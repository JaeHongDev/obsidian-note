---
cssclasses:
  - my_style_width_100
---

- 엔티티들은 대부분 다른 엔티티와 연관관계를 가집니다.
- 객체는 참조를 사용해서 관계를 맺고 테이블은 외래 키를 사용해서 관계를 맺는다. 

- 방향
	- 두 엔티티의 관계를 표현할 때 어느 한쪽이 참조하는 것을 단방향 관계라고 한다.
	- 두 엔티티의 관계를 표현할 때 양쪽이 서로 참조하는 것을 양방향 관계라고 한다
- 다중성
	- 다대일
	- 일대다
	- 일대일
	- 다대다
	- 위 용어를 다중성이라고 이야기합니다. 
- 연관관계의 주인
	- 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 정한다. 



[[단방향 연관관계]]
[[양방향 연관관계]]

[[연관관계의 주인]]


# left join fetch 트러블 슈팅

사이드 프로젝트 구현과정에서 `@oneToMany` 연관관계를 가진 데이터를 페이지네이션으로 가져와야 하는 기능이 있었습니다. 
쉽게 쉽게 구현하자는 생각에 간단하게 `left join fetch`와 `Pageable`를 적용해서 기능을 구현했지만 
`# HHH000104: firstResult/maxResults specified with collection fetch`
경고가 발생했습니다. 

경고 내용을 보면 모든 컬렉션을 가져와서 페이징을 처리하고 있습니다. 
메모리에서 정렬을 처리하다보니 데이터베이스의 데이터가 많다면 OOM이 발생하게 됩니다. 

데이터가 많지 않다보니 그냥 놔두고 마지막에 할까? 고민했지만 생각보다 애플리케이션이 느려지는 것 같아 문제를 해결해보고자 시도했습니다. 


### 데이터 구조

![[Pasted image 20240521000801.png]]
TechBlogPost 1 <-> N Tag N <-> 1 Category

## 쿼리 구조

![[Pasted image 20240521001122.png]]


## 왜 이런 문제가 발생할까?

`*ToMany` 쿼리의 경우 JPA는 전체 데이터 건수를 예측할 수 없습니다. 

![[Pasted image 20240521004224.png]]

위 테이블 구조에서 Post는 몇 개의 PostTag를 가질지 예측할 수 없습니다. 

![[Pasted image 20240521004329.png]]

만약 위 데이터 처럼 첫 post는 2개이 postTag를 가지고 두 번째 Post는 3개의 PostTag를 가지고 있을 때 `SELECT` 쿼리를 사용하면 총 5개의 Row가 발생합니다. 

5개의 Row가 결과로 반환됐지만 JPA는 어디서 끊어야 할지 알 수 없습니다. 
만약 두 번째 post가 10개의 postTag를 가진다면 12개의 row가 반환되기 때문에 실제 쿼리를 조회하기 전까지 어디서 끊어야 할지 알 수 없기 때문입니다. 

QueryDSL을 사용하면 이 문제를 간단하게 해결할 수 있지만 JPA만 가지고 문제를 해결하고 싶었습니다. 

그래서 자료들을 추가적으로 찾아봤을 떄 `BatchSize`를 활용하는 방법이 있습니다. 
![[Pasted image 20240521005035.png]]
Batch Size를 설정해주면 in절에 들어갈 데이터의 개수를 지정해줄 수 있습니다. 

이 경우 지연 로딩된 엔티티를 최초 조회해서 사용하는 시점에 `BatchSize`크기만큼 미리 로딩합니다.
![[Pasted image 20240521005307.png]]
> 배치 크기는 식별자로 이 클래스의 인스턴스를 가져오기 위한 '배치 크기'를 지정합니다. 아직 로드되지 않은 인스턴스는 한 번에 배치 크기만큼 로드됩니다

첫 데이터를 로딩한 다음 필요한 데이터의 식별자를 저장해둔 다음 `in` 쿼리를 통해서 부족한 데이터를 가져옵니다. 


## 🤔 그러면 batch size를 동적으로 할당할 수 있는 방법은 없나요?

![[Pasted image 20240521010258.png]]

![[Pasted image 20240521011239.png]]

방법은 있지만 권장하지 않습니다. 

### 그러면 페이징 처리할 떄 동적으로 늘어날 경우 어떻게 해야 할까?


# left join 쿼리를 어떻게 매핑할까?
```sql
    select
        o1_0.member_id,
        o1_1.id 
    from
        member_others o1_0 
    join
        member o1_1 
            on o1_1.id=o1_0.others_id 
    where
        o1_0.member_id=?
```

![[Pasted image 20240520194632.png]]

![[Pasted image 20240520194728.png]]

![[Pasted image 20240520194817.png]]

![[Pasted image 20240520194914.png]]

왜 캐시가 있지?

![[Pasted image 20240520195237.png]]

![[Pasted image 20240520212453.png]]


![[Pasted image 20240521155234.png]]

![[Pasted image 20240521160343.png]]
![[Pasted image 20240521160618.png]]


![[Pasted image 20240521180820.png]]