---
cssclasses:
  - my_style_width_100
---

데이터베이스를 사용하고 운영할 떄 가장 중요한 두 가지 요소
1. 확장성
2. 가용성

위 두가지가 중요한 이유는 
1. 대용량 트래픽을 안정적으로 처리하기 위해서는 데이터베이스 서버의 확장이 필수적
2. 사용자가 언제든지 안정적인 서비스를 이용하려면 DBMS서버를 포함한 하위 시스템들의 가용성이 뒷받침 돼야 함

이렇게 가용성과 확장성을 위해 사용되는 기술이 `복제(Replication)`이다. 


# 복제

## 정의
복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것을 말한다. 
- 소스 서버: 원본 데이터를 가진 서버
- 레플리카 서버
	- 소스 서버에서 데이터 및 스키마에 대한 변경이 최초로 발생
	- 레플리카 서버에서 이러한 변경 내역을 소스 서버로부터 전달받은 다음 가지고 있는 데이터에 반영하는 도익화 작업을 한다.

일반적으로 서비스에 사용될 DB서버를 구축할 떄는 메인으로 사용될 소스 서버 안 대와 복제를 통해 소스 서버와 동일한 데이터를 가진 레플리카 서버를 한 대 이상 함께 구축한다.

## 목적
1. 스케일 아웃(Scale-out)
	- 사용자가 늘어남에 따라 트래픽도 증가
	- 트래픽을 처리하기 위한 방법 중 하나로 서버의 사양을 업그레이드가 있으며 이를 `스케일 업`이라고 한다.
		- ⚠ 임시방편
	- 스케일 업이 아닌 동일한 데이터를 가진 DB서버를 추가한다면 실행되는 쿼리를 분산시킬 수 있으며 이를 `스케일 아웃`이라고 한다.
2. 데이터 백업
	- 운영상의 실수로 실제 데이터에 문제가 발생할경우 대비하기 위한 백업이 있다. 
	- 일반적으로 DBMS에서는 백업 프로그램이 실행되어 백업이 실행되는데 실제 쿼리 처리와 백업 프로그램의 실행으로 인해 실제 쿼리 성능에 영향이 갈 수 있다.
	- 이런 문제점을 해결하기 위해 레플리카서버를 백업서버를 두는 대비책으로 사용할 수 있다.
3. 데이터 분석
	- DB서버에서는 기본적으로 서비스에서 사용되는 쿼리들이 실행되지만 분석용 쿼리도 실행된다. 
	- 분석용 쿼리의 경우 굉장히 복잡하고 무거운 경우가 대부분이기에 서버의 리소를 많이 사용하는데 이로 인해 분석용 복제 서버를 두는 것으로 쉽게 해결할 수 있다.
4. 데이터의 지리적 분산
	- 서비스에서 사용되는 애플리케이션 서버와 DB서버는 지리적으로 근접한 위치에 존재할 수도 있고, 혹은 장거리로 떨어져 있을 수 있습니다.
	- 이런 경우 두 서버 간의 통신 시간은 떨어진 거리만큼 비레해서 늘어나며 속도에도 영향을 받기 때문에 애플리케이션 서버와 DB서버가 가깝게 위하는 것이 좋기 때문에 떨어져 있는 dB서버의 위치를 복제 서버를 사용해 응답 속도를 개선할 수 있다. 


## 아키텍처

### 용어 정리
- `바이너리 로그`: MySQL 서버에서 발생하는 모든 변경 사항을 기록하는 로그
	- 데이터 변경 내역 뿐만 닌 데이터베이스 테이블 구조 변경, 계정 권한의 변경 정보까지 기록
- `이벤트`: 바이너리 로그에 기록된 각 변경 정보
- `릴레이 로그`
	- 레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 따로 로컬 디스크에 저장해둔 파일
	- 래플리케이션 IO스레드에 의해 작성되는 파일
	- 소스 서버의 바이너리 로그에서 읽어온 이벤트 정보가 저장
	- 인덱스 파일과 실제 이벤트 정보가 저장돼 있는 로그 파일들로 구성
	- 레플리케이션 SQL 스레드에 의해 레플리카 서버에 적용
- `커넥션 메타 데이터`
	- 레플리케이션 IO스레드에서 소스 서버에 연결할 때 사용하는 아래의 값이 담겨져 있다.
		- DB 계정 정보
		- 현재 읽고 있는 소스 서버의 바이너리 파일명
		- 파일 내 위치
	- `mysql.slave_master_info` 테이블에 저장
- `어플라이어 메타데이터`
	- 레플리케이션 SQL 스레드에서 릴레이 로그에 저장된 소스 서버의 이벤트들을 레플리카 서버에 적용하는 컴포넌트
	- 최근 적용된 이벤트에 대해 해당 이벤트가 저장돼 있는 아래의 내용을 가짐
		- 로그 파일명
		- 파일 내 위치 정보
	- 레플리케이션 SQl 스레드가 이 정보를 사용
	- `mysql.slave_relay_log_info` 테이블에 저장
- 
- `바이너리 로그 덤프 스레드`: 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행 (다 읽은 이후에는 잠금 해제)
- `레플리케이션 IO 스레드`: 복제가 시작되면 생성되는 스레드(복제 종료 후 소멸)로 소스 서버의 바이너리 로그 덤프 스레드로 부터 로그 이벤트를 가져와 로컬 서버의 파일(릴레이 로그)로 저장하는 역할을 합니다. 
- `레플리케이션 SQL 스레드`: IO스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다.


![[Pasted image 20240407180443.png |600]]

- MySQL의 복제는 소스 서버에서 생성된 바이너리 로그가 레플리케이션 서버로 전송 
- 전송된 바이너리 로그를 레플리카 서버에서 로컬 디스크에 저장한 뒤 자신이 가진 데이터에 반영하는 동기화 과정을 수행
- 레플리카 서버에서 레플리케이션 IO스레드와 SQL스레드는 서로 독립적으로 동작
	- SQL스레드에서 이벤트를 적용하는게 느리더라도 IO스레드와 무관하여 정상적으로 빠르게 소스 서버로부터 이벤트를 읽어올 수 있다.
	- 레플리카 서버에서 소스 서버의 변경 사항들이 적용되는 것은 소스 서버가 동작하는 것과 별개로 진행되므로 레플리카 서버에 문제가 생기더라도 서버는 영향을 받지 않는다.
	- 그러나 소스 서버에 문제가 생겨 레플리카 서버의 IO스레드가 정상적으로 동작하지 않게 되면 복제는 에러를 발생시키고 중단

- 커넥션 및 어플라이어 메타데이터는 MySQL의 아래 시스템 변를 통해 데이터를 관리할지 성정할 수 있다. 
	- `master_info_repository`
	- `relay_log_info_repository`
- 설정 가능한 값으로는 FILE, TABLE의 두 가지가 있습니다. 
	- FILE: 커넥션 메타데이터와 어플라이어 메타데이터는 각각 MySQL의 데이터 디렉터리에서 아래 파일로 관리된다. 
		- master.info
		- relay-log.info
		- 위 두 파일의 경로는 --master-inf-file 옵션과, relay_log_info_file 시스템 변수를 이용해 지정할 수 있다. 
	- TABLE: MySQL의 `mysql` 데이터베이스 내 `slave_master_info` , `slave_relay_log_info` 테이블에 데이터가 저장된다.
		- InnoDB 스토리지 엔진 기반의 테이블로 관리되고 특히 레플리케이션 SQL 스레드가 트랜잭션을 적용할 때
		- `slave_relay_log_info `테이블의 데이터도 같은 시점에 아토믹하게 업데이트된다.
		- 이런 상황을 `크레시 세이프 복제`라고 한다.
	- 두 시스템 변수들은 MySQL 8.0.2버전부터 기본값이 TABLE로 변경됐으며, FILE은 Deprecate될 예정이다. 
		- Deperecated된 이유는 IO스레드와 SQL 스레드가 동작할 때 서버가 비정상 종료되는 경우 실제 적용된 바이너리 로그 위치와 파일에 저장된 위치가 일치하지 않거나 파일 자체가 손상되어 복제가 재시작되지 못하는 경우가 있었다. 


## 복제 타입

MySQL의 복제는 소스 서버의 바이너리 로그에 기록된 견경 내역을 식별하는 방식에 따라 다음과 같이 나뉩니다.
- 로그 파일 위치 기반 복제 
- 글로벌 트랜잭션 ID 기반 복제

### 바이너리 로그 파일 위치 기반 복제
- 바이너리 로그 파일 위치 기반 복제는 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태입니다. 
- 바이너리 로그 파일 위치 기반 복제에서는 이벤트 하나하나를 소스 서버의 바이너리 로그 파일명과 파일 내에서 위치값의 조합으로 식별한다. 
	- 이렇게 하는 이유는 복제를 일시적으로 중단할 수 있고 재개할 때 마지막으로 적용했던 이벤트 이후의 이벤트들부터 다시 불러올 수 있다. 
- MySQL server_id 값은 이벤트가 최초로 발생한 MySQL 서버를 식별하는 정보이다.
#### 바이너리 로그 파일에서 위치를 식별하는 이유
![[Pasted image 20240407185325.png]]
- 복제를 처음 구축할 때 레플리카 서버에 서버의 어떤 이벤트부터 동기화를 수행할 것 인지 설정해야 함
- 복제가 설정된 레플리카 서버는 소스 서버의 어느 이벤트까지 로컬 디스크로 가져왔고 또 적용했는지 정보를 관리, 소스 서버에 해당 정보를 전달해 그 이후의 바이너리 로그 이벤트들을 가져온다.
- 그렇기에 소스 서버에서 발생한 각 이벤트에 대한 식별이 반드시 필요함

#### 바이너리 로그 파일 위치 기반의 복제 구축
MySQL 서버 간에 복제를 설정할 때는 각 서버에 데이터 존재 여부와 복제를 활용할 방법에 따라 복제 설정 과정 및 구축 방법이 달라진다.

##### 설정 준비
- MySQL 복제를 사용하려면 소스 서버에서 바이너리 로그가 활성화돼 있어야 함
- mysql 서버가 고유한 server_id값을 가져아한다. 
![[Pasted image 20240407185913.png]]

소스 서버에서 바이너리 로그가 정상적으로 기록되고 있는지 확인하는 방법
![[Pasted image 20240407185940.png]]
- file: 현재 사용되고 있는 바이너리 로그 파일의 이름
- position: 로그의 위치

레플리카 서버 설정
![[Pasted image 20240407190313.png]]
![[Pasted image 20240407190332.png]]


복제 계정 준비
- 복제용 계정: 레플리카 소스 서버로부터 바이너리 로그를 가져오기 위해 사용되는 DB계정![[Pasted image 20240407190459.png]]

데이터 복사
소스 서버의 데이터를 레플리카 서버로 가져와서 적재할 때 `mysqldump`를 사용합니다. 
참고로 복사할 떄 아래 옵션을 필수로 설정해야 합니다. 
- `--single-transaction`
	- 데이터를 덤프할 때 하나의 트랜잭션을 사용해 덤프가 진행
	- 테이블 혹은 레코드에 잠금을 걸지 않고 InnoDB 테이블들에 대해 일관된 데이터를 덤프 받음
- `--master-data`
	- 덤프 시작 시점의 소스 서버의 바이너리 로그 파일명과 위치 정보를 포함하는 복제 설정 구문이 덤프 파일 헤더에 긹될 수 있게 하는 옵션
	- MySQL 서버에서 `FLUSH TABLES WITH READ LOCK` 명령을 실행해 글로벌 락을 간다.
		- 바이너리 로그의 위치를 순간적으로 고정시키는 목적
	- 옵션은 1과 2로 설정할 수 있습니다.
		1. 덤프 파일 내의 복제 설정 구문(`CHANGE REPLICATION SOURCE TO`, `CHANGE MASTER TO`)이 실제 실행가능한 형태로 기록
		2. 해당 구문이 주석으로 처리되어 참조만할 수 있는 형태로 기록
덤프 예시 명령어
![[Pasted image 20240407191013.png]]
데이터 덤프 완료 후 sql 파일을 레플리카 서버로 옮겨서 적재하는 방법
![[Pasted image 20240407191109.png]]

##### ⚠ 주의
![[Pasted image 20240407191227.png]]


복제 시작

![[Pasted image 20240407191931.png]]

레플리카 서버 데이터 적재 완료 시점에 소스 서버와 레플리카 서버의 데이터 상태가 다른데 다음의 동기화 과정을 수행합니다. 
- 현재 50정도 레플리카 서버의 데이터는 지연된 상태이다.
- 복제를 설정하는 명령은 `CHANGE REPLICATION SOURCE TO` 명령을 사용하여 mysqldump로 백업 받은 파일의 헤더 부분에서  참조한다. 
![[Pasted image 20240407192453.png]]
![[Pasted image 20240407192502.png]]

각 옵션을 보면 
- `SOURCE_HOST`는 레플리카 서버에서 복제 연결할 소스 서버를 의미하며 소스 서버의 IP혹은 도메인 정보를 넣을 수 있다.
- `SOURCE_PORT(MASTER_PORT)`는 소스 서버에서 구동 중인 MySQ 서버의 포트 번호를 넣을 수 있다.
- `SOURCE_USER, SOURCE_PASSWORD` 복사용 계정 정보
- `SOURCE_LOG_FILE, SOURCE_LOG_POST`는 로그 파일명과 위치값을 기록
- `GET_SOURCE_PUBLIC_KEY`는 RSA키 기반 비밀번호 교환 방식의 통신을 위해 공개키를 소스 서버에 요청 여부를 표현
	- 문제점 있음 (440p 마지막 줄)
![[Pasted image 20240407192920.png]]
![[Pasted image 20240407192930.png]]



### 글로벌 트랜잭션 아이디 기반 복제
 - MySQL 5.5 버전까지는 복제를 설정할 때 바이너리 로그 파일 위치 기반 복제 방시만 지원
	 - 각각의 이벤트들이 바이너리 로그 파일명과 파일 내 위치 값의 조합으로 식별
		 - 문제점
			 - 바이너리 로그 파일이 저장돼 있는 소스 서버에서만 유효
			 - 동일한 이벤트가 레플리카 서버에서도 동일한 파일명의 동일한 위치에 저장된다는 보장을 할 수 없음
			 - 복제에 투입된 서버들마다 동일한 이벤트에 대해 서로 다른 식별 값을 가진다.
- 복제를 구성하는 서버들이 서로 호환되지 않는 정보를 이용해 복제를 진행함으로써 복제의 토폴로지를 변경하는 작업이 불가능할 때가 있다.
	- 복제 토폴로지 변경은 주로 복제에 참ㅇ한 서버들 중에서 일부 서버에 장애가 발생했을 때 필ㅇ함
	- 토폴로지 변경이 어렵다는 것은 그만큼 복제를 이용한 쟁애 복가 어렵다는 것을 의미함
	 - HMA, MNN, Orchestrator같은 MySQL HA 솔류션들은 내부적으로 복잡한 바이너리 로그 파일 위치 계산을 수행하거나 떄로는 포기해버리는 형태로 처리
해결책
- 소스 서버에서 발생한 이벤트들이 복제에 참여한 모든 MySQL서버에서 동일한 고유 식별값을 가지는 방법잉 있다.
- 이 떄 부여된 식별 값을 글로벌 트랜잭션 아이디(Global Transaction Identifier, GTID)라고 한다. 
- 해당 식별값을 기반으로 복제하는 형태를 GTID 기반 복제라고 한다. 
- MySQL 5.5버전까지 바이너리 로그 파일 위치 기반 복제 방식만 지원
	- 문제점
		- 바이너리 로그 파일 명과 파일 위치 값의 조합으로 식별하면 바이너리 로그 파일이 저장돼 있는 소스 서버에서만 유효
			- 동일한 이벤트가 레플리카 서버에서도 동일한 파일명, 동일한 위치에 저장된다는 보장을 할 수 없는 레플리카사 버서들마다 동일한 이벤트에 대해 다른 식별값을 가짐
		- 이런 방식은 토폴로지를 변경하는 작업은 불가능한 상황이 있다. 
			1. 복제 토폴로지 변경은 복제에 참여한 서버들 중에서 일부 서버에 장애가 발생했을 때 필요
				 - 복제가 어렵다는 것은 복제를 이용한 장애 복구가 어렵다는 것을 의미
#### GTID의 필요성
- 앞서 바이너리 로그 파일 위치 기반 복제 방식의 문제점 설명
- 복제 토폴로지를 예시로 보면 하나의 소스 서버에 두 개의 레플리카 서버가 연결돼 있는 토폴로지 (읽기 부하 분산 및 통계 혹은 배치용으로 구성)
- ![[Pasted image 20240408165640.png]]
- A의 바이너리 로그와 레플리카 서버 B는 동기화가 완료된 상태지만 C는 지연된 상태
- 이때 소스 서버인 A에서 장애가 발생하면서 서버가 비정상적으로 종료됐다고 가정
	- B,C 중 하나를 소스 서버로 승격하고, A서버로 연결돼 있던 클라이언트 커넥션을 새로 승격된 소스 서버로 교체해야 함
	- 여기서 레플리카 서버 B를 소스 서버로 승격
	- C서버는 동기화되지 않은 상태여서 SELECT용도로 사용할 수 없음
![[Pasted image 20240408170531.png]]

- B서버가 새로운 소스 서버로 승격되면서 쿼리 요청이 B서버로 들어오기 시작
- B서버는 SELECT 쿼리의 부하 분사용이기 떄문에 분산 SELECT 쿼리 처리와 더불어 기존 소스 서버의 역할까지 겹쳐 과부하가 발생
- B서버의 SELECT 쿼리를 C서버로 옮겨서 실행하면 되지만 C서버는 동기화가 되지 않은 상태로 촤종 시점까지 동기화할 수 없다.
- 별도의 방법을 사용하는 경우 
	- 레플리카 서버 B의 릴레이 로그가 지워지지 않고 남아있다면 B서버의 릴레이 로그를 가져와서 필요한 부분만 실행하면 복구가 가능하지만 MySQL서버의 릴레이 로그는 불필요한 시점에 자동으로 삭제되므로 제한적인 방법이다.

GTID를 사용한 방법
![[Pasted image 20240408170846.png]]

- 소스서버 A와 레플리카사 서버 B가 완전히 복제된 상황
- 레플리카 서버 C는 이전 GTID만 까지만 동기화 된 상태
- 이 때 소스 서버 A에 장애가 발생하면 C서버의 소스 서버가 도도록 C서버에서 
	- `CHANGE REPLICATION SOURCE TO SOURCE_HOST='B', SOURCE_PORT=3306` 명령을 실행
	- A서버의 GTID와 C서버의 GRID가 동일하며 현재 트랜잭션까지 실행했으므로 B서버로 복제를 다시 연결할 때도 B서버에서 이전 GTID 이후의 바이너리 로그 이벤트를 2가져와 동기화하면 된다. 
- 이렇게 레플리카 서버 C가 새로운 소스 서버인 B와 동기화할 수 있도록 준되면 클라이언 쿼리 요청을 B서버와 C서버로 나눠서 실행할 수 있도록 한다. 

#### 글로벌 트랜잭션 아읻 

바이너리 로그 파일-> 물리적인 방식
글로벌 트랜잭션 아이디 -> 논리적인 의미

MySQL의 GTID는 서버에서 커밋된 각 트랜잭션과 연결된 고유 식별자로 해당 트랜잭션이 발생한 서버에서 고유할뿐만 아니라 그 서버가 속한 복제 토폴로지 내 모든 서버에서 고유함

GTID는 커밋되어 바이너리 로그에 기록된 트랜잭션에 한해서만 할당되며, 데이터 읽기만 수행하는 SELECT 쿼리 혹은 sql_log_bin 설정이 비활성화돼 있는 상태에서 발생한 트랜잭션은 바이너리에 기록되지 않으므로 GTID가 할당되지 않는다. 

GTID는 {소스 아이디}:{트랝개션 아이디}의 조합
![[Pasted image 20240408173001.png]]

소스 아이디는 트랜잭션이 발생된 소스 서버를 식별하기 위한 값
- server_uuid 시스템 변수 값을 사용
트랜잭션 아이디는 서버에서 커밋된 트랜잭션 순서대로 부여되는 값으로 1부터 1씩 단조 증가 형태로 발급
- auto.cnf파일에 server_uuid값이 저장

현재 사용되고 있는 GTID값을 확인하는 방법
1. mysql.gtid_executed 테이블 조회
![[Pasted image 20240408173246.png]]
2. show global variables
![[Pasted image 20240408173316.png]]
3. show master status
![[Pasted image 20240408173405.png]]


GTID는 각각의 값이 하나씩 개별로 보여지거나 연속된 값들인 경우 범위로 보여지는데 이를 GTID Set이라고 합니다. 
- 기본적으로 동일한 서버에서 생성된 연속하는 GTID값은 축소시켜 범위로 보여진다.
- 범위 값과 단일 값이 하나의 표현식으로 나타나며 콜론으로 구분
![[Pasted image 20240408173521.png]]
- 또한 GTID셋에는 서로 다른 UUID를 가지는 GTID값들을 포함할 수 있다.
	- 서버의 UUID값이 기존과는 다른 값으로 변경됐거나 혹은 여러 서버에서 데이터를 복제하는 경우 여기에 해당함
![[Pasted image 20240408173620.png]]


mysql.gtid_executed 테이블은 단순히 현재 실행된 GTID값을 저장하는 것 이외에 레플리카 서버에서 바이너리 로그가 비활성화돼 있는 상태에서 GTID 기반의 복제를 사용할 수 있게 하고, 예게치 못한 문제로 바이너리 로그가 손실됐을 때 GRID값이 보존될 수 있게 한다. 
- 5.7.5버전에서 처음 도입 InnoDB스토리지 엔진으로 설정
- MySQL 8.0.17이상 버전을 사용하는 경우에는 매 트랜잭션이 커밋될 때마다 Mmysql.gtid_executed 테이블에도 GTID값이 바로 저장된다.
- 이전 버전의 경우 혹은 InnoDB가 아닌 다른 스토리지 엔진을 사용하는 경우 GTID값은 바이너리 로그 파일이 로테이션되거나 MySQK 서버가 종료될 때만 mysql.gtid_executed 테이블에 저장된다. 
- 이렇게 mysql.gtid_executed 테이블에 매 트랜잭션이 커밋될 때가 아닌 특정한 시점에만 GTID값이 저장되는 경우 mysql.gtid_executed 테이블에 최근까지 사용된 GTID값이 반영되지 않기 때문에 마지막에 실행된 트랜잭션의 GRID값을 조회할 때는 gtid_executed 시스템 변수 값을 확인해야 함
![[Pasted image 20240408174451.png]]
![[Pasted image 20240408174459.png]]




#### 글로벌 트랜잭션 아이디 기반의 복제 구축
- MySQL 서버에서 GTID를 활성화하는 것과 GTID기반의 복제를 사용하는 것은 별개이며 복제를 위한 조건 중 하나이다.


##### 설정 준비
GTID 기반의 복제를 사용하려면 복제에 참여하는 모든 MySQL 서버들이 GTID가 활성화돼 있어야 하며 각 서버의 server_id 및 server_uuid가 복제 그룹 내에서 고유해야 한다.
![[Pasted image 20240408175034.png]]


중요
> 설정 파일에는 반드시 gtid_mode=ON, enforce_grid_consistency=on을 명시해야 함
>
> 명시 하지 않는 경우 에러가 발생하면서 MySQL 서버는 기동하지 않는다. 
![[Pasted image 20240408175143.png]]


![[Pasted image 20240408175155.png]]


#### 복제계정 준비
![[Pasted image 20240408175217.png]]

#### 데이터 복사
mysqldump를 사용해 소스 서버의 데이터를 덤프해서 레플리카 서버에 적재
![[Pasted image 20240408175243.png]]


MySQl 서버는 GTID 복제와 관련해서 대표적으로 2개의 시스템 변수를 가진다.
GTID가 활성화된 소스 서버에서 mysqldump로 데이터를 덤프받아 레플리카 서버를 구축하는 경우, 덤프가 시작된 시점의 소스 서버의 GTID값을 레플리카 서버에서 다음 2개의 시스템 변수에 설정해야 복제를 시작할 수 있다. 
![[Pasted image 20240408175350.png]]

GTID 기반 복제에서 레플리카서버는 gtid_executed 값을 기반으로 다음 복제 이벤트를 소스 서버로 가져온다.
gtid_executed는 읽기 전용 변수로 사용자가 변경할 수 없으며, 사용자는 gtid_purged변수값만 수정 가능
![[Pasted image 20240408180027.png]]

![[Pasted image 20240408180035.png]]

![[Pasted image 20240408180046.png]]

![[Pasted image 20240408180057.png]]



#### 복제 시작
레플리카 서버의 초기 데이터가 모두 준비됐지만 레플리카 서버에 복구된 데이터는 소스 서버에서 백업을 실행했던 과거 시점의 데이터이며 백업 시점 이후에 새롭게 변경된 데이터는 레플리카서버에 적용돼 있지 않은 상태이며, 아직 실시간으로 변경되는 데이터도 레플리카 서버로 복제되지 않습니다. 