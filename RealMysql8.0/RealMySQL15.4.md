---
cssclasses:
  - my_style_width_100
---

MySQL Enum과 Set은 모두 문자열 값을 MySQL 내부적으로 숫자 값으로 매핑해서 관리하는 타입

> 실제 데이터베이스에서는 이미 인코딩된 알파벳이나 숫자 값만 저장되므로 그 의미를 바로 파악하기가 쉽지 않다는 단점이 있다. -> 이거 무슨 말임?

# Enum
- Enum타입은 테이블의 구조에 나열된 목록 중 하나의 값을 가질 수 있다.
- Enum타입의 가장 큰 용도는 **코드화된 값을 관리**하는 것
- MySQL 서버가 실제로 값을 디스크나 메모리에 저장할 때는 값에 **매핑된 정숫값**을 사용합니다.
- Enum타입에 사용할 수 있는 최대 아이템의 개수는 **65,535**개이다.
- 아이템의 개수가 255개 미만이면 ENUM타입은 저장 공간으로 1바이트를 사용하고, 그 이상인 경우에는 2바이트까지 사용한다.
- Enum타입은 **실제 테이블에 저장된 코드 값이 어떤 의미인지 이해하기 쉽지 않았던 일단 타입의 문제를 해결할 수 있는 유용한 타입**
- Enum타입은 저장해야 하는 아이템 값(문자열)이 길면 길수록 저장 공간을 더 많이 절약할 수 있다.
	- 🤔 Enum은 조회 속도가 균등할까?
## 단점
- Enum타입의 가장 큰 단점은 칼럼에 저장되는 문자열 값이 테이블 구조이기 때문에 Enum타입에 새로운 값을 추가한다면 테이블의 구조를 변경해야 한다
	- JPA를 사용했을 때 크게 와닿았던 문제 (JPA, ENUM값 추가했을 때 문제가 발생)
	- 🤔 Enum의 값은 어떤 방식으로 저장될 까? innocheck
	- MySQL5.6 버전 이전에는 Enum 타입의 아이템이 새로 추가되면 테이블을 리빌드 해야 했지만
		- 이후 부터는 새로 추가하는 아이템이 Enum 타입의 제일 마지막으로 추가하는 형태라면 테이블의 구조 변경만으로 즉시 완료된다.
			- 🤔 어떻게 하면 enum의 원소를 쉽게 추가할 수 있을까?
- **Enum 타입의 컬럼값으로 정렬을 수행하면 매핑되기 전의 문자열 값 기준으로 정렬되는 것이 아닌 코드 값으로 정렬이 수행된다.**
	- 이 경우  `CAST`를 활용해서 정렬 기준을 문자열이 되도록 변환해줘야 합니다
		- `order by CAST(ENUM AS CHAR)`

## 장점
- 테이블 구조에 정의된 코드 값만 사용할 수 있도록 강제할 수 있습니다.
- 데이터베이스 서버의 디스크 저장 공간의 크기를 줄여준다. 
	- 디스크 데이터는 InnoDB 버퍼 풀로 적재돼야 쿼리에서 사용할 수 있기 때문에 많은 메모리가 소모되기 돼서 용량이 준다면 그만큼 메모리 사용량을 줄일 수 있다. 
	- 백업, 복구 시간을 줄일 수 있다. 


## 이미지(쿼리 예시임)
![[Pasted image 20240331171623.png | 600]]
![[Pasted image 20240331171710.png]]
![[Pasted image 20240331171814.png]]




- enum의 문제점 (정리하기)
# Set
## 특징
- enum과 동일한 테이블의 구조에 정의된 아이템을 정숫값으로 매핑해서 저장하는 방식
- Enum과 달리 1개 이상의 값을 가질 수 있음
	- MySQL서버가 내부적으로 BIT-OR연산을 거쳐 1개 이상의 선택된 값을 저장한다
	- Bit or연산을 활용하기 때문에 여러 저장 공간을 가지는 것이 아닌 
		- 1바이트 - 8개 이하
		- 2바이트 - 9 to 16
		- 3바이트 - 17 to 24
		- ... 최대 8바이트까지 저장
		- 🤔 그럼 기존 저장공간이 바뀌면 어떻게 바뀜?

생성 방법
- `column_name SET(...원소)`

검색
- `find_in_set(찾을 원소, 컬럼)`
- `select * from table where column='원소1,원소2'` : 원소1, 원소2가 저장된 위치가 동일해야 검색 가능


## 단점
- Enum과 같이 Set타입이 추가되는 경우 테이블의 읽기 잠금과 리빌드 작업이 발생합니다. 
	- Enum과 동일하게 중간 위치에 새로운 아이템이 추가되어야 읽기 잠금 발생
- Set은 Enum과 같이 맨 뒤에 새로운 아이템이 추가되는 경우 INSTANT 알고리즘으로 처리가 가능하지만, SET타입의 아이템 개수가  9개로 늘어날 때 잠금 작업이 필요하다.
	- 1바이트 -> 2바이트


# Text와 BLOB

## 특징
- MySQL에서 대량의 데이터를 저장하려면 TEXT,BLOB을 사용


## TEXT와 BLOB의 차이
- TEXT타입은 **문자열**을 저장하는 대용량 컬럼으로 문자 집합이나 콜레이션을 가집니다.
- BloB타입은 **이진 데이터 타입**으로 별도의 문자 집합이나 콜레이션을 가지지 않는다.


## TEXT, BLOB을 사용하는 상황
- 컬럼 하나에 저장되는 문자열이나, 이진 값의 길이를 예측할 수 없이 클 때 Text, Blob을 사용한다. (게시글의 본문)
	- 참고로 값의 크기가 4000바이트를 넘을 때 반드시 BLOB이나 텍스트를 사용해야 하는 것은 아님
		- 레코드가 64KB를 넘지 않는 한도 내에서 VARCHAR의 길이 제한은 없다. 
	- 🤔 한 컬럼안에 너무 많은 텍스트가 있는 경우 어떻게 처리해야 할까?
- MySQL에서는 버전에 따라 조금씩 차이는 있지만 하나의 레코드는 전체 크기가 64kb를 넘어설 수 없다. varchar, varbinary와 같은 가변 길이 컬럼은 최대 저장 가능 크기를 포함해 64kb로 제한되는데 이보다 더 큰 값을 저장하고 싶다면 TEXT,BLOB타입으로 전환해야 한다. 


## 인덱스

- BLOB, TEXT 타입의 컬럼에 인덱스를 생성할 수 있다. 
- 추천하지 않지만 생성해야 한다면 몇 바이트 까지 허용할지 정해야 하며 최대 크기를 넘어서는 경우 인덱스를 사용할 수 없다.
	- 엔진 별 최대 크기 비교
		- MyISAM - 1000바이트
		- (REDUNDANT, CMOPACT  로우 포맷) innoDB - 767바이트
		- (DYNAMIC, COMPRESSED 로우 포맷) innoDB - 3072바이트
	- 시스템 변수
		- `max_sort_length` : 기본값이 1024바이트로 설정, 이 값에 의해 정렬되는 길이가 결정, 가능한 줄이는 것이 빠른 검색에 유리함

## 임시테이블 관점
- 임시 테이블은 메모리 혹은 디스크에 저장
	- 메모리에 저장되는 경우는 `internal_tmp_mem_storage_engine` 시스템 변수에 영향을 받음
		- `memory`: TEXT, BLOB을 원하지 않음
		- `temptable` TEXT,BLOB 지원 <- 가능한 사용

## DML관점
- insert, update 문장 중에서 BLOB, TEXT 컬럼을 조작하는 sql의 경우 문제가 발생합니다.
	- 이거 문제로 내면 괜찮을 듯? 
	- mysql 서버의 `max_allowd_packet` 시스템 변수에 설정된 값보다 큰 sql은 서버로 전송되지 못한다. 
	- 대용량 blob, text 컬럼을 사용하는 쿼리가 있다면 `max_allowed_packet`을 사용하는 것을 권장 
- TEXT, BLOB 타입 컬럼의 값은 테이블의 `ROW_FORMAT` 옵션에 영향을 받습니다.
	- 설정하지 않았다면 `innodb_default_row_format`의 값을 사용 (dynamic)
- MySQL은 사용 가능한 모든 `ROW_FORMAT`을 가능한 TEXT, BLOB 컬럼의 값을 다른 레코드와 같이 저장하려고 하지만 레코드의 최대 길이로 인해 불가능하다. 

### COMPACT 포맷의 문제점
- MySQL 5.7에서 테이블 기본 `ROW_FORMAT`은 `COMPACT` -> `DYNAMIC`으로 변경
- `COMPACT` 포맷에서 저장할 수 있는 레코드 하나의 최대 길이는 데이터 페이지의 크기 16kb의 절반이다.
	- 레코드의 전체 길이가 16KB의 절반을 넘어서면 용량이 큰 순서대로 외부 페이지로 옮겨 8126바이트 이하로 맞춘다.
![[Pasted image 20240402153436.png]]
1. fd_blob, fd_text 총 길이는 6000바이트로 모두 프라이머리 키 페이지에 같이 저장
2. fd_text의 길이가 너무 길어 Text 컬럼은 외부 페이지로 저장
3. fd_blob, fd_text모두 외부 페이지로 저장

- blob, text컬럼이 16kb(16000)를 넘어서는 경우 MySQL 서버는 컬럼의 값을 나눠서 여러 개의 외부 페이지에 저장하고, 각 페이지를 체인으로 연결합니다. 
	![[Pasted image 20240401154712.png]]
- blob, text 컬럼을 외부 페이지로 저장하는 경우 MySQL 서버는 compact, redundant 레코드 포맷을 사용하는 테이블에서는 외부 페이지로 저장된 TEXT,BLOB 컬럼의 앞쪽 768 바이트만 잘라서 저장합니다. 
- DYNAMIC, COMPRESEED 레코드 포맷의 BLOB 프리픽스는 인덱스를 생성할 때 도움이 되기도 하지만 BLOB이나, TEXT 컬럼을 가진 테이블의 저장효율을 낮추게 될 수있다. 

# 공간 데이터 타입
- MySQL에서는 WKT, WKB를 이용해 공간 데이터를 지원한다.
- 지원하는 데이터 타입은 다음고 같다.
	- POINT
	- LINESTRING
	- POLYGON
	- GEOMETRY
	- MULTIPOINT
	- MULTILINESTRING
	- MULTIPOLYGON
	- GEOMETRYCOLLECTION
- POINT, LINESTRING, POLYGON 타입은 하나의 정보만 가질 수 있다.
- GEOMETRY는 POINT, LINESTRING, POLYGON 타입의 수퍼 타입을 3개 타입의 객체 모두 저장할 수 있다. (단 하나의 객체만 가능)
- MULTI 접두사로 시작하는 타입은 종류별로 여러 객체를 저장할 수 있다.
![[Pasted image 20240401155141.png]]


## 공간 데이터 생성
-  MySQL 서버에서는 공간 데이터를 생성할 때 WKT 포맷을 MySQL 서버가 처리할 수 있는 이진 데이터 포맷의 데이터로 변환할 수 있습니다. 
![[Pasted image 20240401155329.png | 600]]

![[Pasted image 20240401155337.png | 600]]

- 각 공간 데이터 생성 함수의 이름에서 `FromText` -> `FromWKB`를 사용하면 `WKT` 대신 `WKB`를 이용한 공간 데이터 객체를 생성할 수 있다. 

## 공간 데이터 조회
- MySQL 서버가 공간 데이터를 조회하는 방법은 다음과 같습니다.
	- 이진 데이터 조회 (WKB 포맷, MySQL 이진 포맷)
	- 텍스트 데이터 조회 (WKT 포맷)
	- 공간 데이터의 속성 함수를 이용한 조회
- 첫 번째, 두 번째는 공간 데이터 타입과 관계없이 `ST_AsText/ST_AsWKT` 함수, 혹은 `ST_AsBinary/ST_AsWKB` 함수를 이용해 조회할 수 있다.

(실제 조회방법은 이전 챕터에서 다뤘습니다)


# JSON 타입
- JONS타입은 MySQL 5.7버전 지원
- JSON 데이터를 문자열로 저장하는 것이 아닌 MongoDB와 같은 바이너리 포맷의 BSON으로 변환해서 저장
	- 🤔 BSON으로 저장하면 몽고 대신 써도 되는거 아님?

## 저장방식 
- MySLQL은 내부적으로 JSON타입의 값을 BLOB타입에 저장합니다.
	- JSON그대로가 아닌 BSON타입으로 변환해서 저장
## 쿼리
![[Pasted image 20240401170042.png | 600]]


'{"a": "x", "b": "y", "c": "z" }'


## 이진 포맷 JSON 데이터 필드
![[Pasted image 20240401170205.png|600]]
![[Pasted image 20240401170215.png|600]]

 - 이진 값으로 표시된 항목이 실제 바이너리 필드 값이며, 각 필드 값의 순서와 길이 , 주소를 표시
 - 주소는 JSON 도큐먼트에서 첫 번째 1바이트를 제외하고 난 다음, 이진 데이터에서 각 필드의 오프셋을 의미함
 - 첫 번째 1바이트를 제외하고 난 다음, 이진 데이토에서 각 필드의 오프셋을 의미함
 - MySQL서버에서 매우 큰 용량의 JSON 도큐먼트가 저장되면 MySQL 서버는 16KB 단위로 여러 개의 데이터 페이지로 나뉘어 저장
 - 이때 대용량 BLOB 데이터는 여러 개의 BLOB 페이지로 나뉘어 저장되는데 MySQL 5.7버전까지는 BLOB 페이지들이 단순 링크드 리스트 처럼 관리 됐다. 

## 부분 업데이트 성능
- MySQL 8.0 버전부터 JSON타입에 대한 부분 업데이트 기능을 제공함
	- JSON_SET
	- JSON_REPLACE
	- JSON_REMOVE
- 필드 변경 작업을 확인하기 위한 기능은 다음 기능으로 **대력적**으로 예측할 수 있습니다.
	- JSON_STORAGE_FREE 
	- JSON_STORAGE_SIZE 

- JSON 컬럼은 내부적으로 BLOB 타입(LONGBLOB - 4GB까지 저장가능함)으로 저장
	- 1MB JSON 데이터를 저장해도 MySQL 서버는 16KB 데이터 페이지를 64개 사용
		- JSON 부분 업데이트를 사용하면 페이지 하나를 변경
		- 사용할 수 없는 경우 64개 데이터 페이지를 다시 디스크로 기록

## JSON 타입 콜레이션과 비교
- JSON 컬럼에 저장되는 데이터와 JSON 컬럼으로부터 가공되어 나온 결과값은
	- `utf8mb4` 문자집합
	- `utf8mb4_bin` 콜레이션 ( 값의 대소문자를 모두 비교)
- 을 가진다.


## JSON 컬럼 선택
- BLOB 타입, TEXT타입에 JSON 문자열을 저장하는 경우 변환없이 디스크에 저장됩니다.
- 그래서 어떻게 JSON을 저장해야 할까?
	- BLOB, TEXT로 저장
		- 장점 X 
			- JSON 타입이 오히려 이진 포맷으로 컴팩션해서 저장하기에 별다른 장점이 없음
	- JSON 컬럼을 사용해서 저장
		- 컬럼의 속성이 상이해 정규화로 표현하기 어려운 경우
	- 정규화된 컬럼을 저장
		- 변경이 잦고 추가가 빈번하며 저장공간을 효율적으로 활용해야 하는 경우

œ
# 가상 컬럼
- MySQL 서버의 가상 컬럼은 다음과 같습니다.
	- 가상 컬럼(Virtual Column) 
		- `AS VRITAUL`을 사용해서 생성
		- 칼럼의 값이 디스크에 저장되지 않음
		- 컬럼의 구조 변경은 테이블 리빌드를 필요로 하지 않음
		- 컬럼의 값은 레코드가 읽히기 전 또는 BEFORE 트리거 실행 직후에 계산되어 만들어짐
	
	- 스토어드 컬럼(Stored Column)
		- `AS STORTED`을 사용해서 생성
		- 컬럼의 값이 물리적으로 디스크에 저장
		- 컬럼의 구조 변경은 다른 일반 테이블과 같이 필요 시 테이블 리빌드 방식으로 처리
		- INSERT와 UPDATE 시점에만 컬럼의 값이 계산

	
-





# 문제 만들기


철수는 게시글 추가 기능에 이미지 썸네일 업로드 기능을 추가로 구현하고 있습니다. 사용자는 게시글을 작성할 때 썸네일 이미지를 선택하여 업로드할 수 있습니다. 하지만 비용 문제로 클라우드 서비스를 이용할 수 없고 데이터베이스 서버와 애플리케이션을 운용할 서버만 가지고 있습니다.  
이때 철수를 위해 이미지 업로드 기능을 구현하기 위한 테이블을 설계해 주세요.  

- BLOB, TEXT, 가상칼럼 
- DATETIME, 
요구사항  
1. 이미지는 JPG, PNG만 업로드 가능합니다.  
	1. JPG, PNG 이외의 데이터가 입력될 수 있지만 저장하면 안 됩니다.  
	2. 이미지 확장자는 추가될 수 있기 때문에 확장성에 대비해 주세요.  
	3. 이후 확장자별로 파일을 조회하기 위해 많은 사람이 사용하는 JPG, PNG 순서로 저장해야 합니다.  
2. 이미지는 1개만 업로드 할 수 있으며 저장할 수 있는 용량은 최대 64kb입니다.  
3. 게시글 제목을 추가할 수 있습니다.  
4. 게시글 본문이 있습니다.  
5. 글자 수 제한은 없습니다.  
6. 게시글이 생성된 날짜, 시간을 저장해야 합니다.  
7. 게시글이 수정된 날짜, 시간을 저장해야 합니다.  
8. 식별할 수 있는 고유키를 필요로 합니다.  
9. 파일의 이름을 직접 생성해야 하며 규칙은 다음과 같습니다.  
	1. 파일의 현재 생성 시간 + 확장자 (2024_04_02_04_44_14_3.jpg) 년_월_일_시간_분_초_게시글아이디.확장자


```
create table post(  
    id int primary key,  
    title varchar(64),  
    content TEXT,  
    image blob not null,  
    extension enum('jpg', 'png'),  
    created_at datetime default current_timestamp,  
    updated_at datetime default current_timestamp on update current_timestamp,  
    file_name varchar(64) as (concat(date_format(created_at, '%Y_%m_%d_%h_%i_%s'),'_',id,'.',extension)) virtual  
);
```


프로젝트가 성황리에 진행되던 중 이미지를 저장하다가 JPEG 확장자를 뺴먹었다는 것을 알게 되었으며 뿐만 아니라 avif, webp와 같은 다양한 확장자를 추가하기를 원합니다. 저장 순서는 JPG,JPEG,PNG, AVIF, WEBP로 만들어주세요. 그리고 이 과정에서 발생하는 상황에 대해 알려주세요.

```
ALTER TABLE post modify extension enum('jpg', 'jpeg', 'png', 'avif', 'webp'),  
    ALGORITHM =COPY , LOCK =SHARED ;
```

사장
부사장

MySQL에 JSON 타입이 추가된 이후로 현재까지 많은 발전을 이루고 있습니다. 심지어 JSON 타입은 몽고디비와 유사한 BSON으로 저장되는데 MySQL에서 JSON 컬럼을 사용해야 할까요? 