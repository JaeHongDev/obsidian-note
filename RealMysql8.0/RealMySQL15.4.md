---
cssclasses:
  - my_style_width_100
---

MySQL Enum과 Set은 모두 문자열 값을 MySQL 내부적으로 숫자 값으로 매핑해서 관리하는 타입

> 실제 데이터베이스에서는 이미 인코딩된 알파벳이나 숫자 값만 저장되므로 그 의미를 바로 파악하기가 쉽지 않다는 단점이 있다. -> 이거 무슨 말임?

# Enum
- Enum타입은 테이블의 구조에 나열된 목록 중 하나의 값을 가질 수 있다.
- Enum타입의 가장 큰 용도는 코드화된 값을 관리하는 것
- MySQL 서버가 실제로 값을 디스크나 메모리에 저장할 때는 값에 매핑된 정숫값을 사용합니다.
- Enum타입에 사용할 수 있는 최대 아이템의 개수는 65,535개이다.
- 아이템의 개수가 255개 미만이면 ENUM타입은 저장 공간으로 1바이트를 사용하고, 그 이상인 경우에는 2바이트까지 사용한다.
- Enum타입은 실제 테이블에 저장된 코드 값이 어떤 의미인지 이해하기 쉽지 않았던 일단 타입의 문제를 해결할 수 있는 유용한 타입
- Enum타입은 저장해야 하는 아이템 값(문자열)이 길면 길수록 저장 공간을 더 많이 절약할 수 있다.
	- 🤔 Enum은 조회 속도가 균등할까?
## 단점
- Enum타입의 가장 큰 단점은 칼럼에 저장되는 문자열 값이 테이블 구조이기 때문에 Enum타입에 새로운 값을 추가한다면 테이블의 구조를 변경해야 한다
	- 🤔 Enum의 값은 어떤 방식으로 저장될 까? innocheck
	- MySQL5.6 버전 이전에는 Enum 타입의 아이템이 새로 추가되면 테이블을 리빌드 해야 했지만
		- 이후 부터는 새로 추가하는 아이템이 Enum 타입의 제일 마지막으로 추가하는 형태라면 테이블의 구조 변경만으로 즉시 완료된다.
			- 🤔 어떻게 하면 enum의 원소를 쉽게 추가할 수 있을까?
- **Enum 타입의 컬럼값으로 정렬을 수행하면 매핑되기 전의 문자열 값 기준으로 정렬되는 것이 아닌 코드 값으로 정렬이 수행된다.**
	- 이 경우  `case`를 활용해서 정렬 기준을 문자열이 되도록 변환해줘야 합니다

## 장점
- 테이블 구조에 정의된 코드 값만 사용할 수 있도록 강제할 수 있습니다.
- 데이터베이스 서버의 디스크 저장 공간의 크기를 줄여준다. 
	- 디스크 데이터는 InnoDB 버퍼 풀로 적재돼야 쿼리에서 사용할 수 있기 때문에 많은 메모리가 소모되기 때문에 용량이 준다면 그만큼 메모리 사용량을 줄일 수 이쑈다. 
	- 백업, 복구 시간을 줄일 수 있다. 


## 이미지(쿼리 예시임)
![[Pasted image 20240331171623.png | 600]]
![[Pasted image 20240331171710.png]]
![[Pasted image 20240331171814.png]]




- enum의 문제점 (정리하기)
# Set
## 특징
- enum과 동일한 테이블의 구조에 정의된 아이템을 정숫값으로 매핑해서 저장하는 방식
- Enum과 달리 1개 이상의 값을 가질 수 있음
	- MySQL서버가 내부적으로 BIT-OR연산을 거쳐 1개 이상의 선택된 값을 저장한다
	- Bit or연산을 활용하기 때문에 여러 저장 공간을 가지는 것이 아닌 
		- 1바이트 - 8개 이하
		- 2바이트 - 9 to 16
		- 3바이트 - 17 to 24
		- ... 최대 8바이트까지 저장
		- 🤔 그럼 기존 저장공간이 바뀌면 어떻게 바뀜?

생성 방법
- `column_name SET(...원소)`

검색
- `find_in_set(찾을 원소, 컬럼)`
- `select * from table where column='원소1,원소2'` : 원소1, 원소2가 저장된 위치가 동일해야 검색 가능


## 단점
- Enum과 같이 Set타입이 추가되는 경우 테이블의 읽기 잠금과 리빌드 작업이 발생합니다. 
	- Enum과 동일하게 중간 위치에 새로운 아이템이 추가되어야 읽기 잠금 발생
- Set은 Enum과 같이 맨 뒤에 새로운 아이템이 추가되는 경우 INSTANT 알고리즘으로 처리가 가능하지만, SET타입의 아이템 개수가  9개로 늘어날 때 잠금 작업이 필요하다.
	- 1바이트 -> 2바이트


# Text와 BLOB

## 특징
- MySQL에서 대량의 데이터를 저장하려면 TEXT,BLOB을 사용


## TEXT와 BLOB의 차이
- TEXT타입은 **문자열**을 저장하는 대용량 컬럼으로 문자 집합이나 콜레이션을 가집니다.
- BloB타입은 **이진 데이터 타입**으로 별도의 문자 집합이나 콜레이션을 가지지 않는다.


## TEXT, BLOB을 사용하는 상황
- 컬럼 하나에 저장되는 문자열이나, 이진 값의 길이를 예측할 수 없이 클 때 Text, Blob을 사용한다. 
	- 참고로 값의 크기가 4000바이트를 넘을 때 반드시 BLOB이나 텍스트를 사용해야 하는 것은 아님
		- 레코드가 64KB를 넘지 않는 한도 내에서 VARCHAR의 길이 제한은 없다. 
	- 🤔 한 컬럼안에 너무 많은 텍스트가 있는 경우 어떻게 처리해야 할까?
- MySQL에서는 버전에 따라 조금씩 차이는 있지만 하나의 레코드는 전체 크기가 64kb를 넘어설 수 없다. varchar, varbinary와 같은 가변 길이 컬럼은 최대 저장 가능 크기를 포함해 64kb로 제한되는데 이보다 더 큰 값을 저장하고 싶다면 TEXT,BLOB타입으로 전환해야 한다. 


## 인덱스

- BLOB, TEXT 타입의 컬럼에 인덱스를 생성할 수 있다. 
- 추천하지 않지만 생성해야 한다면  몇 바이트 까지 허용할지 정해야 하며 최대 크기를 넘어서는 경우 인덱스를 사용할 수 없다.
	- 엔진 별 최대 크기 비교
		- MyISAM - 1000바이트
		- (REDUNDANT, CMOPACT  로우 포맷) innoDB - 767바이트
		- (DYNAMIC, COMPRESSED 로우 포맷) innoDB - 3072바이트
	- 시스템 변수
		- `max_sort_length` : 1024바이트 설정

## 임시테이블 관점
- 임시 테이블은 메모리 혹은 디스크에 저장
	- 메모리에 저장되는 경우는 `internal_tmp_mem_storage_engine` 시스템 변수에 영향을 받음
		- `memory`: TEXT, BLOB을 원하지 않음
		- `temptable` TEXT,BLOB 지원 <- 가능한 사용

## DML관점
- insert, update 문장 중에서 BLOB, TEXT 컬럼을 조작하는 sql의 경우 문제가 발생합니다.
	- 이거 문제로 내면 괜찮을 듯? 
	- mysql 서버의 `max_allowd_packet` 시스템 변수에 설정된 값보다 큰 sql은 서버로 전송되지 못한다. 
	- 대용량 blob, text 컬럼을 사용하는 쿼리가 있다면 `max_allowed_packet`을 사용하는 것을 권장 
- TEXT, BLOB 타입 컬럼의 값은 테이블의 `ROW_FORMAT` 옵션에 영향을 받습니다.
	- 설정하지 않았다면 `innodb_default_row_format`의 값을 사용 (dynamic)
- MySQL은 사용 가능한 모든 `ROW_FORMAT`을 가능한 TEXT, BLOB 컬럼의 값을 다른 레코드와 같이 저장하려고 하지만 레코드의 최대 길이로 인해 불가능하다. 

### COMPACT 포맷의 문제점
- MySQL 5.7에서 테이블 기본 `ROW_FORMAT`은 `COMPACT` -> `DYNAMIC`으로 변경
- `COMPACT` 포맷에서 저장할 수 있는 레코드 하나의 최대 길이는 데이터 페이지의 크기 16kb의 절반이다.
	- 레코드의 전체 길이가 16KB의 절반을 넘어서면 용량이 큰 순서대로 외부 페이지로 옮겨 8126바이트 이하로 맞춘다.
	![[Pasted image 20240401154712.png]]


# 공간 데이터 타입
- MySQL에서는 WKT, WKB를 이용해 공간 데이터를 지원한다.
- 지원하는 데이터 타입은 다음고 같다.
	- POINT
	- LINESTRING
	- POLYGON
	- GEOMETRY
	- MULTIPOINT
	- MULTILINESTRING
	- MULTIPOLYGON
	- GEOMETRYCOLLECTION
- POINT, LINESTRING, POLYGON 타입은 하나의 정보만 가질 수 있다.
- GEOMETRY는 POINT, LINESTRING, POLYGON 타입의 수퍼 타입을 3개 타입의 객체 모두 저장할 수 있다. (단 하나의 객체만 가능)
- MULTI 접두사로 시작하는 타입은 종류별로 여러 객체를 저장할 수 있다.
![[Pasted image 20240401155141.png]]


## 공간 데이터 생성
-  MySQL 서버에서는 공간 데이터를 생성할 때 WKT 포맷을 MySQL 서버가 처리할 수 있는 이진 데이터 포맷의 데이터로 변환할 수 있습니다. 
![[Pasted image 20240401155329.png | 600]]

![[Pasted image 20240401155337.png | 600]]

- 각 공간 데이터 생성 함수의 이름에서 `FromText` -> `FromWKB`를 사용하면 `WKT` 대신 `WKB`를 이용한 공간 데이터 객체를 생성할 수 있다. 

## 공간 데이터 조회
- MySQL 서버가 공간 데이터를 조회하는 방법은 다음과 같습니다.
	- 이진 데이터 조회 (WKB 포맷, MySQL 이진 포맷)
	- 텍스트 데이터 조회 (WKT 포맷)
	- 공간 데이터의 속성 함수를 이용한 조회
- 첫 번째, 두 번째는 공간 데이터 타입과 관계없이 `ST_AsText/ST_AsWKT` 함수, 혹은 `ST_AsBinary/ST_AsWKB` 함수를 이용해 조회할 수 있다.

(실제 조회방법은 이전 챕터에서 다뤘습니다)


# JSON 타입
- JONS타입은 MySQL 5.7버전 지원
- JSON 데이터를 문자열로 저장하는 것이 아닌 MongoDB와 같은 바이너리 포맷의 BSON으로 변환해서 저장
	- 🤔 BSON으로 저장하면 몽고 대신 써도 되는거 아님?

## 저장방식 
- MySLQL은 내부적으로 JSON타입의 값을 BLOB타입에 저장합니다.
	- JSON그대로가 아닌 BSON타입으로 변환해서 저장
## 쿼리
![[Pasted image 20240401170042.png | 600]]


'{"a": "x", "b": "y", "c": "z" }'


## 이진 포맷 JSON 데이터 필드
![[Pasted image 20240401170205.png|600]]
![[Pasted image 20240401170215.png|600]]

- 이진