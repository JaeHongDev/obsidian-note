---
cssclasses:
  - my_style_width_100
---

# SELECT

 웹 서비스 같이 온라인 트랜잭션 처리 환경의 데이터베이스에서는 insert나 update 같은 작업은 거의 레코드 단위로 발생하므로 성능상 문제가 되는 경우는 별로 없습니다.
하지만 SELECT는 테이블의 데이터를 조합해서 빠르게 가져와야 하기 때문에 여러 개의 테이블을 어떻게 읽을 것인가에 많은 주의를 기울여야 합니다.

## SELECT 절의 처리 순서

대부분의 쿼리는 아래의 그림의 순서대로 쿼리 절이 실행됩니다.
![[Pasted image 20240204141607.png]]

1. from (join) 
2. where 적용
	 - (from, where, join, select) 순서
3. group by
4. distinct
5. having
6. order by
7. limit 

> 참고로 order by나 group by절이 있더라도 인덱스를 이용해 처리할 때는 위에서 보여지는 단계가 불필요하다.
> -> 인덱스 순서로 정렬 돼 있기 때문이죠
> -> 인덱스 루스 스캔으로 group by를 해결할 수 있긴함

간혹 아래의 그림처럼 order by가 조인보다 먼저 실행되거나, CTE, 윈도우 함수를 제외한 쿼리는 위 구조와 다르게 동작한다.
![[Pasted image 20240204142109.png]]



![[Pasted image 20240206122046.png]]
![[Pasted image 20240206122011.png]]
![[Pasted image 20240206122033.png]]
![[Pasted image 20240206122444.png]]


위 쿼리 처럼 앞서 이야기한 실행 순서를 벗어나는 쿼리를 사용하는 경우 서브쿼리로 작성된 인라인 뷰를 사용하는 이 때 order by와 limit의 순서가 바뀌기 때문에 동일한 결과가 발생하지 않을 수 있습니다.


## Where 절과 Group By 절 Order by 절의 인덱스 사용

### 인덱스를 사용하기 위한 기본 규칙

where 절이나 order by 또는 group by가 인덱스를 사용하려면 기본적으로 인덱스된 컬럼의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 합니다.

> 왜 인덱스를 변형하면 적용이 안될까..?
> 	생각해보면 간단할 수 있음 정수의 경우 문자열로 바꼈을 때  1000, 2 는 순서상 2가 더 높음 하지만 정수형의 경우 1000이 더 크기 때문에 인덱스를 못 쓰는게 아닐까?

먼약 인덱스 컬럼의 값을 변형해야 한다면(md5 함수) 미리 계산된 값을 저장하도록 MySQL 가상 컬럼을 추가하고 그 컬럼에 인덱스를 생성하거나 함수 기반의 인덱스를 사용하면 됩니다.

만약 where 절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야 합니다.

![[Pasted image 20240204161945.png]]

MySQL 옵티마이저가 내부적으로 문자열 타입을 숫자 타입으로 변환한 후 비교 작업을 처리하는데 인덱스의 변형이 발생하기 떄문에 인덱스 풀 스캔을 하게 됩니다. 


### where 절의 인덱스 사용

where 조건이 인덱스를 사용하는 방법은
- 작업 범위 결정 조건 (동등 비교 조건 , IN 으로 구성된 조건에 사용된 컬럼들이 인덱스의 좌측에서 비교했을 때 일치하는가에 따라 달라짐)
- 체크 조건
이렇게 두 방식으로 구분할 수 있습니다.


![[Pasted image 20240204163022.png]]

where 절의 경우 인덱스 결합 구성과는 무관하게 조건절에 있는 인덱스 컬럼 순서에 맞춰 옵티마이저가 파악해서 적용함

결합 인덱스를의 순서가 col_1, col_2, col_3 이라고 했을 때 where 절에 col_3 = '', col_1, col_2로 적어도 옵티마이저가 적절하게 판단함

단 여기서 주의할 점이 있는데 where절의 연산자 결합이 And가 아닌 Or로 되어 있다면 문제가 발생할 수 있다. 



### Group by 절의 인덱스 사용

group by는 where과 달리 비교 연산자를 가지지 않으므로 작업 범위 결정 조건이나 체크 조건을 구분해서 생각할 필요는 없습니다.

대신 ==group by절에 명시된 컬럼의 순서가 인덱스를 구성하는 컬럼의 순서와 같으면 group by절은 인덱스를 이용할 수 있습니다.==

 1. Group by 절에 명시된 컬럼이 인덱스 컬럼의 순서와 위치가 같아야 합니다. 
 2. 인덱스를 구성하는 컬럼 중에서 뒤쪽에 있는 컬럼은 group by 절에 명시되지 않아도 인덱스를 사용할 수 있지만 인덱스의 앞쪽에 있는 컬럼이 group by 절에 명시되지 않으면 인덱스를 사용할 수 없습니다 
3. where 조건절과는 달리 group by 절에 명시된 컬럼이 하나라도 인덱스에 없으면 group by 절은 전혀 인덱스를 이용하지 못합니다.
![[Pasted image 20240204165129.png]] ![[Pasted image 20240204165212.png]]

위 예시에 맞춰 인덱스 사용 여부를 결정하면 다음과 같습니다.

1. COL2, COL_1  1번 조건과 맞지 않아서 사용할 수 없음
2. COL1, COL3, COL2  1번 조건과 맞지 않음
3. COL1, COL_3,  2번 조건 중 앞쪽에 있는 컬럼이 명시되지 않았기 때문에 사용할 수 없음
4. COL1 ~ COL5, 3번 조건 중 group by 절에 명시된 컬럼이 하나라도 인덱스에 없으면 만족할 수 없음 (COL_5)

![[Pasted image 20240204165531.png]]

위 예시는 인덱스를 사용할 수 있는 예시입니다.

> 이부분은 신기했던 내용

만약 where 절에서 COL_1, COL_2가 동등 비교 조건으로 사용된다면 group by절에 COL_1, COL_2 둘 중에 하나가 빠져도 인덱스를 이용한 group by가 가능할 떄도 있습니다.
![[Pasted image 20240204165801.png]]

### ORDER BY 절의 인덱스 사용

groupby와 처리방법이 비슷하며 별도의 조건이 하나 더 있는데 각 컬럼의 오름차순 및 내림차순 옵션이 인덱스와 같거나 정반대인 경우에만 사용할 수 있습니다. 
![[Pasted image 20240204170155.png]]
![[Pasted image 20240204170148.png]]

1. COL1이 명시되지 않아 사용할 수 없음
2. COL(2,3)의 순서가 바뀜
3. COL2의 경우 asc가 아님
4. COL2가 존재하지 않음
5. COL5는 인덱스에 포함되지 않음


### WHERE 조건과 order by 절의 인덱스 사용 

WHERE절과 order by절에서 동시에 서로 다른 인덱스를 사용하는 경우 3가지 중 하나의 방법으로만 인덱스를 이용합니다.
1. where 절과 order by 절이 동시에 같은 인덱스를 사용하는 경우
	- where 절의 비교 조건에서 사용하는 컬럼과 order by 절의 정렬 대상 컬럼이 모두 하나의 인덱스에 연속해서 포함돼 있을 때 사용 가능함
1. where 절만 인덱스를 이용하는 경우 
	- order by 절은 인덱스를 이용한 정렬이 불가능하며, 파일 소트와 같은 별도의 정렬 처리 과정 을 거쳐 수행한다.
2. order by 절만 인덱스를 이용하는 경우
	- order by절의  인덱스를 읽으면서 레코드 한 건씩 where 절의 조건에 일치하는지 비교하고 일치하지 않을 때는 버리는 형태로 처리함.
	- 많은 레코드를 읽어야 한다면 이런 형태로 사용

WHERE 절에서 비교 조건으로 비교된 컬럼과 order by 절에 명시된 컬럼이 순서대로 빠짐없이 인덱스 컬럼의 왼쪽부터 일치해야 합니다. (인덱스 스킵 스캔의 경우는 제외)

###  group by 절과 order by 절의 인덱스 사용
group by와 order by 절이 동시에 사용된 쿼리에서 두 절이 모두 하나 인덱스를 사용해서 처리되려면 group by 절에 명시된 컬럼과 order by에 명시된 컬럼의 순서와 내용이 모두 같아야 합니다.

만약 group by, order by 둘 중 하나라도 인덱스를 이용하지 못하면 둘 다 인덱스를 사용할 수 없다.
즉 group by는 인덱스를 이용할 수 있지만 order by 가 인덱스를 이용할 수 없을 때 이 쿼리의 group by와 order by절은 모두 이용하지 못한다.
(반대의 경우도 마찬가지)

MySQL 5.7 버전까지는 group by는 group by 컬럼에 대한 정렬까지 함께 수행하는 것이 기본 작동 방식이지만 8.0부터는 group by 절이 컬럼의 정렬까지는 보장하지 않는 형태로 바꼈다. 즉 그루핑과 정렬을 모두 수행하기 위해서는 group by, order by절을 모두 명시해야 합니다.
### WHERE 조건과 ORDER BY 절 GROUP BY 절의 인덱스 사용

where, group by, order by 절이 모두 포함된 쿼리가 인덱스를 사용하는지 판단하는 순서는 다음과 같습니다.
1. where 절이 인덱스를 사용할 수 있는지
2. group by 절이 인덱스를 사용할 수 있는지
3. group by 절과 order by 절이 동시에 인덱스를 사용할 수 있는지
![[Pasted image 20240205132646.png]]

## WHERE 절의 비교 조건 사용 시 주의사항

### NULL 비교

MySQL에서는 NULL값이 포함된 레코드도 인덱스로 관리됩니다. 
- NULL도 하나의 값으로 인정함
- 단 값이지만 비교할 수 없는 값이기 때문에 is null (<=>) 연산자를 활용해야 함

![[Pasted image 20240205162637.png]]


### 문자열이나 숫자 비교

이전에도 이야기 했듯이 숫자 컬럼을 비교할 때는 반드시 타입에 맞는 상숫값을 사용하는 것을 권장합니다.

![[Pasted image 20240205162832.png]]

> 조건절에 인덱스를 타야 하는 값이 변형되는 것은 인덱스를 탈 수 없기 떄문

세 번째, 네 번쨰 쿼리는 인덱스를 타지 못한다. 그 이유는 비교하는 컬럼의 타입이 일치하지 않기 때문인데 앞서 설명한 이유와 동일하다.
### 날짜 비교

#### DATE 또는 DATETIME과 문자열 비교
DATE 또는 DATETIME 타입의 값과 문자열을 비교할 때는 문자열 값을 자동으로 DATETIME 타입의 값으로 변환해서 비교를 수행합니다.

이부분도 이전에 이야기 했듯이 date 관련 문자열은 내부적으로 입력된 값을 변형시키기 때문에 별다른 DATE 변환은 필요없습니다.
![[Pasted image 20240205163130.png]]

하지만 hire_date의 값을 변환하는 것은 인덱스를 타지 못하기 때문에 주의해야 합니다.


#### DATE와 DATETIME의 비교

![[Pasted image 20240205163415.png]]
DATE에서 DTAETIME으로 변환하는 작업은 이전과 다르게 인덱스의 사용 여부에 영향을 미치지 않기 때문에 성능보다는 쿼리의 결과에 주의해서 사용하면 됩니다.


#### DATETIME과 TIMESTAMP의 비교

하지만 DATETIME에서 TIMESTAMP의 비교는 인덱스를 타지 않는다.

![[Pasted image 20240205163646.png]]

UNIX_TIMESTAMP 함수의 결괏값은 단순 숫자 값에 불과하기 때문에 UNIX_TIME_STAMP값을 date,datetime과 비교하기 위해서는 추가적인 변환과정을 거쳐야 합니다.
![[Pasted image 20240205163756.png]]


#### Short-Circuit Evaluation
> 자바 스트림의 takeWhile도 마찬가지

Short-circuit Evaluation은 여러 개의 표현식이 AND 또는 OR 논리 연산자로 연결된 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화를 의미합니다.
![[Pasted image 20240205175510.png]]

위 쿼리 같은 경우 처음 쿼리는 1번 조건에서 시간 변환, 비교 조건 이후 2번 조건이 실행 됩니다. 
반면 마지막 쿼리는 2번 조건 실행 후 경우에 따라 1번 조건이 실행되는데 여기서 성능 차이가 발생합니다.
만약 1985-01-01 이전 데이터가 존재하지 않는다면 불필요한 테이블 스캔을 하지 않기 때문입니다. 

만약 MySQL 서버는 쿼리의 절에 나열된 조건을 순서대로 쇼트 서킷 평가 방식을 사용해 레코드를 반환할지 말지를 결정하는데 만약 Where 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있다면 쇼트 서킷 평과와 무관하게 MySQL 서버는 그 조건을 먼저 사용한다.

### Distinct

특정 컬럼의 유니크한 값을 조회하는 경우 Select 쿼리에 distinct를 사용합니다.

distinct를 남용하는 것은 성능적인 문제가 발생할 수 있기 때문에 아래의 글을 참고하자
[[RealMySQL8.0 - Chapter9#DISTINCT 처리]]


### Limit n
limit는 쿼리 결과에서 지정된 순서에 위치한 레코드만 가져오고자 할 때 사용합니다. 
![[Pasted image 20240205190058.png]]
- where 절의 검색 조건에 일치하는 레코드를 전부 읽는다.
- 1번에서 읽어온 레코드를 first_name 컬럼값에 따라 정렬한다.
- 상위 5건만 사용자에게 반환한다.
![[Pasted image 20240206004808.png]]

1. 0번 부터 10개의 레코드만 읽고 바로 종료
2. group by 결과에 대해 0번 부터 10개의 결과를 가져옴 -> group by이후에 실행
3. 풀 테이블 스캔 방식을 이용해 레코드를 읽어가며 임시 테이블을 만들고 10개가 채워지면 종료
4. where 조건 절을 읽고 first_name 기준으로 정렬 후 10건을 가져옴 -> 작업량을 크게 줄이지 못함

limit 있다면 group by, order by의 작업도 작게나마 작업량을 줄여주는 것을 알 수 있습니다.

> ⚠ 주의
> limit 사용시 주의할 점이 있는데 서브 쿼리로 limit 작업량을 줄일 수 없다

limit n, m 에서 n값이 커지는 경우 n값 만큼 레코드를 읽고 버려지기 떄문에 주의해야 합니다.
![[Pasted image 20240206005548.png]]


## count 

count 함수는 레코드의 건수를 반환하는 함수입니다. 
count는 두 가지 형태로 사용되는데 
- `count(*)`: 레코드 자체의 개수를 센다
- (column):  column이 null이 아닌 레코드의 개수를 센다

![[Pasted image 20240206010032.png]]

## JOIN 

### Join의 순서와 인덱스

[[RealMySQL8.0 - Chapter8#인덱스 레인지 스캔]] 
인덱스 레인지 스캔은 인덱스를 탐색하는 과정과 스캔하는 과정으로 구분할 수 있습니다.
인덱스를 이용한 작업은 가져오는 레코드의 건수가 소량이기 때문에 인덱스 스캔 작업은 부하가 작지만 특정 인덱스 키를 찾는 인덱스 탐색 작업은 상대적으로 부하가 높은 편입니다.

조인 작업에서 드라이빙 테이블을 읽을 떄는 인덱스 탐색 작업을 단 한 번만 수행하고 이후부터는 스캔만 실행하는데 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복합니다. 

### JOIN 컬럼의 데이터 타입

조인 컬럼 간의 비교에서 각 컬럼의 데이터 타입이 일치하지 않으면 인덱스를 효율적으로 이용할 수 없다. 
(이전에 살펴본 조건절과 동일함)

### Outer join의 성능과 주의사항

inner join은 조인 대상 테이블에 모두 존재하는 레코드만 결과 집합으로 반환합니다. 
![[Pasted image 20240206013149.png]]

![[Pasted image 20240206013252.png]]
이 쿼리의 실행 계획을 보면 employees 테이블을 드라이빙 테이블로 사용하는 것을 알 수 있습니다.

![[Pasted image 20240206163930.png]]

inner join 형태로 변경하면 departments 테이블에서 부서명이 'Development'인 레코드 1건만 찾아서 조인을 실행하는 실행 계획을 선택했을 것입니다.
예측한 rows ->  30만 -> 4만 으로 줄어듭니다.

즉 inner join 을 사용할 수 있다면  inner join을 사용하는 것이 좋으며 이는 옵티마이저에게 더 나은 쿼리 최적화를 할 수 있는 선택지가 주어지게 됩니다.

### join과 왜래키

데이터베이스에 외래키가 생성돼 있어먄 조인을 할 수 있는 것은 아닙니다. 왜래키는 데이터 무결성을 보장하기 위해서 이며 이는 참조무결성과 관련된 내용입니다. 

### 지연된 조인
조인을 사용해서 데이터를 조회하는 쿼리에 group by 혹은 order by를 사용할 때 각 처리 방법에서 인덱스를 사용한다면 이미 옵티마이저가 최적화해서 실행하고 있을 가능성이 높습니다. 
하지만 그렇지 못한다면 MySQL 서버는 모든 조인을 실행하고 난 다음 group by혹은 order by를 처리할 것 입니다.

이런 경우 조인의 결과를 group by하거나 order by하면 조인을 실행 하기 전의 레코드에 group by나 order by를 수행하는 것 보다 많은 레코드를 처리해야 하는데 group by, order by를 조인이 실행되기 이전에 조인쿼리를 처리하는 방식을 지연된 조인이라고 합니다.


![[Pasted image 20240206165745.png]]

위 쿼리는 드라이빙 테이블의 조건절에서 3000건의 레코드를 읽고 12000번정도 조인을 했습니다. 그리고 결과를 임시테이블에 저장하고 group by처리를 통해 3천건으로 줄여 10건만 반환한 쿼리입니다.

![[Pasted image 20240206170105.png]]
위 쿼리는 지연된 조인으로 변경된 쿼리입니다.
salaries테이블에서 가능한 모든 처리르 수행한 다음 결과를 임시 테이블에 저장했고 그 결과를 employees 테이블과 조인하도록 고친 것입니다.

from 절에 서브쿼리가 사용됐기 때문에 파생 테이블로 처리 됐으며 쿼리 처리를 위해 5.6만 건의 레코드를 읽어야 하지만 실제로는 2.8만 건의 레코드만 읽으면 되는 쿼리입니다. 

또한 group by 를 통해 3천 건으로 줄였으며 최종족으로 10건만 임시테이블에 저장된 후 10건만 읽어서 employees 테이블과 조인을 수행한다. 

지연된 조인으로 개선 임시 테이블이 생성되기 때문에 느리다고 생각할 수 있지만 조인의 횟수를 비교해보면 조인으로 변경된 쿼리의 조인 횟수가 훨씬 적기 때문에 오히려 지연된 조인 쿼리가 빠르다는 것을 알 수 있습니다. 

즉 적절한 쿼리 튜닝을 통해서 훨씬 빠른 성능을 보장할 수 있기 때문에 이런 부분을 잘 인지하는 것이 좋습니다. 


![[Pasted image 20240206181251.png]]

![[Pasted image 20240206174025.png]]

[[RealMySQL 10.2 실행 계획 확인#table 컬럼]]

[]