---
cssclasses:
  - my_style_width_100
---

# 고급 최적화
MySQL 서버의 옵티마이저가 실행 계획을 수립할 때 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립합니다.

## 옵티마이저 스위치 옵션
- 옵티마이저 스위치는 MySQL 5.5버전부터 지원되기 시작했습니다.

옵티마이저 스위치 옵션은 `optimzer_switch` 시스템 변수를 이용해서 제어하는데, `optimizer_switch` 시스템 변수에는 여러 개의 옵션을 세트로 묶어서 설정하는 방식으로 사용합니다.
`optimizer_switch` 시스템 변수에 설정할 수 있는 최적화 옵션은 다음과 같습니다.
```
`atched_key_access={on|off}`
`block_nested_loop={on|off}`
`condition_fanout_filter={on|off}`
`ㅌ_condition_pushdown={on|off}`
`derived_merge={on|off}`
`duplicateweedout={on|off}`
`engine_condition_pushdown={on|off}`
`firstmatch={on|off}`
`hash_join={on|off}`
`index_condition_pushdown={on|off}`
`index_merge={on|off}`
`index_merge_intersection={on|off}`
`index_merge_sort_union={on|off}`
`index_merge_union={on|off}`
`loosescan={on|off}`
`materialization={on|off}`
`mrr={on|off}`
`mrr_cost_based={on|off}`
`prefer_ordering_index={on|off}`
`semijoin={on|off}`
`skip_scan={on|off}`
`subquery_materialization_cost_based={on|off}`
`subquery_to_derived={on|off}`
`use_index_extensions={on|off}`
`use_invisible_indexes={on|off}`
```
- 각각의 옵티마이저 스위치 옵션은 default, on, off 중에서 하나를 설정할 수 있는데, on으로 설정되면 해당 옵션을 활성화하고, off를 설정하면 해당 옵션을 비활성화한다.
- 그리고 default를 설정하면 기본값이 적용된다.
- 옵티마이저 스위치 옵션은 글로벌과 세션별 모두 설정할 수 있는 시스템 변수이므로 MySQL 서버 전체적으로 또는 현재 커넥션에 대해서만 다음과 같이 설정할 수 있다.
```mysql
// MySQL 서버 전체적으로 옵티마이저 스위치 설정
set global optimizer_switch='index_merge=on,index_merge_union=on,...'; 

// 현재 커넥션의 옽비마이저 스위치만 설정
set session optimizer_switch='index_merge=on,index_merge_union=on,...';
```
- 또한 다음과 같이 "SET_VAR" 옵티마이저 힌트를 이용해 현재 쿼리에만 설정할 수 있습니다.
```mysql
select /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off'*/ 
 from ...
```

### MRR 배치 키 인덱스 (mrr & batched_key_access)
MRR은 `Multi-Range Read` 를 줄여서 부르는 이름이고 메뉴얼에서는 `DS-MMR(Disk Sweep Multi-Range Read`라고 합니다. 

MySQL 서버에서 제공하던 조인 방식은 네스티드 루프 방식인데 서버 내부 구조상 조인 처리는 MySQL 엔진이 처리 하지만, 실제 레코드 검색과 읽는 부분은 스토리지 엔진이 처리함.
결국 이런 방식은 레코드 건별로 드리븐 테이블의 레코드를 찾으면 레코드를 찾고 레코드를 읽는 스토리지 엔진에서는 아무런 최적화를 수행할 수가 없음.

이런 단점을 보완하기 위해 조인 대상 테이블의 레코드를 읽어서 조인 버퍼에 버퍼링을 합니다.
이 과정에서 조인 버퍼에 레코드가 가득 차면 MySQL 엔진은 스토리지 엔진으로 부터 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청함

조인 버퍼에 레코드가 가득 차면 MySQL엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청하고 스토리지 엔진은 읽어야 할 레코드들을 데이터 페이지에 정렬된 순서로 접근해서 디스크의 데이터 페이지 읽기를 최소화 할 수 있습니다.

MMR을 응용해서 실행되는 조인 방식을 `BKA(Batched Key ACCESS)` 라고 합니다.
기본 설정은 비활성화 인데 이는 쿼리의 특성에 따라 도움을 받을 수 있지만, BKA 조인을 사용하게 되면 부가적인 정렬 작업이 필요해지면서 오히려 성능에 안 좋은 영향을 미칠 수 있기 때문입니다.

### 블록 네스티드 루프 조인(block_nested_ loop)
MySQL 서버에서 사용되는 대부분의 조인은 네스티드 루프 조인인데, 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있는 경우 사용되는 조인 방식입니다.
![[Pasted image 20231223002401.png]]
```
for(row1 in employees)
 for(row2 in salaries) 
   if(condition_matched)return (row1, row2)
```
 이러한 형태의 조인은 프로그래밍 언어에서 중첩된 반복 명령을 사용하는 것처럼 작동한다고 해서 네스티드 루프 조인이라고 합니다.

- 네스티드 루프 조인은 레코드를 읽어서 다른 버퍼 공간에 저장하지 않고 즉시 드리븐 테이블의 레코드를 찾아서 반환합니다.
- 네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 차이는 조인 버퍼(join_buffer_size 시스템 설정으로 조정되는 조인을 위한 버퍼)가 사용되는지 여부와 조인에서 드라이빙 테이블과 드린 테이블이 어떤 순서로 조인 되느냐 입니다.

조인 알고리즘에서 "Block" 이라는 단어가 사용되면 조인용으로 별도의 버퍼가 사용됐다는 것을 의미하는데, 조인 쿼리의 실행 계획에서 Extra컬럼에 Using Join Buffer라는 문구가 표시되면 그 실행 계획은 조인 버퍼를 사용한다는 것을 의미합니다.

조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리됩니다.
즉 드라이빙 테이블은 한 번에 쭉 읽지만, 드리븐 테이블을 여러 번 읽는다는 것을 의미합니다.
예를 들어 드라이빙 테이블에서 일치하는 레코드가 1,000건이었는데, 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없었다면 드리븐 테이블에서 연결되는 레코드를 찾기 위해 1000번의 풀 테이블 스캔을 해야 합니다. 

그래서 드리븐 테이블을 검색할 때 인덱스를 사용할 수 없는 쿼리는 상당히 느려지며, 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립합니다

- 만약 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리합니다.
- 이때 사용되는 메모리의 캐시를 조인 버퍼라고 합니다.

- 두 테이블이 조인되는 다음 예제 코리에서 각 테이블에 대한 조건은 WHERE절에 있지만, 두 테이블 간의 연결 고리 역할을 하는 조인 조건은 없습니다.
- 그래서 dept_emp 테이블에서 from_date > '2000-01-01' 인 레코드와 employees 테이블에서 emp_no < 109004 조건을 만족하는 레코드는 카테시안 조인을 수행합니다.

![[Pasted image 20231224232624.png]]

- 위 쿼리의 실행 계획을 보면 dept_emp 테이블이 드라이빙 테이블이며, employees 테이블을 읽을 때는 조인 버퍼를 이용해 네스티드 루프 조인을 한다는 것을 Extra 컬럼의 내용으로 알 수 있습니다.
![[Pasted image 20231224232722.png]]


- 위 쿼리의 실행 계획에서 조인 버퍼가 어떻게 사용되는지 볼 수 있습니다.
1. dept_emp 테이블의 ix_fromdate 인덱스를 이용해 (from_date > '1955-01-01') 조건을 만족하는 레코드를 검색한다.
2. 조인에 필요한 나머지 컬럼을 모두 dept_emp 테이블로부터 읽어서 조인 버퍼에 저장한다.
3. employees 테이블의 프라이머리 키를 이용해 (emp_no < 109004) 조건을 만족하는 레코드를 검색한다.
4. 3번 단계에서 검색된 결과에 2번의 캐시된 조인 버퍼의 레코드를 결합해서 반환한다.

![[Pasted image 20231224233310.png]]

- 위 그림에서 중요한 점은 조인 버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인 것처럼 실행된다는 것입니다.
- 위에서 설명한 절차의 4번 단계가 employees 테이블의 결과를 기준으로 dept_emp  테이블의 결과를 결합한다는 것을 의미합니다.
- 실제 위 쿼리의 실행 계획상으로는 dept_emp 테이블이 드라이빙 테이블이 되고 employees 테이블이 드리븐 테이블이 된다.
- 하지만 실제 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리된다.
- 일반적으로 조인이 수행된 후 가져오는 결과는 드라이빙 테이블의 순서에 의해 결정되지만, 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있음을 기억해야 한다. 
> ⚠ 주의
> 8.0.20 이후 버전부터는 해시 조인 알고리즘으로 사용 이제 Using Join Buffer는 표시되지 않음

### 인덱스 컨디션 푸시다운 (index_condition_pushdown) 

(책 예시 참고)
> select * from employees where last_name = 'Action' and first_name like '%sal';
![[Pasted image 20231226161446.png]]
간단하게 정리하면 인덱스로 등록된 컬럼이지만 인덱스의 범위를 좁히지 못하는 경우 인덱스에서 모두 처리한 다음 IO를 처리하는 작업입니다.




### 인덱스 확장 (use_index_extensions)
`use_index_extensions` 옵티마이저 옵션(optimizer_switch)은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 결정하는 옵션이다.
InnoDB 스토리지 엔진에서 모든 세컨더리 인덱스는 리프 노드에 프라이머리 키 값을 가지는데 이는 프라이머리 키를 클러스트링 키로 생성하는 특징 떄문입니다.

예를 들어 아래 테이블 처럼 프라이머리 키와 세컨더리 인덱스를 가진 테이블이 있다고 가정해보겠습니다.
![[Pasted image 20231225170427.png]]

( 이부분을 말로 설명할 수 있어야 할 텐데..)
dept_emp 테이블에서 프라이머리 키는 (dept_no, emp_no) 이며, 세컨더리 인덱스 ix_fromdate는 from_date 컬럼만 포함한다.
그런데 세컨더리 인덱스는 데이터 레코드를 찾아가기 위해 프라이머리 키인 dept_no와 emp_no 컬럼을 순서대로 포함한다.
그래서 최종적으로 ix_fromdate 인덱스는 (from_date, dept_no, emp_no) 조합으로 인덱스를 생성환 것과 흡사하게 작동할 수 있게 된다.
현재 MySQL 서버는 ix_fromdate 인덱스의 마지막에 (dept_no, emp_no) 컬럼이 숨어있다는 것을 인지하고 실행 계획을 수립하도록 개선했다.

- 아래 쿼리의 실행 계획을 보겠습니다.
![[Pasted image 20231225171739.png]]
- 실행 계획의 key_len 컬럼은 이 쿼리가 인덱스를 구성하는 컬럼 중에서 어느 부분까지 사용했는지를 바이트 수로 보여주는데, 이 예제에서는 19바이트가 표시된 것을 보면 from_date 컬럼 (3바이트)과 dept_emp 컬럼(16) 까지 사용했다는 것을 알 수 있다.
- `dept_no =d001` 조건을 제거해서 비교해보면 dept_no 컬럼을 사용하지 않았기 때문에 3바이트만 사용한 것을 알 수 있습니다.
![[Pasted image 20231225172003.png]]
- 뿐만 아니라 InnoDB의 프라이머리 키가 세컨더리 인덱스에 포함돼 있으므로 다음과 같이 정렬 작업도 인덱스를 활용해서 처리되는 장점도 있습니다.
![[Pasted image 20231225174303.png]]

- Extra 컬럼에 Using Filesort 가 표시되지 않았기에 MySQL 서버가 별도의 정렬 작업 없이 인덱스 순서대로 레코드를 읽기만 함으로써 order by 조건을 만족했다는 것을 의미합니다.
### 🧐 컬럼의 바이트 확인 책 내용이 오타인 것 같은데?
from_date를 조건으로 가진 상태에서 조회하면 3바이트가 나오게 되는데 이는 mysql에서 date는 3바이트만 차지하기 떄문입니다.

> 328p
> 
> 19바이트가 표시된 것을 보면 from_date 컬럼과 dept_emp 컬럼 (16) 바이트까지 사용했다는 것을 알 수 있다.
> 
> -> dept_emp 가 아닌 dep_no 컬럼 인 것 같음 

그리고 char(4)는 4바이트이자만 16바이트라고 설명하고 있는데 이는 아스키코드만 사용하는 경우 4바이트 이지만 다중 바이트 문자를 포함하는 경우에는 1글자당 4바이트를 가지게 되기 때문에 4 x 4 로 16바이트 입니다.


### 인덱스 머지(index_merge)

대부분의 옵티마이저는 인덱스를 이용해 쿼리를 실행하는 경우 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립합니다.
하지만 인덱스 머지 실행 게획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리합니다.
> 쿼리에서 한 테이블에 대한 WHERE 조건이 여러 개 있더라도 하나의 인덱스에 포함된 컬럼에 대한 조건만으로 인덱스를 검색하고 나머지 조건은 읽어온 레코드에 대해서 체크하는 형태로 사용되는 것이 일반적이기 떄문에 하나의 인덱스만 사용해서 작업 범위를 줄일 수 있는 경우라면 테이블별로 하나의 인덱스만 활용하는 것이 효율적입니다.

이처럼 하나의 인덱스만 사용해서 작업 범위를 충분히 줄일 수 있는 경우라면 테이블별로 하나의 인덱스만 활용하는 것이 효율적이지만
쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많다면 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.

- 인덱스 머지 실행 계획은 아래 3개의 세부 실행 계획으로 나누어 볼 수 있다.
- 3가지 최적화 모두 여러 개의 인덱스를 통해 결과를 가져온다는 것은 동일하지만 각각의 결과를 어떤 방식으로 병합할지 따라 구분된다.
1. index_merge_intersection
2. index_merge_sort_union
3. index_merge_union
index_merge 옵티마이저 옵션은 위의 나열된 3개의 최적화 옵션을 한 번에 모두 제어할 수 있는 옵션이고 자세한 것은 하나씩 보겠습니다.

### 인덱스 머지 - 교집합 (index_merge_intersection)
- 다음 쿼리는 2개의 where 조건을 가지고 있는데, employees 테이블의 first_name 컬럼과 emp_no 컬럼 모두 각각의 인덱스를 가지고 있습니다.
- 2개 중에서 어떤 조건을 사용하더라도 인덱스를 사용할 수 있습니다.
- 그에 따라 옵티마이저는 ix_firstname과 primary 키를 모두 사용해서 쿼리를 처리하기로 결정하는데 실행 계획의 Extra 컬럼에 Using intersect라고 표시된 것은 이 쿼리가 여러 개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환했다는 것을 의미합니다.
![[Pasted image 20231225185459.png]]
- fisrt_name 컬럼의 조건과 emp_no 컬럼의 조건 중 하나라도 충분히 효율적으로 쿼리를 처리할 수 있었다면 옵티마이저는 <u>2개의 인덱스를 모두 사용하는 실행 계획을 사용하지 않았을 것 입니다.</u>
- 즉 옵티마이저가 각각의 조건에 일치하는 레코드 건수를 예측해 본 결과, 두 조건 모두 상대적으로 많은 레코드를 가져와야 한다는 것을 알게 된 것입니다.
![[Pasted image 20231225190117.png]]

- 인덱스 머지 실행 계획이 아니었다면 다음 2가지 방식으로 처리해야 합니다.

> ⚠ 원래 이렇게 처리해야 하는 거 아니었나요?  -> 나중에 조금 더 정리하기
1.  `first_name='Georgi'` 조건만 인덱스를 사용헀다면 일치하는 레코드 253건을 검색한 다음 데이터 페이지에서 레코드를 찾고 emp_no 컬럼의 조건에 일치하는 레코드들만 반환하는 형태로 처리돼야 한다.
2. `emp_no between 10000 and 20000` 조건만 인덱스를 사용헀다면 프라이머리 키를 이용해 1만건을 읽어와서 `first_name='Georgi'` 조건에 일치하는 레코드만 반환하는 형태로 처리돼야 한다

- 위 방법도 나쁘지 않은 방법이지만 두 인덱스의 교집합만 가져오게 되면 다음과 같은 이점을 얻을 수 있습니다.
![[Pasted image 20231225190620.png]]
- 실제 두 조건을 모두 만족하는 레코드 건수는 14건입니다.
- 만약 `ix_fisrtname` 인덱스만 사용했다면 253번의 데이터 페이지 읽기를 하지만 실제 그중에서 겨우 14번만 의미 있는 작업이었을 것이고
	- 페이지 하나의 크기는 16kb이기 때문에 현재 쿼리에서는 많은 용량을 요구하지 않지만 데이터의 크기 혹은 intersection이 늘어난다면 성능상 문제가 발생할 여지가 있습니다.
- primary key 만 사용했다면 1만건을 읽어서 9986건은 버리고 겨우 14건만 반환하는 작업이 됐을 것입니다.

- 그런데 ix_firstname 인덱스는 프라이머리 키인 emp_no 컬럼을 자동으로 포함하고 있기 때문에  ix_firstname 인덱스만 사용하는 것이 더 성능이 좋을 것으로 생각할 수 있습니다.
- 이런 경우는 index_merge_intersection 최적화를 비활성화 하면 됩니다.
	- 단 전체 설정으로 변경하는 경우 모든 쿼리가 영향을 받을 수 있기 때문에 현재 커넥션 혹은 현재 쿼리에만 영향을 주도록 설정하는 것이 좋습니다
![[Pasted image 20231225195153.png]]

index_merge_intersection 옵션을 간단하게 정리
모든 세컨더리 인덱스의 리프 노드는 프라이머리 키를 가집니다. 그러다보면 세컨더리 인덱스 + 프라이머리키 검색 조건 쿼리를 사용하게 될 경우가 있습니다.
이런 상황에서 세컨더리 인덱스 혹은 프라이머리키 둘 중 하나를 먼저 처리한 후 레코드를 가져온 다음 남은 조건을 처리해도 되지만 인덱스에서 바로 처리해버리면 훨씬 효율적으로 처리가 가능합니다.

### 인덱스 머지 - 합집합 (index_merge_union)

- 인덱스 머지의 Using union은 where 절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 or 연산자로 연결된 경우에 사용되는 최적화다.![[Pasted image 20231225211613.png]]

- 위 예제 쿼리는 2개의 조건이 or로 연결돼 있습니다.
- employees 테이블에는 first_name 칼럼과 hire_date 컬럼에 각각 ix_firstname 인덱스와 ix_hiredate가 준비돼 있습니다.
- 그래서 first_name='Matt'인 조건과 hire_date='1987-03-31' 조건이 각각의 인덱스를 사용할 수 있습니다.
- 실행 계획을 보면 두 조건을 사용하는 Using Union 최적화를 사용하는 것 또한 볼 수 있습니다.
- 쿼리 실행 계획에서 Extra 컬럼에 Using union(ix_firstname, ix_hiredate)라고 표시됐는데, 이는 인덱스 머지 최적화가 ix_firstname 인덱스의 검색 결과와 ix_hiredate 인덱스 검색 결과를 Union 알고리즘으로 병합했다는 것을 의미합니다.
- 여기서 병합은 두 집합의 합집합을 가져왔다는 것을 의미합니다.

- Union 알고리즘의 숨은 비밀 중 하나는 예제로 살펴본 쿼리에서 first_name='Matt'이면서 hire_date='1987-03-31' 인 사원이 있었다면 그 사원의 정보는 ix_firstname 인덱스를 검색한 결과에도 포함돼 있을 것이며, ix_hiredate 인덱스를 검색한 결과에도 포함돼 있을 것입니다.
- 하지만 이 쿼리의 결과에서는 사원의 정보가 두 번 출력되지 않는데 MySQL은 내부적으로 다음과 같은 작업을 수행합니다.
![[Pasted image 20231225214744.png]]

- 위 그림에서 인덱스 머지 최적화의 Union 알고리즘의 작동 방식을 그림으로 표현한 것이다.
- first_name 컬럼의 검색 결과와 hire_date 컬럼의 검색 결과에서 사원 번호가 13163인 사원은 양쪽 집합에 모두 포함돼 있어서 반드시 제거해야 합니다.
- 하지만 MySQL 서버는 first_name 조건을 검색한 결과와 hire_date 컬럼을 검색한 결과가 프라이머리 키로 이미 각각 정렬돼 있다는 것을 알고 있습니다.
- 예제 쿼리를 다음과 같이 각각의 쿼리로 분리해서 실행 계획이나 쿼리 결과를 살펴보면 인덱스 검색을 통한 두 결과 집합이 모두 프라이머리 키로 정렬돼 있다는 것을 쉽게 확인할 수 있습니다.
- (쿼리 안보여줄거임)
- MySQl 서버는 두 집합에서 하나씩 가져와서 서로 비교하면서 프라이머리 키인 emp_no 컬럼의 값이 중복된 레코드들을 정렬 없이 걸러낼 수 있습니다.
- 이렇게 정렬된 두 집합의 결과를 하나씩 가져와 중복 제거를 수행할 때 사용된 알고리즘을 우선순위 큐라고 합니다.
> ⚠ 주의
> SQL 문장에서 AND 연산자와 OR 연산자는 상당히 큰 차이를 보입니다.
> 2개의 조건이 AND로 연결된 경우에는 두 조건 중 하나라도 인덱스를 사용할 수 있으면 인덱스 레인지 스캔으로 쿼리가  실행되지만
> 
> 2개의 where 조건이 or 연산자로 연결된 경우에는 둘 중 하나라도 제대로 인덱스를 사용하지 못하면 항상 풀 테이블 스캔으로밖에 처리하지 못합니다.


index_merge_union 간단히 정리
인덱스 머지 합집합은 쿼리의 조건 중 or를 사용하는 경우에서 두 조건 모두 인덱스를 사용하는 경우에 적용됩니다.
이 때 우선순위 큐를 이용해서 조건을 만족하는 인덱스를 찾는 다면 큐에 저장합니다. 이는 중복된 조건 처리에도 유용하며 최종 결과가 프라이머리키에 의해 정렬되는 특징을 가집니다.

### 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)
- 인덱스 머지 최적화의 Union 알고리즘은 두 결과 집합의 중복을 제거하기 위해 정렬된 결과를 필요로 하는데도 MySQL 서버는 별도의 정렬을 수행하지 않는다는 것과 별도의 정렬이 필요치 않은 이유에 대해 살펴봤습니다.
- 하지만 모든 경우가 인덱스 머지 과정에서 정렬이 필요하지 않은 것이 아니며 정렬이 필요한 경우 MySQL 서버는 인덱스 머지 최적화의 Sort Union 알고리즘을 사용합니다.
![[Pasted image 20231225220007.png]]
- 위 쿼리가 sort_union을 받게 된 이유는 다음과 같습니다.
- 첫 번째 조건의 경우 프라이머리 키로 정렬이 되지만 두 번째 hire_date의 경우에는 emp_no가 아닌 hire_date 순서로 정렬됩니다.
- 그렇기에 두 집합의 결과에서 중복을 제거하기 위해 각 집합을 emp_no 컬럼으로 정렬한 다음 중복 제거를 수행한다.
- 정리하면 Extra 컬럼에 Using sort union 문구가 표시된 경운는 머지 최적화에서 중복 제거를 위해 강제로 정렬을 수행한 것을 의미합니다.


### 세미 조인 (semijoin)
- 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리를 세미 조인이라고 합니다.
- MySQL 8.0 이전에는 세미 조인 형태의 쿼리를 최적화 하는 부분이 상당히 취약했습니다.
```mysql
select * from employees e
 where e.emp_no IN
  (SELECT de.emp_no from dept_emp de where de.from_date='1955-01-01')
```
- MySQL 서버에서 세미 조인 최적화 기능이 없었을 때는 위의 세미 조인 쿼리의 실행 계획은
- employees 테이블을 풀 스캔한 다음 한 건 한 건 서브쿼리의 조건에 일치하는지 비교했습니다. (현재는 다른 방식으로 처리)
- 세미 조인 형태의 쿼리와 안티 세미 조인 형태의 쿼리는 최적화 방법은 차이가 있습니다.
- 먼저 = (subquery) 형태와 In (subquery) 형태의 세미 조인 쿼리에 대해 다음과 같이 3가지 최적화 방법을 적용할 수 있습니다.
	- 세미 조인 최적화
	- IN-to-EXISTS 최적화
	- Materialization 최적화
- 그리고 <> (subquery) 형태와 Not IN (subquery) 형태의 안티 세미 조인 쿼리에 대해서는 두 가지의 최적화 방법이 있습니다.
	- in-to-exists 최적화
	- materialization 최적화
여기서는 서브쿼리 최적화 중에서 최근 도입된 세미 조인 최적화에 대해서만 살펴보겠습니다.
- MySQL 서버 8.0 버전부터는 세미 조인 쿼리의 성능을 개선하기 위한 다음과 같은 최적화 전략이 있습니다.
	- Table Pull-out
	- Duplicate Weed-out
	- First Match
	- Loose Scan
	- Materialization 


### 테이블 풀 아웃 (Table Pull out)
- 테이블 풀 아웃 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화입니다.
- 이는 서브쿼리 최적화가 도입되기 이전에 수동으로 쿼리를 튜닝하던 대표적인 방법이었습니다.
- 다음 예제 쿼리는 부서 번호가 'd0009'인 부서에 소속된 모든 사원을 조회하는 쿼리입니다.
- 아마도 In(subquery) 형태의 세미 조인이 가장 빈번하게 사용되는 형태의 쿼리을 것입니다.
![[Pasted image 20231225223839.png]]
- 실행 계획을 보면 dept_emp 테이블과 employees 테이블이 순서대로 표시돼 있는데 
- 가장 중요한 부분은 id 컬럼의 값이 모두 1인데 여기서 이 값이 동일한 값을 가진다는 것은 두 테이블이 서브쿼리 형태가 아닌 조인으로 처리됐음을 의미합니다.
- 테이블 풀 아웃 최적화는 별도로 실행 계획의 Extra 컬럼에 Using table pullout 과 같은 문구가 출력되지 않는다.
- 그래서 테이블 풀 아웃 최적화가 사용됐는지는 실행 계획에서 해당 테이블들의 id 컬럼 값이 같은지 다른지를 비교해보는 것이 가장 간단한 방법이다.
- 테이블 풀 아웃 최적화가 사용됐는지 더 정확하게 확인하는 방법은 Explain 명령을 실행한 직후 show warnings 명령으로 MySQL 옵티마이저가 재작성한 쿼리를 보는 것입니다.
(왜 warnings 동작 안함?)

간단히 정리하면 Table pollout 최적화는 서브 쿼리를 아우터 쿼리로 가져와 조인으로 풀어쓰는 최적화 방식입니다.
하지만 모든 쿼리에서 적용 가능한 것이 아닌 몇 가지 조건이 있습니다. 
1. 세미 조인 서브쿼리에서만 사용 가능
2. 서브쿼리 쿼리 부분이 유니크 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능
### 퍼스트 매치 (firstmatch)
- First Match 최적화 전략은 In( subquery) 형태의 세미 조인을 Exists 형태로 튜닝한 것과 비슷한 방법으로 실행됩니다.
- 아래는 예시 쿼리입니다.
![[Pasted image 20231225230225.png]]
1. id 컬럼의 값이 모두 1로 변경
2. Extra 컬럼에 FirstMatch(e) 문구 추가

- 실행 게획의 id 컬럼의 값이 모두 1로 표시된 것으로 봐서 위의 FirstMatch 최적화의 예제에서 titles 테이블이 서브쿼리 패턴으로 실행되지 않고, 조인으로 처리됐다는 것을 알 수 있습니다.
- FirstMatch(e)문구는 employees 테이블의 레코드에 대해 titles 테이블에 일치하는 레코드 1건만 찾으면 더이상의 titles 테이블 검색을 하지 않는다는 것을 의미합니다.
- 실제 의미론적으로는 Exists와 동일하게 처리된 것임지만 FirstMatch 는 서브쿼리가 아니라 조인으로 풀어서 실행하면서 일치하는 첫 번째 레코드만 검색하는 최적화를 실행합니다.
![[Pasted image 20231225230550.png]]

- 먼저 employees 테이블에서 first_name 컬럼의 값이 Matt 인 사원의 정보를 ix_firstname 인덱스를 이용해 레인지 스캔으로 읽은 결과입니다.
- fisrt_name이 Matt이고 사원 번호가 12302인 레코드를 titles 테이블과 조인해서 titles 테이블의 from_date가 t.from_date between ~ 조건을 만족하는 레코드를 찾아본다.
- 12302번 사원은 from_date 조건을 만족하는 레코드가 없으므로 사용자에게 반환되는 결과가 없다.

위 그림에서 본 것처럼 FIrst Match 최적화는 MySQL 에서 수행했던 최적화 방법인 In-to-Exists 변환과정과 거의 비슷한 처리 로직을 수행한다.

장점으로는 
- 여러 테이블이 조인되는 경우 원래 쿼리에는 없던 동등 조건을 옵티마이저가 자동으로 추가하는 형태의 최적화가 실행
- 기존의 in-to-exists 최적화에서는 이러한 동등 조건 전파가 서브쿼리 내에서만 가능했지만 퍼스트 매치에서는 조인 형태로 처리되기 때문에 서브쿼리뿐 아니라 아우터 쿼리의 테이블까지 전파될 수 있다.
- 퍼스트매치 최적화로 실행되면 더 많은 조건이 주어지는 것이므로 더 나은 실행계획이 만들어진다 (?)
- in-to-exists 변환 최적화 전략에서는 아무런 조건 없이 변환 가능한 경우에는 무조건 그 최적화를 수행했다.
- 하지만 퍼스트매치 최적화에서는 서브쿼리의 모든 테이블에 대해 퍼스트매치 최적화를 수행할지 아니면 일부 테이블에 대해서만 수행할지 취사선택할 수 있다는 것이 장점이다

특징
1. 퍼스트매치는 서브쿼리에서 하나의 레코드만 검색되면 더이상의 검색을 멈추는 단축 실행 경로이기 때문에 퍼스트매치 최적화에서 서브쿼리는 서브쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후에 실행된다.
2. 실행 계획의 Extra 컬럼에는 FirstMatch(table-N)문구가 표시된다.
3. 상관 서브쿼리에서도 사용될 수 있다.
4. group by나 집합 함수가 사용된 서브쿼리의 최적화에는 사용될 수 없다.


### 루스 스캔 
- 인덱스를 사용하는 group by 최적화 방법의 루스 인덱스 스캔과 비슷한 읽기 방법을 사용한다.
```mysql
explain select * from departments d where d.dept_no in (  
    select de.dept_no from dept_emp de  
    );
```

- departments 테이블의 레코드 건수는 9건밖에 되지 않지만 dept_emp 테이블의 레코드 건수는 33만건 가까이 저장돼 있습니다.
- 그런데 dept_emp 테이블에는 (dept_no + emp_no) 컬럼의 조합으로 프라이머리키 인덱스가 만들어져 있습니다.
- 그리고 프라이머리 키는 전체 레코드 건수는 33만 건 정도 있지만 dept_no만으로 그루핑해서 보면 결국 9건밖에 없다는 것을 알 수 있습니다.
- 그렇다면 dept_emp 테이블의 프라이머리 키를 루스 인덱스 스캔으로 유니크한 dept no만 읽으면 효율적으로 서브쿼리 부분을 실행할 수 있습니다.
- 그것도 중복된 레코드까지 제거하면서 말입니다.
![[Pasted image 20231226035329.png]]
위 그림에서 서브쿼리에 사용된 dept_emp 테이블이 드라이빙 테이블로 실행되며, dept_emp 테이블의 프라이머리 키를 dept_no 부분에서 유니크하게 한 건씩만 읽고 있다는 것을 보여줍니다.
루스 인덱스 스캔의 Using index of group-by도 위 그림에 표현된 dep_emp 테이블의 프라이머리 키를 읽는 방식과 동일합니다.



### 구체화 (Materialization)
- Materialization 최적화는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미입니다.
- 여기서 구체화는 쉽게 표현하면 내부 임시 테이블을 생성한다는 것을 의미 합니다.
![[Pasted image 20231226035656.png]]
위 쿼리는 1995년 1월 1일 조직이 변경된 사원들의 목록을 조회하는 쿼리로 세미 조인을 사용하는 예시입니다.
- 위 쿼리는 FirstMatch 최적화를 사용하면 employees 테이블에 대한 조건이 서브쿼리 이외에는 아무것도 없기 때문에 employees 테이블을 풀 스캔해야 할 것입니다.
- 그래서 이런 형태의 세미 조인에서는 퍼스트 매치 최적화가 성능 향상에 별로 도움이 되지 않습니다.
- MySQL 서버 옵티마이저는 이런 형태의 쿼리를 위해 서브쿼리 구체화라는 최적화를 도입했습니다.
- 실행 계획의 마지막 라인의 select_type 컬럼에 materialized라고 표시 돼 있는데 이 쿼리에서 사용하는 테이블은 2개인데 실행 계획은 3개 라인이 출력된 것을 봐도 이 쿼리의 실행 계획은 어디선가 임시 테이블이 생성됐다는 것을 알 수 있습니다.
- dept_emp 테이블을 읽는 서브 쿼리가 먼저 실행되어 그 결과로 임시 테이블이 만들어졌고 최종적으로 서브쿼리가 구체화된 테이블과 employees 테이블을 조인해서 결과를 반환합니다.

구체화를 간략하게 정리하면  In을 통한 서브쿼리를 실행할 경우 FirstMatch 최적화가 적용이 됩니다. 하지만 퍼스트 매치 최적화의 경우 드라이빙 테이블을 풀스캔하게 되는데 이는 성능 향상에 크게 도움이 되지 않습니다.
이를 위해 내부 임시 테이블을 만들고 해당 테이블과 드라이빙 테이블을 조인하면서 최적화를 하는 방식입니다.
이를 사용하기 위해서는 몇 가지 조건이 있습니다.
- IN에서 서브쿼리는 상관 서브쿼리가 아니어야 합니다.
- 서브 쿼리는 group by나 집합 함수들이 사용돼도 구체화를 사용할 수 있습니다.
- 구체화가 사용된 경우에는 내부 임시 테이블이 사용된다.



### 중복 제거(Duplicated Weed-out)
Duplicate Weedout은 세미 조인 서브쿼리를 일반적인 inner join 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘입니다.
```mysql
explain select * from employees e  
 where e.emp_no in (select e.emp_no from salaries s where s.salary > 150000);
```
salaries 테이블의 프라이머리 키가(emp_no + from_date) 인데 salary가 150000 이상인 레코드를 salaries 테이블에서 조회하면 그 결과에는 중복된 emp_no가 발생합니다.

Dulicated Weed out 최적화 알고리즘을 간단하게 이야기하면 서브쿼리를 사용하는 쿼리의 결과에서 중복이 발생하는 경우에서 inner join 과 group by 절로 바꿔서 실행하는 것과 동일한 작업으로 처리하는 것을 의미합니다.

1. 서브쿼리를 실행
2. 테이블과 조인 후 임시 테이블 생성
3. where in 에서 사용하는 키를 기준으로 중복 제거
위 과정을 거칩니다.

여기서 Extra 컬럼에 start temporary와 End temporary 문구가 별도로 표시되는데
이는 테이블의 실행 계획 라인에는 start temporary 문구 반복 과정이 끝나는 테이블의 실행 계획 라인에는 End temporary 문구가 표시됩니다. (Dplicate Weedout 최적화 과정)

제약사항 
1. 서브쿼리가 상관 서브쿼리라고 하더라도 사용할 수 있음(구체화랑 다름)
2. 서브쿼리가 group by 나 집합 함수가 사용된 경우에는 사용될 수 없습니다.
3. Duplicate Weedout은 서브쿼리의 테이블을 조인으로 처리하기 때문에 최적화할 수 있는 방법이 많음

### 컨디션 팬아웃

조인을 실행할 때 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미칩니다. 드라이빙 테이블의 크기가 드리븐 테이블보다 작다면 빠른 성능이 나오고 반대의 경우는 느립니다.
이때 condition_fanout_filter 옵티마이저 옵션을 통해 어떤 테이블을 드라이빙 테이블로 정할지 결정하는데 도움을 주기 위한 옵션입니다.

여기서 condition_fanout_filter는 filtered 컬럼의 값을 예측해내는데
두 방법을 통해서 이를 해결합니다.
1. where 조건절에 사용된 컬럼에 대해 인덱스가 있는 경우
2. where 조건절에 사용된 컬럼에 대해 히스토그램이 존재하는 경우


### 파생 테이블 머지
MySQL 서버에는 From 절에 사용된 서브쿼리는 먼저 실행해서 그 결과를 임시 테이블로 만든 다음 외부 쿼리 부분을 처리했습니다.
이는 레코드가 적을 때 메모리에 생성되지만, 임시 테이블에 저장될 레코드 건수가 많아지면 디스크로 다시 기록되고 읽는 오버헤드가 발생했습니다.

5.7버전부터는 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리부분을 제거하는 최적화가 도입되었습니다. 

모든 테이블에 대해 적용이 가능한 것이 아닌  아래 서브쿼리만 가능합니다.
- sum 또는 min, max같은 집계 함수와 윈도우 함수가 사용
- distinct
- limit
- union 
- union all
- select 절에 사용된 서브쿼리
- 값이 변경되는 사용자 변수가 사용된  경우

### 인비저블 인덱스(use_invisible_indexes)
8.0 버전부터는 인덱스의 가용 상태를 제어할 수 있는 기능이 추가됐습니다.
이전에는 인덱스가 존재하면 항상 옵티마이저가 실행 계획을 수립할 때 해당 인덱스를 검토하고 사용하도록 했지만 현재는 인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게 제어하는 기능을 제공합니다.

이때 use_invisible_indexes 옵티마이저 옵션을 이용하면 INVISBSIBLE로 설정된 인덱스라 하더라도 옵티마이저가 사용하게 제어할 수 있습니다.

### 스킵 스캔 (skip scan)

스킵 스캔 옵션을 보기전 스킵 스캡에 대해서 간략하게 이야기하면 
인덱스는 값이 정렬돼 있다는 것을 의미합니다. 즉 인덱스를 구성하는 컬럼의 순서가 매우 중요한데

A,B,C로 구성된 인덱스가 있을때 B,C는 인덱스로 사용하지 못하지만 인덱스 스킵 스캔은 제한적이긴 하지만 인덱스의 이런 제약 사항을 뛰어넘을 수 있는 최적화 기법입니다.
즉 인덱스의 선행 컬럼이 조건절에 사용되지 않더라도 후행 칼럼의 조건만으로도 인덱스를 이용한 쿼리 성능 개선이 가능합니다.

하지만 선행 컬럼의 값이 다양한 경우라면 스킵 스캔 최적화가 비효율적이기에 옵티마이저는 소수의 유니크한 값을 가질 때만 인덱스 스킵스캔 최적화를 사용합니다.
![[Pasted image 20231226142059.png]]


### 해시조인 
해시 조인은 네스티드 루프 조인을 비교대상으로 두고 이야기합니다.

해시조인은 첫 번째 레코드를 찾는 데 시간이 많이 걸리지만 최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않습니다. (최고 스루풋 전략 - Best Throughput 전략)
네스티드 루프 조인은 마지막 레코드를 찾는 데까지는 시간이 많이 걸리지만 첫 번째 레코드를 찾는 것은 상대적으로 훨씬 빠릅니다. (최고 응답 속도 전략 - Best Response time 전략)

둘 사이의 사용하는 곳은 차이가 있는데 일반적인 웹 서비스는 응답속도가 중요하고 분서과 같은 서비스는 전체 처리 소요 시간이 중요하기 때문에 전체 스루풋이 중요합니다.

MySQL은 범용 RDBMS이기 떄문에 네스티드 루프 조인이 적합하며 의도적으로 해시조인이 빠르다고 옵티마이저 힌트를 사용해서 강제로 쿼리 실행 계획을 유도하는 것은 좋지 않습니다.

블록 네스티드 루프 조인이라는 알고리즘은 조인 조건이 좋지 않은 경우에 주로 사용하는데 이는 조인 버퍼를 무한정 크게 설정할 수 없고 종니 대상 테이블의 레코드 크기가 조인 버퍼보다 큰 경우에 드라이빙 테이블을 여러 번 반복해서 스캔해야 하는 문제점이 있습니다.

현재는 블록 네스티드 루프 조인을 사용하는 즉 네스티드 루프 조인을 사용할 수 없는 상황에서 해시 조인을 사용하게 됐습니다. 

#### 빌드 단계
조인 대상 테이블 중에서 레코드 건수가 적어서 해시 테이블로 만들기에 용이한 테이블을 골라서 메모리에 해시 테이블을 생성하는 작업을 수행한다.
빌드 단계에서 해시 테이블을 민들 때 사용되는 테이블을 빌드 테이블이라고 합니다.

#### 프로브 단계
나머지 테이블의 레코드를  읽어서 해시 테이블의 일치 레코드를 찾는 과정입니ㅏㄷ.
이떄 읽는 나머지 테이블을 프로브 테이블이라고 합니다. 

![[Pasted image 20231226155316.png]]

### 인덱스 정렬 선호 (prefer_ordering_index)

MySQL 옵티마이저는 order by 혹은 group by를 인덱스를 통해 사용해 처리 가능한 경우 쿼리의 실행 계획에서 이 인덱스의 가중치를 높이 설정해서 실행하비다.

![[Pasted image 20231226143814.png]]
위 쿼리는 2가지 실행 계획이 만들어집니다.
- 인덱스를 이용해 조건에 일치하는 레코드를 칮은 후 emp_no로 정렬
- employees 테이블의 프라이머리 키가 emp_no이므로 프라이머리 키를 정순으로 읽은 후 hire_date 컬럼의 조건에 일치하는지 비교 후 결과를 반환

일반적으로 1번이 효율적이지만 간혹 2번 실행 계획을 선택할 때가 있습니다.
이는 옵티마이저의 실수이며 자주 발생하면 order by를 위한 인덱스에 가중치를 부여하지 않도록 prefer_ordering_index 옵티마이저 옵션이 추가됐습니다.
![[Pasted image 20231226144142.png]]


## 조인 최적화 알고리즘

MySQL에는 조인 쿼리의 실행 계획 최적화를 위한 알고리즘이 2개 있습니다. 
- Exhausitve 검색 알고리즘
- Greedy 검색 알고리즘

### Exhausitive 검색 알고리즘


### Greedy 검색 알고리즘
![[Pasted image 20231226165437.png]]

Greedy 검색 알고리즘은 Exhaustive 검색 알고리즘의 시간 소모적인 문제점을 해결하기 위해 MySQL 5.0부터 도입된 조인 최적화 기법
그림의 조인 최적화 순서
1. 전체 N개의 테이블 중에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
2. 1번에서 생성된 조인 조합 중에서 최소 비용의 실행 계획 하나를 선정
3. 2번에서 선정된 실행 계획의 첫 번째 테이블을 부분 실행 계획(실행 계획 완료 대상) 의 첫 번째 테이블로 선정
4. 전체 N-1개의 테이블 중(3번에서 선택된 테이블 제외)에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
5. 4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된 부분 실행 계획에 대입해 실행 비용을 계산
6. 5번의 비용 계산 결과, 최적의 실행 계획에서 두 번째 테이블을 3번에서 생성된 부분 실행 계획의 두 번째 테이블 로 선정
7. 남은 테이블이 모두 없어질 때까지 4~6번까지의 과정을 반복 실행하면서 부분 실행 계획에 테이블의 조인 순서 를 기록
8. 최종적으로 부분 실행 계획이 테이블의 조인 순서로 결정됨

optimizer_search_depth 시스템 변수는 Greedy 검색 알고리즘과 Exhaustive 검색 알고리즘 중에서 어떤 알 고리즘을 사용할지 결정하는 시스템 변수
값은 0~62까지의 정숫값을 설정할 수 있음, 1~62까지의 정숫값이 설정되면 Greedy 검색 대상을 지정된 개수로 한정해서 최적의 실행 계획을 산출
0으로 설정되면 Greedy 검색을 위해 최적의 조인 검색 테이블의 개수를 MySQL 옵티마이저가 자동으로 결정 함
조인에 사용된 테이블의 개수가 설정 값보다 크다면 설정 값 만큼의 테이블은 Exhaustive 검색이 사용되고 나머지 테이블은 Greedy 검색이 사용된다.
설정 값보다 작다면 Exhaustive 검색만 사용된다.

optimizer_prune_level 시스템 변수는 MySQL 5.0부터 추가된 Heuristic 검색이 작동하는 방식을 제어함
우리가 어떤 알고리즘을 사용하더라고 MySQL 옵티마이저는 여러 테이블의 조인 순서를 결정하기 위해 상당히 많은 조인 경로를 비교함
Heuristic 검색의 가장 핵심적인 내용은 다양한 조인 순서의 비용을 계산하는 도중 이미 계산했던 조인 순서의 비용보다 큰 경우에는 언제든지 중간에 포기할 수 있다는 것
아우터 조인으로 연결되는 테이블은 우선순위에서 제거하는 등 경험 기반의 최적화도 Heuristic 검색 최적화에는 포함돼 있다.
설정 값이 1일 경우 조인 순서 최적화에 경험 기반의 Heuristic 알고리즘을 사용
설정 값이 0일 경우 경험 기반의 Heuristic 알고리즘이 사용되지 않음
실제 Heuristic 조인 최적화는 조인 대상 테이블이 몇 개 되지 않더라도 상당한 성능 차이를 낸다. 그러므로 특별한 요건이 없다면 설정 값을 0으로 설정하지 말자.

MySQL 8.0 버전의 조인 최적화는 많이 개선되어 optimizer_search_depth 변수의 값에는 크게 영향을 받지 않는 것으로 보인다.
하지만 optimizer_prune_level을 0으로 설정하면 optimizer_search_depth 값 변화에 따라 실행 계획 수립에 소요되는 시간이 급증한다.
조인 최적화와 관련된 휴리스틱(Heuristic)의 문제점이 있었지만 MySQL 8.0에서는 이런 조인 최적화 관련된 휴리스틱을 비활성화할 필요가 거의 없어졌다.