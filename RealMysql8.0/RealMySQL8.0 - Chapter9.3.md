---
cssclasses:
  - my_style_width_100
---

# 고급 최적화
MySQL 서버의 옵티마이저가 실행 계획을 수립할 때 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립합니다.
이 때 옵티마이저 옵션은 
- 옵티마이저 옵션
- 옵티마이저 스위치
두 가지로 구분할 수 있습니다.

여기서 옵티마이저 옵션은 조인이 많이 사용되는 서비스에서 꼭 알아야 하는 옵션입니다.
## 옵티마이저 스위치 옵션
- 옵티마이저 스위치는 MySQL 5.5버전부터 지원되기 시작했습니다.
- 옵티마이저 스위치 옵션은 `optimzer_switch` 시스템 변수를 이용해서 제어하는데, `optimizer_switch` 시스템 변수에는 여러 개의 옵션을 세트로 묶어서 설정하는 방식으로 사용합니다.
- `optimizer_switch` 시스템 변수에 설정할 수 있는 최적화 옵션은 다음과 같습니다.
```
`atched_key_access={on|off}`
`block_nested_loop={on|off}`
`condition_fanout_filter={on|off}`
`derived_condition_pushdown={on|off}`
`derived_merge={on|off}`
`duplicateweedout={on|off}`
`engine_condition_pushdown={on|off}`
`firstmatch={on|off}`
`hash_join={on|off}`
`index_condition_pushdown={on|off}`
`index_merge={on|off}`
`index_merge_intersection={on|off}`
`index_merge_sort_union={on|off}`
`index_merge_union={on|off}`
`loosescan={on|off}`
`materialization={on|off}`
`mrr={on|off}`
`mrr_cost_based={on|off}`
`prefer_ordering_index={on|off}`
`semijoin={on|off}`
`skip_scan={on|off}`
`subquery_materialization_cost_based={on|off}`
`subquery_to_derived={on|off}`
`use_index_extensions={on|off}`
`use_invisible_indexes={on|off}`
```
- 각각의 옵티마이저 스위치 옵션은 default, on, off 중에서 하나를 설정할 수 있는데, on으로 설정되면 해당 옵션을 활성화하고, off를 설정하면 해당 옵션을 비활성화한다.
- 그리고 default를 설정하면 기본값이 적용된다.
- 옵티마이저 스위치 옵션은 글로벌과 세션별 모두 설정할 수 있는 시스템 변수이므로 MySQL 서버 전체적으로 또는 현재 커넥션에 대해서만 다음과 같이 설정할 수 있다.
```mysql
// MySQL 서버 전체적으로 옵티마이저 스위치 설정
set global optimizer_switch='index_merge=on,index_merge_union=on,...'; 

// 현재 커넥션의 옽비마이저 스위치만 설정
set session optimizer_switch='index_merge=on,index_merge_union=on,...';
```
- 또한 다음과 같이 "SET_VAR" 옵티마이저 힌트를 이용해 현재 쿼리에만 설정할 수 있습니다.
```mysql
select /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off'*/ 
 from ...
```

### MRR 배치 키 인덱스 (mrr & batched_key_access)
MRR은 `Multi-Range Read` 를 줄여서 부르는 이름이고 메뉴얼에서는 `DS-MMR(Disk Sweep Multi-Range Read`라고 합니다. 

MySQL 서버는 조인 대상 테이블 중 하나로부터 레코드를 읽어서 조인 버퍼에 버퍼링하는 것을 MRR이라고 합니다.
구체적으로 드라이빙 테이블의 레코드를 읽어서 드린 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링합니다. 
조인 버퍼에 레코드가 가득 차면 MySQL엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청하고 스토리지 엔진은 읽어야 할 레코드드들을 데이터 페이지에 정렬된 순서로 접근해서 디스크의 데이터 페이지 읽기를 최소화 할 수 있습니다.

MMR을 응용해서 실행되는 조인 방식을 `BKA(Batched Key ACCESS)` 라고 합니다.
기본 설정은 비활성화 인데 이는 쿼리의 특성에 따라 도움을 받을 수 있지만, BKA 조인을 사용하게 되면 부가적인 정렬 작업이 필요해지면서 오히려 성능에 안 좋은 영향을 미칠 수 있기 때문입니다.

### 블록 네스티드 루프 조인(block_nested_ loop)
MySQL 서버에서 사용되는 대부분의 조인은 네스티드 루프 조인인데, 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있는 경우 사용되는 조인 방식입니다.
아래 예제에서는 employees 테이블에서 first_name 조건에 일치하는 레코드 1건을 찾아서 salaries 테이블의 일치하는 레코드를 찾는 형태의 조인입니다.
![[Pasted image 20231223002401.png]]
 이러한 형태의 조인은 프로그래밍 언어에서 중첩된 반복 명령을 사용하는 것처럼 작동한다고 해서 네스티드 루프 조인이라고 합니다.

- 네스티드 루프 조인은 레코드를 읽어서 다른 버퍼 공간에 저장하지 않고 즉시 드리븐 테이블의 레코드를 찾아서 반환합니다.
- 네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 차이는 조인 버퍼(join_buffer_size 시스템 설정으로 조정되는 조인을 위한 버퍼)가 사용되는지 여부와 조인에서 드라이빙 테이블과 드린 테이블이 어떤 순서로 조인되느냐 입니다.

조인 알고리즘에서 "Block" 이라는 단어가 사용되면 조인용으로 별도의 버퍼가 사용됐다는 것을 의미하는데, 조인 쿼리의 실행 계획에서 Extra컬럼에 Using Join Buffer라는 문구가 표시되면 그 실행 계획은 조인 버퍼를 사용한다는 것을 의미합니다.

조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리됩니다.
즉 드라이빙 테이블은 한 번에 쭉 읽지만, 드리븐 테이블을 여러 번 읽는다는 것을 의미합니다.
예를 들어 드라이빙 테이블에서 일치하는 레코드가 1,000건이었는데, 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없었다면 드리븐 테이블에서 연결되는 레코드를 찾기 위해 1000번의 풀 테이블 스캔을 해야 합니다. 

그래서 드리븐 테이블을 검색할 때 인덱스를 사용할 수 없는 쿼리는 상당히 느려지며, 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립합니다

- 그런데 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리합니다.
- 이때 사용되는 메모리의 캐시를 조인 버퍼라고 합니다.
- 조인 버퍼는 join_buffer_size라는 시스템 변수로 크기를 제한할 수 있으며, 조인이 완료되면 조인 버퍼는 바로 해제됩니다.

- 두 테이블이 조인되는 다음 예제 코리에서 각 테이블에 대한 조건은 WHERE절에 있지만, 두 테이블 간의 연결 고리 역할을 하는 조인 조건은 없습니다.
- 그래서 dept_emp 테이블에서 from_date > '2000-01-01' 인 레코드와 employees 테이블에서 emp_no < 109004 조건을 만족하는 레코드는 카테시안 조인을 수행합니다.

![[Pasted image 20231224232624.png]]

- 위 쿼리의 실행 계획을 보면 dept_emp 테이블이 드라이빙 테이블이며, employees 테이블을 읽을 때는 조인 버퍼를 이용해 네스티드 루프 조인을 한다는 것을 Extra 컬럼의 내용으로 알 수 있습니다.
![[Pasted image 20231224232722.png]]


- 위 쿼리의 실행 계획에서 조인 버퍼가 어떻게 사용되는지 볼 수 있습니다.
1. dept_emp 테이블의 ix_fromdate 인덱스를 이용해 (from_date > '1955-01-01') 조건을 만족하는 레코드를 검색한다.
2. 조인에 필요한 나머지 컬럼을 모두 dept_emp 테이블로부터 읽어서 조인 버퍼에 저장한다.
3. employees 테이블의 프라이머리 키를 이용해 (emp_no < 109004) 조건을 만족하는 레코드를 검색한다.
4. 3번 단계에서 검색된 결과에 2번의 캐시된 조인 버퍼의 레코드를 결합해서 반환한다.

![[Pasted image 20231224233310.png]]

- 위 그림에서 중요한 점은 조인 버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인 것처럼 실행된다는 것입니다.
- 위에서 설명한 절차의 4번 단계가 employees 테이블의 결과를 기준으로 dept_emp  테이블의 결과를 결합한다는 것을 의미합니다.
- 실제 위 쿼리의 실행 계획상으로는 dept_emp 테이블이 드라이빙 테이블이 되고 employees 테이블이 드리븐 테이블이 된다.
- 하지만 실제 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리된다.
- 일반적으로 조인이 수행된 후 가져오는 결과는 드라이빙 테이블의 순서에 의해 결정되지만, 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있음을 기억해야 한다.

### 인덱스 컨디션 푸시다운 (index_condition_pushdown) 다시하기
MySQL 5.6 버전부터는 인덱스 컨디션 푸시다운(Index Condition Pushdown) 이라는 기능이 도입됐다.

간단한 테스트를 위해 다음과 같이 인덱스를 생성하고 옵티마이저 스위치를 조정해서 인덱스 컨디션 푸시다운 기능을 비활성화하자.
![[Pasted image 20231224234044.png]]

![[Pasted image 20231225000934.png]]
- 위 쿼리를 실행할 때 스토리지 엔진이 몇 건의 레코드를 읽는지 보면 last_name 조건은 ix_lastname_firstname 인덱스를 레인지 스캔으로 사용할 수 있습니다.
- 하지만 first_name like '%sal' 조건은 인덱스 레인지 스캔으로는 검색해야 할 인덱스의 범위를 좁힐 수 없습니다.
- 그래서 위 쿼리에서 last_name 조건은 ix_lastname_firstname인덱스의 특정 범위만 조회할 수 있는 조건이며, first_name like '%sal' 조건은 데이터를 모두 읽은 후 사용자가 원하는 결과인지 하나씩 비교해보는 조건으로만 사용된다.
- 실행 계획을 보면 Extra 컬럼에 Using where가 표시된 것을 확인할 수 있는데 여기서 Using where는 InnoDB 스토리지 엔진이 읽어서 반환해준 레코드가 인덱스를 사용할 수 없는 where 조건에 일치하는지 검사하는 과정을 의미합니다.
- 아래 그림은 last_name='Action' 조건으로 인덱스 레인지 스캔을 하고 테이블의 레코드를 읽은 후, fisrt_name like '%sal' 조건에 부합되는지 여부를 비교하는 과정입니다.
- 성능과 큰 관계가 없어 보이지만 매우 중요한 의미를 가지는데, 실제 테이블을 읽어서 3건의 레코드를 가져왔지만 그중 단 1건만 first_name like '%sal' 조건에 일치했습니다.
- 그런데 만약 'last_name=Action' 조건에 일치하는 레코드가 10만 건이나 되면, 그중에서 단 1건만 fisrt_name like '%sal' 조건에 일치하면 10만건의 레코드 읽기가 불필요한 작업이 됩니다.
- 



### 인덱스 확장 (use_index_extensions)
`use_index_extensions` 옵티마이저 옵션(optimizer_switch)은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 결정하는 옵션이다.
InnoDB 스토리지 엔진에서 모든 세컨더리 인덱스는 리프 노드에 프라이머리 키 값을 가지는데 이는 프라이머리 키를 클러스트링 키로 생성하는 특징 떄문입니다.

예를 들어 아래 테이블 처럼 프라이머리 키와 세컨더리 인덱스를 가진 테이블이 있다고 가정해보겠습니다.
![[Pasted image 20231225170427.png]]

( 이부분을 말로 설명할 수 있어야 할 텐데..)
dept_emp 테이블에서 프라이머리 키는 (dept_no, emp_no) 이며, 세컨더리 인덱스 ix_fromdate는 from_date 컬럼만 포함한다.
그런데 세컨더리 인덱스는 데이터 레코드를 찾아가기 위해 프라이머리 키인 dept_no와 emp_no 컬럼을 순서대로 포함한다.
그래서 최종적으로 ix_fromdate 인덱스는 (from_date, dept_no, emp_no) 조합으로 인덱스를 생성환 것과 흡사하게 작동할 수 있게 된다.
현재 MySQL 서버는 ix_fromdate 인덱스의 마지막에 (dept_no, emp_no) 컬럼이 숨어있다는 것을 인지하고 실행 계획을 수립하도록 개선했다.

- 아래 쿼리의 실행 계획을 보겠습니다.
![[Pasted image 20231225171739.png]]
- 실행 계획의 key_len 컬럼은 이 쿼리가 인덱스를 구성하는 컬럼 중에서 어느 부분까지 사용했는지를 바이트 수로 보여주는데, 이 예제에서는 19바이트가 표시된 것을 보면 from_date 컬럼 (3바이트)과 dept_emp 컬럼(16) 까지 사용했다는 것을 알 수 있다.
- `dept_no =d001` 조건을 제거해서 비교해보면 dept_no 컬럼을 사용하지 않았기 때문에 3바이트만 사용한 것을 알 수 있습니다.
![[Pasted image 20231225172003.png]]
- 뿐만 아니라 InnoDB의 프라이머리 키가 세컨더리 인덱스에 포함돼 있으므로 다음과 같이 정렬 작업도 인덱스를활용해서 처리되는 장점도 있습니다.
![[Pasted image 20231225174303.png]]

- Extra 컬럼에 Using Filesort 가 표시되지 않았기에 MySQL 서버가 별도의 정렬 작업 없이 인덱스 순서대로 레코드를 읽기만 함으로써 order by 조건을 만족했다는 것을 의미합니다.
### 🧐 컬럼의 바이트 확인 책 내용이 오타인 것 같은데?
from_date를 조건으로 가진 상태에서 조회하면 3바이트가 나오게 되는데 이는 mysql에서 date는 3바이트만 차지하기 떄문입니다.

> 328p
> 
> 19바이트가 표시된 것을 보면 from_date 컬럼과 dept_emp 컬럼 (16) 바이트까지 사용했다는 것을 알 수 있다.
> 
> -> dept_emp 가 아닌 dep_no 컬럼 인 것 같음 

그리고 char(4)는 4바이트이자만 16바이트라고 설명하고 있는데 이는 아스키코드만 사용하는 경우 4바이트 이지만 다중 바이트 문자를 포함하는 경우에는 1글자당 4바이트를 가지게 되기 때문에 4 x 4 로 16바이트 입니다.


### 인덱스 머지(index_merge)

대부분의 옵티마이저는 인덱스를 이용해 쿼리를 실행하는 경우 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립합니다.
하지만 인덱스 머지 실행 게획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리합니다.
> 쿼리에서 한 테이블에 대한 WHERE 조건이 여러 개 있더라도 하나의 인덱스에 포함된 컬럼에 대한 조건만으로 인덱스를 검색하고 나머지 조건은 읽어온 레코드에 대해서 체크하는 형태로 사용되는 것이 일반적이기 떄문에 하나의 인덱스만 사용해서 작업 범위를 줄일 수 있는 경우라면 테이블별로 하나의 인덱스만 활용하는 것이 효율적입니다.

이처럼 하나의 인덱스만 사용해서 작업 범위를 충분히 줄일 수 있는 경우라면 테이블별로 하나의 인덱스만 활용하는 것이 효율적이지만
쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많다면 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.

- 인덱스 머지 실행 계획은 아래 3개의 세부 실행 계획으로 나누어 볼 수 있다.
- 3가지 최적화 모두 여러 개의 인덱스를 통해 결과를 가져온다는 것은 동일하지만 각각의 결과를 어떤 방식으로 병합할지 따라 구분된다.
1. index_merge_intersection
2. index_merge_sort_union
3. index_merge_union
index_merge 옵티마이저 옵션은 위의 나열된 3개의 최적화 옵션을 한 번에 모두 제어할 수 있는 옵션이고 자세한 것은 하나씩 보겠습니다.

### 인덱스 머지 - 교집합 (index_merge_intersection)
- 다음 쿼리는 2개의 where 조건을 가지고 있는데, employees 테이블의 first_name 컬럼과 emp_no 컬럼 모두 각각의 인덱스를 가지고 있습니다.
- 2개 중에서 어떤 조건을 사용하더라도 인덱스를 사용할 수 있습니다.
- 그에 따라 옵티마이저는 ix_firstname과 primary 키를 모두 사용해서 쿼리를 처리하기로 결정하는데 실행 계획의 Extra 컬럼에 Using intersect라고 표시된 것은 이 쿼리가 여러 개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환했다는 것을 의미합니다.
![[Pasted image 20231225185459.png]]
- fisrt_name 컬럼의 조건과 emp_no 컬럼의 조건 중 하나라도 충분히 효율적으로 쿼리를 처리할 수 있었다면 옵티마이저는 <u>2개의 인덱스를 모두 사용하는 실행 계획을 사용하지 않았을 것 입니다.</u>
- 즉 옵티마이저가 각각의 조건에 일치하는 레코드 건수를 예측해 본 결과, 두 조건 모두 상대적으로 많은 레코드를 가져와야 한다는 것을 알게 된 것입니다.
![[Pasted image 20231225190117.png]]

- 인덱스 머지 실행 계획이 아니었다면 다음 2가지 방식으로 처리해야 합니다.

> ⚠ 원래 이렇게 처리해야 하는 거 아니었나요?  -> 나중에 조금 더 정리하기
1.  `first_name='Georgi'` 조건만 인덱스를 사용헀다면 일치하는 레코드 253건을 검색한 다음 데이터 페이지에서 레코드를 찾고 emp_no 컬럼의 조건에 일치하는 레코드들만 반환하는 형태로 처리돼야 한다.
2. `emp_no between 10000 and 20000` 조건만 인덱스를 사용헀다면 프라이머리 키를 이용해 1만건을 읽어와서 `first_name='Georgi'` 조건에 일치하는 레코드만 반환하는 형태로 처리돼야 한다

- 위 방법도 나쁘지 않은 방법이지만 두 인덱스의 교집합만 가져오게 되면 다음과 같은 이점을 얻을 수 있습니다.
![[Pasted image 20231225190620.png]]
- 실제 두 조건을 모두 만족하는 레코드 건수는 14건입니다.
- 만약 `ix_fisrtname` 인덱스만 사용했다면 253번의 데이터 페이지 읽기를 하지만 실제 그중에서 겨우 14번만 의미 있는 작업이었을 것이고
	- 페이지 하나의 크기는 16kb이기 때문에 현재 쿼리에서는 많은 용량을 요구하지 않지만 데이터의 크기 혹은 intersection이 늘어난다면 성능상 문제가 발생할 여지가 있습니다.
- primary key 만 사용했다면 1만건을 읽어서 9986건은 버리고 겨우 14건만 반환하는 작업이 됐을 것입니다.

> 이부분 조금 더 찾아보기
- 그런데 ix_firstname 인덱스는 프라이머리 키인 emp_no 컬럼을 자동으로 포함하고 있기 때문에  ix_firstname 인덱스만 사용하는 것이 더 성능이 좋을 것으로 생각할 수 있습니다.
- 이런 경우는 index_merge_intersection 최적화를 비활성화 하면 됩니다.
	- 단 전체 설정으로 변경하는 경우 모든 쿼리가 영향을 받을 수 있기 때문에 현재 커넥션 혹은 현재 쿼리에만 영향을 주도록 설정하는 것이 좋습니다.
![[Pasted image 20231225195153.png]]

### 인덱스 머지 - 합집합 (index_merge_union)

- 인덱스 머지의 Using union은 where 절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 or 연산자로 연결된 경우에 사용되는 최적화다.![[Pasted image 20231225211613.png]]

- 위 예제 쿼리는 2개의 조건이 or로 연결돼 있습니다.
- employees 테이블에는 first_name 칼럼과 hire_date 컬럼에 각각 ix_firstname 인덱스와 ix_hiredate가 준비돼 있습니다.
- 그래서 first_name='Matt'인 조건과 hire_date='1987-03-31' 조건이 각각의 인덱스를 사용할 수 있습니다.
- 실행 계획을 보면 두 조건을 사용하는 Using Union 최적화를 사용하는 것 또한 볼 수 있습니다.
- 쿼리 실행 계획에서 Extra 컬럼에 Using union(ix_firstname, ix_hiredate)라고 표시됐는데, 이는 인덱스 머지 최적화가 ix_firstname 인덱스의 검색 결과와 ix_hiredate 인덱스 검색 결과를 Union 알고리즘으로 병합했다는 것을 의미합니다.
- 여기서 병합은 두 집합의 합집합을 가져왔다는 것을 의미합니다.

- Union 알고리즘의 숨은 비밀 중 하나는 예제로 살펴본 쿼리에서 first_name='Matt'이면서 hire_date='1987-03-31' 인 사원이 있었다면 그 사원의 정보는 ix_firstname 인덱스를 검색한 결과에도 포함돼 있을 것이며, ix_hiredate 인덱스를 검색한 결과에도 포함돼 있을 것입니다.
- 하지만 이 쿼리의 결과에서는 사원의 정보가 두 번 출력되지 않는데 MySQL은 내부적으로 다음과 같은 작업을 수행합니다.
![[Pasted image 20231225214744.png]]

- 위 그림에서 인덱스 머지 최적화의 Union 알고리즘의 작동 방식을 그림으로 표현한 것이다.
- first_name 컬럼의 검색 결과와 hire_date 컬럼의 검색 결과에서 사원 번호가 13163인 사원은 양쪽 집합에 모두 포함돼 있어서 반드시 제거해야 합니다.
- 하지만 MySQL 서버는 first_name 조건을 검색한 결과와 hire_date 컬럼을 검색한 결과가 프라이머리 키로 이미 각각 정렬돼 있다는 것을 알고 있습니다.
- 예제 쿼리를 다음과 같이 각각의 쿼리로 분리해서 실행 계획이나 쿼리 결과를 살펴보면 인덱스 검색을 통한 두 결과 집합이 모두 프라이머리 키로 정렬돼 있다는 것을 쉽게 확인할 수 있습니다.
- (쿼리 안보여줄거임)
- MySQl 서버는 두 집합에서 하나씩 가져와서 서로 비교하면서 프라이머리 키인 emp_no 컬럼의 값이 중복된 레코드들을 정렬 없이 걸러낼 수 있습니다.
- 이렇게 정렬된 두 집합의 결과를 하나씩 가져와 중복 제거를 수행할 때 사용된 알고리즘을 우선순위 큐라고 합니다.
> ⚠ 주의
> SQL 문장에서 AND 연산자와 OR 연산자는 상당히 큰 차이를 보입니다.
> 2개의 조건이 AND로 연결된 경우에는 두 조건 중 하나라도 인덱스를 사용할 수 있으면 인덱스 레인지 스캔으로 쿼리가  실행되지만
> 
> 2개의 where 조건이 or 연산자로 연결된 경우에는 둘 중 하나라도 제대로 인덱스를 사용하지 못하면 항상 풀 테이블 스캔으로밖에 처리하지 못합니다.


### 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)
- 인덱스 머지 최적화의 Union 알고리즘은 두 결과 집합의 중복을 제거하기 위해 정렬된 결과를 필요로 하는데도 MySQL 서버는 별도의 정렬을 수행하지 않는다는 것과 별도의 정렬이 필요치 않은 이유에 대해 살펴봤습니다.
- 하지만 모든 경우가 인덱스 머지 과정에서 정렬이 필요하지 않은 것이 아니며 정렬이 필요한 경우 MySQL 서버는 인덱스 머지 최적화의 Sort Union 알고리즘을 사용합니다.
![[Pasted image 20231225220007.png]]
- 위 쿼리가 sort_union을 받게 된 이유는 다음과 같습니다.
- 첫 번째 조건의 경우 프라이머리 키로 정렬이 되지만 두 번째 hire_date의 경우에는 emp_no가 아닌 hire_date 순서로 정렬됩니다.
- 그렇기에 두 집합의 결과에서 중복을 제거하기 위해 각 집합을 emp_no 컬럼으로 정렬한 다음 중복 제거를 수행한다.
- 정리하면 Extra 컬럼에 Using sort union 문구가 표시된 경운는 머지 최적화에서 중복 제거를 위해 강제로 정렬을 수행한 것을 의미합니다.


### 세미 조인 (semijoin)
- 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리를 세미 조인이라고 합니다.
- MySQL 8.0 이전에는 시미 조인 형태의 쿼리를 최적화 하는 부분이 상당히 취약했습니다.
```mysql
select * from employees e
 where e.emp_no IN
  (SELECT de.emp_no from dept_emp de where de.from_date='1955-01-01')
```
- MySQL 서버에서 세미 조인 최적화 기능이 없었을 때는 위의 세미 조인 쿼리의 실행 계획은
- employees 테이블을 풀 스캔한 다음 한 건 한 건 서브쿼리의 조건에 일치하는지 비교했습니다. (현재는 다른 방식으로 처리)
- 세미 조인 형태의 쿼리와 안티 세미 조인 형태의 쿼리는 최적화 방법은 차이가 있습니다.
- 먼저 = (subquery) 형태와 In (subquery) 형태의 세미 조인 쿼리에 대해 다음과 같이 3가지 최적화 방법을 적용할 수 있습니다.
	- 세미 조인 최적화
	- IN-to-EXISTS 최적화
	- Materialization 최적화
- 그리고 <> (subquery) 형태와 Not IN (subquery) 형태의 안티 세미 조인 쿼리에 대해서는 두 가지의 최적ㅎ롸 방법이 있습니다.
	- in-to-exists 최적화
	- materialization 최적화
여기서는 서브쿼리 최적화 중에서 최근 도입된 세미 조인 최적화에 대해서만 살펴보겠습니다.
- MySQL 서버 8.0 버전부터는 세미 조인 쿼리의 성능을 개선하기 위한 다음과 같은 최적화 전략이 있습니다.
	- Table Pull-out
	- Duplicate Weed-out
	- First Match
	- Loose Scan
	- Materialization 


### 테이블 풀 아웃 (Table Pull out)
- 테이블 풀 아웃 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화입니다.
- 이는 서브쿼리 최적화가 도입되기 이전에 수동으로 쿼리를 튜닝하던 대표적인 방법이었습니다.
- 다음 예제 쿼리는 부서 번호가 'd0009'인 부서에 소속된 모든 사원을 조회하는 쿼리입니다.
- 아마도 In(subquery) 형태의 세미 조인이 가장 빈번하게 사용되는 형태의 쿼리을 것입니다.
![[Pasted image 20231225223839.png]]
- 실행 계획을 보면 dept_emp 테이블과 employees 테이블이 순서대로 표시돼 있는데 
- 가장 중요한 부분은 id 컬럼의 값이 모두 1인데 여기서 이 값이 동일한 값을 가진다는 것은 두 테이블이 서브쿼리 형태가 아닌 조인으로 처리됐음을 의미합니다.
- 테이블 풀 아웃 최적화는 별도로 실행 계획의 Extra 컬럼에 Using table pullout 과 같은 문구가 출력되지 않는다.
- 그래서 테이블 풀 아웃 최적화가 사용됐는지는 실행 계획에서 해당 테이블들의 id 컬럼 값이 같은지 다른지를 비교해보는 것이 가장 간단한 방법이다.
- 테이블 풀 아웃 최적화가 사용됐는지 더 정확하게 확인하는 방법은 Explain 명령을 실행한 직후 show warnings 명령으로 MySQL 옵티마이저가 재작성한 쿼리를 보는 것입니다.
(왜 warnings 동작 안함?)


### 퍼스트 매치 (firstmatch)
- First Match 최적화 전략은 In( subquery) 형태의 세미 조인을 Exists 형태로 튜닝한 것과 비슷한 방법으로 실행됩니다.
- 아래는 예시 쿼리입니다.
![[Pasted image 20231225230225.png]]
1. id 컬럼의 값이 모두 1로 변경
2. Extra 컬럼에 FirstMatch(e) 문구 추가

- 실행 게획의 id 컬럼의 값이 모두 1로 표시된 것으로 봐서 위의 FirstMatch 최적화의 예제에서 titles 테이블이 서브쿼리 패턴으로 실행되지 않고, 조인으로 처리됐다는 것을 알 수 있습니다.
- FirstMatch(e)문구는 employees 테이블의 레코드에 대해 titles 테이블에 일치하는 레코드 1건만 찾으면 더이상의 titles 테이블 검색을 하지 않는다는 것을 의미합니다.
- 실제 의미론적으로는 Exists와 동일하게 처리된 것임지만 FirstMatch 는 서브쿼리가 아니라 조인으로 풀어서 실행하면서 일치하는 첫 번째 레코드만 검색하는 최적화를 실행합니다.
![[Pasted image 20231225230550.png]]