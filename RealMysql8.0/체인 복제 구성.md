![[Pasted image 20240416134830.png]]

멀티 레플리카 복제 구성에서 레플리카 서버가 너무 많아 소스 서버의 성능에 악영향이 예상된다면 1:M:N 구조의 체인 복제 구성을 고려할 수 있다. 

## 등장 배경
MySQL 복제에서 소스 서버는 레플리카 서버가 요청할 때마다 계속 바이너리 로그를 읽어서 전달해야 한 다. 만약 하나의 소스 서버에 연결된 레플리카 서버 수가 많다면 바이너리 로그를 읽고 전달하는 작업 자체가 부하가 될 수 있습니다.

즉 소스 서버가 해야 할 바이너리 로그 배포 역할을 새로운 MySQL 서버로 넘길 필요가 있기 때문에 체인 복제 구성 방식이 등장했습니다.

## 연결 방식
- 먼저 MySQL 복제에서 소스 서버가 해야 할 바이너리 로그 배포 역할을 레플리카 서버1-3/소스 서버2로 넘깁니다. 
- 소스 서버를 기준으로 1차 복제 그룹에 레플리카 서버 1-1, 레플리카 서버 1-2, 레플리카 서버1-3/소스 서버2를 연결한다. 
- 2차 복제 그룹에 레플리카 서버 2-1, 레플리카 서버 2-2를 연결한다. 
- 1차 복제 그룹은 소스 서버 1과 직접 연결돼 있는 서버들을 OLTP 서비스 용도로 사용
- 2차 복제 그룹은 통계나 배치, 백업 용도로 구분해서 사용한다. 


## 용도
- 이 복제 형태는 MySQL 서버를 업그레이드하거나 장비를 교체할 때 주로 사용
- 기존 장비의 MySQL은 그대로 두고, 새로운 장비에 업그레이드한 MySQL을 설치한 후, 데이터를 신규 장비로 옮기는 형태의 업그레이드로 ==서비스의 멈춤 없이 진행할 수 있다==.
### 교체 방식 훑어보기 
- 1차 복제 그룹(소스 서버2 제외)이 기존 버전의 MySQL 서버이고,
- 1-3 레플리카 서버가 연결된 2차 복제 그룹을 새로 업그레이드 하는 버전의 MySQL로 볼 수 있다. 
#### 1단계
![[Pasted image 20240416141006.png]]
- 소스 서버 1대와 레플리카 서버 2대로 서비스 운영을 하고 있을때 하드웨어나 MySQL 서버의 버전을 업그레이드
- 업그레이드된 장비 3대를 위와 같은 구조로 기존의 복제에 투입해서 복제 동기화
#### 2단계
![[Pasted image 20240416141019.png]]
-  복제가 준비되면 웹 서버나 애플리케이션 서버에서 기존 MySQL 서버에 접속할 때 사용하던 도메인 네임, IP주소를 새로운 MySQL 서버들을 바라보게끔 변경
- 웹 서버나 애플리케이션 서버를 한 대씩 돌아가며 재시작 (connection url이 달라지기 때문)

> 재시작되기 전의 서버들은 기존의 MySQL 서버로 접속해 쿼리를 실행하지만 변경 내용은 모두 새로운 MySQL 서버로 자동 전달된다.
#### 3단계
![[Pasted image 20240416141031.png]]
- 웹 서버나 애플리케이션 서버가 전부 재시작 완료되면, MySQL 서버 3대 모두 복제 그룹에서 제외


#### 4단계
![[Pasted image 20240416141042.png]]

> 최종적으로 업그레이드된 MySQL 서버만으로 서비스를 운영함


## 정리
- 이처럼 체인 형태의 복제를 구성하려면 레플리카 서버인 동싱 소스 서버역할을 하는 서버에서 바이너리 로그와 `log_slave_updates` 시스템 변수가 반드시 활성화돼 있어야 한다.