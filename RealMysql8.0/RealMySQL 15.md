---
cssclasses:
  - my_style_width_100
---
# 용어
- 물리 모델링 


컬럼의 데이터 타입과 길이 선정 시 주의점 
1. 저장되는 값의 성격에 맞는 최적의 타입 선정
2. 가변 길이 컬럼은 최적의 길이 지정
3. 조인 조건으로 사용되는 컬럼은 똑같은 데이터 타입으로 선정 


> 컬럼의 데이터 타입을 선정할 때 실제 저장되는 값의 특성을 고려하지 않고 가능한 최대 길이 값을 기준으로 컬럼의 길이를 선택하는 것이 일반적


# 문자열(char와 varchar)

`char` vs `varchar`


## 저장 공간
- char는 고정 길이 
- varchar는 가변 길이

> ⚠ 고정길이
> 고정 길이는 실제 입력되는 컬럼의 길이에 따라 사용하는 저장 공간의 크기가 변하지 않음
> CHAR 타입은 저장 공간의 크기가 고정이며 실제 저장된 값의 유효 크기가 얼마인지 별도로 저장할 필요가 없으므로 추가로 공간이 필요하지 않음

> ⚠ 가변 길이
> 가변 길이는 최대로 저장할 수 있는 값의 길이는 제한돼 있지만, 그 이하 크기의 값이 저장되면 그만큼 저장 공간이 줄어든다.
> 하지만 varchar 타입은 저장된 값의 유효 크기가 얼마인지를 별도로 저장해 둬야 하므로 1~2바이트의 저장 공간이 추가로 필요함

- char(1), varchar(1) 타입을 각각 사용할 때 두 문자열 타입 모두 한 글자를 저장할 때 사용하는 문자 집합에 따라 실제 저장 공간을 1~4바이트까지 사용

공통점
- char, varchar 모두 한 글자를 저장할 때 1~4바이트 사용 (utf의 경우 4바이트

차이점
- varchar의 경우 저장할 문자열의 길이를 관리하기 위한 1~2바이트의 공간을 추가로 필요로 합니다
	- `255바이트 이하면 1바이트만 사용하고 256바이트 이상은 2바이트를 추가로 사용`
	- varchar 타입의 최대 길이는 2바이트로 표현할 수 있는 이상은 사용할 수 없습니다. (2^16 = 65,536)

추가
- MySQL TEXT, BLOB 타입을 제외한 컬럼의 전체 크기가 64kb를 초과할 수 없습니다.
- A 컬럼에서 40kb를 사용하고 있다면 B컬럼에서는 24kb만 사용할 수 있습니다.
- 만약 초과하게 된다면 VARCHAR 타입이 TEXT 타입으로 대체됩니다.

![[Pasted image 20240323185352.png]]

왜 16383바이트 보다 큰 값을 저장할 수 없는가
- 사용하고 있는 콜레이션에서 한 글자당 4바이트를 사용하고 있기 때문에 ceil(65536 / 4)가 컬럼이 가질 수 있는 최대 바이트 값



그럼 무엇을 써야 할까?
- 문자열 값의 길이가 항상 일정하다면 char를 사용하고 가변적이라면 varchar를 사용하는 것이 일반적입니다.
- varchar타입을 선택해도 디스크에서 1바이트만 더 사용한다면 고민할 필요 없이 varchar를 사용하는게 맞지 않을까?

- 실제 문자열 값의 길이가 정적인지 가변인지 여부로 char, varchar타입을 결정하는 것은 적절하지 않습니다.

RealMysQL에서는 두 가지 기준을 제시 
1. 저장되는 문자열의 길이가 대개 비슷한가?
2. 컬럼의 값이 자주 변경되는가?

=> 값의 길이도 중요하지만, 칼럼의 값의 변경 빈도가 높은지가 기준이 돼야 함



SMP(Supplementary Multilingual Plane) & SIP(Supplementary Ideographic Plane)


![[Pasted image 20240323205308.png]]

tb_test테이블에 레코드 1건을 저장하면 내부적으로 디스크에는 아래와 같이 저장됩니다. 
![[Pasted image 20240323205335.png]]

여기서 char(10) -> varchar(10)으로 변경하면 아래와 같이 적용됩니다.
![[Pasted image 20240323205358.png]]


여기서 만약  ABCD -> ABCDE와 같이 길이가 더 큰 값을 변경될 떄는 레코드 자체를 다른 공간으로 옮겨서 저장 합니다. 
이 과정을 `Row migration`이라고 합니다. 


결론
 - 주민번호 같이 항상 길이가 고정적일 떄 char를 사용해야 함 
 - 또 값이 2~3바이트씩 차이가 나더라도 자주 변경될 수 있는 부서 번호나 게시물의 상태 값 등은 char타입을 사용
 - `자주 변경돼도 레코드가 물리적으로 다른 위치로 이동하거나 분리되지 않기 떄문`
 - -> 레코드의 이동이나 분리는 2~3바이트 공간 낭비보다 더 큰 공간, 자원을 낭비


문자열 데이터 타입을 사용할 떄 주의점
- char, varchar 키워드 뒤에 인자로 전달하는 숫자 값의 주의점
	- MySQL에서는 char, varchar 뒤에 지정하는 숫자는 칼럼의 바이트 크기가 아닌 문자의 수를 의미함
	- 즉 varchar(10)으로 컬럼을 정의하면 10글자를 저장할 수 있는 공간을 의미함



## 저장 공간과 스키마 변경 (Online DDL)
- Oneline DDL은 `서버에서 데이터가 변경되는 도중에도 스키마 변경을 할 수 있도록 제공하는 기능`
	- 모든 스키마 변경이 오란인으로 가능한 것은 아님
	- select만 가능하고, insert update 같은 변경이 허용되지 않을 수 있음
- varchar 데이터 타입을 사용하는 컬럼의 길이를 늘리는 작업은 길이에 따라 테이블에 읽기 잠금을 걸고 레코드를 복사하는 작업이 필요할 수 있음

![[Pasted image 20240324171519.png]]

![[Pasted image 20240324171532.png]]

- 컬럼의 타입을 varchar(63)으로 늘리는 경우는 잠금 없이 변경할 수 있다
- 반면에 varchar(64)로 변경하는 경우에는 특히 INPLACE알고리즘으로 스키마 변경을 실행했으며, COPY알고리즘으로 스키마 변경을 실행했기에 스키마 변경 시간도 많이 걸리게 된다. 
![[Pasted image 20240324171749.png]]
- 이러한 차이가 발생하는 이유는 varchar 타입의 컬럼이 가ㅣ는 길이 저장 공간의 크기 때문입니다. 
- varchar(60)은 utf8mb4 문자 집합을 사용하는 varchar(60) 컬럼의 최대 길이는 240바이트이기 때문에 문자열 값의 길이를 저장하는 공간은 1바이트면 충분
- 하지만 varchar(64) 타입은 저장할 수 있는 문자열의 크기가 최대 256바이트까지 이기 떄문에 저장 공간의 크기를 2바이트로 변경해야 한다.
- 즉 MySQL 서버는 스키마 변경을 하는 동안 읽기 잠금을 걸어서 아무도 데이터를 변경하지 못하도록 막고 테이블의 레코드를 복사하는 방식으로 처리해야 함


## 문자 집합(캐릭터 셋)
- MySQL 서버에서는 각 테이블의 컬럼은 모두 서로 다른 문자 집합을 사용해 문자열 값을 저장할 수 있습니다. 
- 문자 집합은 문자열을 저장하는 `char`, `varchar`, `TEXT`타입의 컬럼에만 설정할 수 있습니다. 
- 테이블 전체에 문자집합을 UTF-8로 설정하면 문자 집합이 적용되는 컬럼은 UTF-8이 기본 설정이다.
- 물론 특정 문자열 집합을 컬럼별로 지정해서 변경하는 것 또한 가능하다. 

문자열 집합 조회
![[Pasted image 20240324172826.png]]

- 출력 내용을 보면 다양한 문자 집합이 있지만 한국엣는 euckr, utf8mb4만 사용해도 충분합니다.

- show character set 명령의 결과에서 Default collation 컬럼에는 해당 문자 집합의 기본 콜레이션이 무엇인지 표시해줍니다.
- 기본 콜레이션이란 `컬럼에 콜레이션은 명시하지 않고 문자 집합만 지정했을 때 설정되는 콜레이션을 의미합니다.`


MySQL에서는 문자 집합을 결정하는 여러 시스템 변수가 존재함
- `character_set_system`: MySQL 서버가 식별자를 저장할 때 사용하는 문자 집합
- `character_set_server`: MySQL 서버의 기본 문자 집합으로 DB나 테이블 또는 컬럼에 아무런 문자 집합이 설정되지 않았을 떄 해당 시스템 변수에 명시된 문자 집합이 기본으로 사용된다.
- `character_set_database`: MySQL DB의 기본 문자 집합으로 시스템 변수에 명시된 문자 집합이 기본값으로 사용
- `character_set_filesystem `: `LOAD DATA INFILE ..` 혹은 `SELECT ... INTO OUTFILE` 문장을 실행할 때 인자로 지정되는 파일의 이름을 해석할 때 사용되는 문자 집합
- `character_set_client`: MySQL 클라이언트가 보낸 SQL 문장은 `character_set_client`에 설정된 문자 집합으로 인코딩해서 MySQL 서버로 전송한다.
- `character_set_connection`: MySQL 서버가 클라이언트로부터 전달받은 SQL 문장을 처리하기 위해 `character_set_connection` 의 문자 집합으로 변환한다.
- `character_set_result`: MySQL 서버가 쿼리의 처리 결과를 클라이너트로 보낼 때 사용하는 문자 집합을 설정하는 시스템 변수


### 클라이언트로부터 쿼리를 요청했을 때의 문자 집합
- MySQL 서버는 클라이너트로부터 받은 메시지가 character_set_client에 지정된 문자 집합으로 인코딩돼 있다고 판단하고, 받은 문자열 데이터를 `character_set_connection`에 정의된 문자 집합으로 변환합니다.
- 여기서 sql 문장에 별도의 문자 집합이 지정된 리터럴은 변환 대상에 포함돼지 않습니다. 
- 그렇기에 `인트로듀서` 를 활용하여 sql문장에서 별도의 문자 집합을 지정할 수 있습니다. 

![[Pasted image 20240324175114.png]]

- 사용법은 문장 기호 `-`와 사용하고자 하는 문자열 집합을 붙혀서 사용하면 된다. 

### 처리 결과를 클라이언트로 전송할 떄의 문자 집합 변환
- character_set_connection에 정의된 문자 집합으로 변환해 sql을 실행한 다음, MySQL서버는 쿼리의 결과를 `character_set_results` 변수에 설정된 문자 집합으로 변환해 클라이언트로 전송합니다. 
- 이 때 결과 셋에 포함된 컬럼의 값, 컬럼명과 같은 메타데이터 모두 `character_set_results`로 인코딩되어 클라이너트로 전송됩니다

![[Pasted image 20240324184553.png]]


## 콜레이션(Collation)

> ⚠ 콜레이션
> 
> 콜레이션은 문자열 칼럼의 값에 대한 비교나 정렬 순서를 위한 규칙을 의미합니다.> 
> 비교, 정렬 작업에서 염문 대소문자를 같은 것으로 처리할지, 혹은 더 크거나 작은 것으로 판단할지에 대한 규칙을 정의하는 것

-  `MySQL의 모든 문자열 타입의 컬럼은 독립적인 문자 집합과 콜레이션을 가집니다.`
- 각 컬럼에 대해 독립적으로 문자 집합이나 콜레이션을 지정하든 그렇지 않든 독립적인 문자 집합과 콜레이션을 가지는 것입니다.


### 콜레이션 이해
- 문자 집합은 2개 이상의 콜레이션을 가지고 있습니다.
- 하나의 문자 집합에 속한 코레이션은 다른 문자 집합과 공유해서 사용할 수 없으며 해당 문자 집합의 디폴트 콜레이션이 해당 컬럼의 콜레이션으로 지정됩니다.
- 반대로 칼럼의 문자 집합은 지정하지 않고 콜레이셔만 지정하면 해당 콜레이션이 소속된 문자 집합이 묵시적으로 그 컬럼의 문자 집합으로 사용됩니다. 

- 일반적으로 콜레이션의 이름은 2개 또는 3개의 파트로 구분돼 있으며, 각 파트는 다음과 같은 의미로 사용됩니다. 
	- 3개의 파트로 구성된 콜레이션
		- 첫 번째 파트는 문자 집합의 이름
		- 두 번째 파트는 해당 문자 집합의 하위 분류
		- 세 번째 파트는 대문자나 소문자의 구분 여부, 세 번째 파트가 `ci` 면 대소문자를 구분하지 않는 콜레이션
		- `cs`면 대소문자를 별도의 문자로 구분하는 콜레이션
	-  2개의 파트로 구성된 콜레이션
		- 첫 번째 파트는 문자 집합의 이름
		- 두 번쨰 파트는 항상 `bin` 이라는 키워드를 사용, 이진 데이터로 관리되는 문자열 컬럼은 별도의 콜레이션을 가지지 않음


- utf8mb4문자 집합의 콜레이션의 이름은 기존의 문자 집합의 콜레이션보다 복잡해졌습니다. 
	- utf8mb4_0900 -> 0090은 UCA의 버전을 의미
	- utf8mb4_unicode_520_ci 콜레이션에서 520은 UCA 5.2.0을 의미
	- 추가로 액센트 문자의 구분 여부가 콜레이션의 이름에 포함
		- utf8mb4_0900_ai_ci -> 엑센트를 가진 문자와 그렇지 않은 문자들을 정렬상 동일 문자로 판단할지 여부를 나타냄

- 자주 사용하는 문자집합의 디폴트 콜레이션은 다음과 같습니다.
	- `latin1` -> `latin1_swedish_ci`
	- `euckr`  -> `euckr_korean_ci`
	- `utf8mb4` -> `utf8mb4_0900_ai_ci`
- 이들 모두 대소문자를 구분하지 않는 콜레이션이며 만약 필요하다면 `_cs` 계열의 콜레이션을 명시적으로 지정해야 함
(370) start

주의점
- MySQL의 문자열 컬럼은 콜레이션 없이 문자 집합만 가질 수 없다. (지정하지 않는 경우 기본 콜레이션 사용)
- 문자열 컬럼의 정렬이나 비교는 콜레이션에 의해 판단하므로 문자열 컬럼에서 char, varhar 같은 타입의 이름과 길이만 같다고 해서 똑같은 `타입`이라고 판단해서는 안 된다. -> 왜 타입이라고 이야기 함? char,varchar를 말하넹
- 즉 타입의 이름, 길이, 콜레이션까지 일치해야 같은 타입 
- 문자열 컬럼에서는 문자 집합과 콜레이션이 모두 일치해야만 앞에서 배운 조인이나 where 조건이 인덱스를 효율적으로 사용할 수 있음 
- 조인의 경우 양쪽 테이블의 컬럼이 문자 집합이나 콜레이션이 다르다면 비교 작업에서 콜레이션의 변환이 필요하기 때문에 인덱스를 효율적으로 이용하지 못함 -> 컬럼에 변형이 가해지면 인덱스를 활용하지 못함


테이블에 콜레이션 적용 
![[Pasted image 20240325114158.png]]

1. `CREATE DATBASE` 명령으로 기본 문자 집합이 `utf8mb4`인 데이터베이스 생성
	- 해당 데이터베이스에서 생성된 테이블의 기본 콜레이션으로 영향을 받음
2. `CREATE TABLE` 명령으로 각 컬럼이 서로 다른 문자 집합이나 콜레이션을 사용하도록 정의
	1. `latin1_general_cs`를 사용 `_cs`계열의 콜레이션으로 대소문자 구분 및 정렬 가능
	2. `utf8_bin` 한글 및 다른 나라의 언어를 사용할 수 있지만 `_bin` 계열의 콜레이션으로 대소문자 구분 정렬 비교 수행
	3. `utf8mb4` 를 사용하며 `utf8mb4_0900_ai_ci` 콜레이션을 사용해 비교, 정렬 시 대소문자 구분하지 않음


규칙 테스트
![[Pasted image 20240325120718.png]]![[Pasted image 20240325120750.png]]
- latin1_general_ci 콜레이션을 사용하고 있으며 정렬 순서로 대소문자 구분없이 정렬

![[Pasted image 20240325120931.png]]
`latin1_general_cs` 콜레이션으로 정렬, 같은 단어에서 대문자가 먼저 오도록 정렬

![[Pasted image 20240325121029.png]]
- `latin1_bin` 콜레이션은 대문자가 먼저 오도록 정렬

![[Pasted image 20240325121104.png]]
- `latin7` 콜레이션이 경우 특수 문자만 먼저 정렬하는 방식



where 검색 중 대소문자 구분 없이 실행하되 정렬은 대소문자를 구분해서 사용해야 한다면 어떻게 해야 할까?
- 이 경우 검색과 정렬 작업 중 하나는 인덱스를 이용하는 것을 포기해야 함
- 보통 컬럼의 콜레이션을 `_ci` 로 만들어 인덱스를 충분히 이용할 수 있도록 하고, 
- 정렬 작업은 `filesort`를 활용함

#### utf8mb4 문자 집합의 콜레이션

아래는 콜레이션별 UCA버전

![[Pasted image 20240325122015.png | 600]]

- 콜레이션 이름에 locale이 포함돼 있는지 여부로 언어에 종속적인 콜레이션과 언어에 비종속적인 콜레이션으로 구분 가능
![[Pasted image 20240325122050.png]]

- `utf8mb4_0900_ai_ci` 와 같이 언어 비종속적인 콜레이션은 문자 셋의 기본 정렬 순서에 의해 정렬 및 비교 수행
- 언어 종석적인 콜레이션은 해당 언어에서 정의한 정렬 순서에의해 정렬 및 비교 수행


성능 비교
- MySQL 메뉴얼에서 `UCA 9.0.0` 버전은 그 이전 버전의 콜레이션보다 빠르다고 하지만 실제 테스트서는 그렇지 않습니다.
- 해당 버전을 사용하는 콜레이션 모두 `NO PAD` 옵션으로 문자열 비교 작업이 처리되기 때문에 특정 케이스에서는 이전 버전의 콜레이션보다 더 빠르거나 하는 성능에 큰 영향이 없다고 이야기합니다(저자 생각)
- 실제 성능 비교를 해보면 이전 버전이 더 빠른 결과를 보입니다
- ![[Pasted image 20240325123907.png]]

- 성능 차이가 있지만 문자열 비교 한 번에 대략 0.1마이크로초밖에 차이가 나지 않습니다. 
- <b>그렇기에 성능을 기준으로 콜레이션을 선택하는 것은 올바르지 않습니다.</b>

(378 start)

## 비교 방식
- MySQL의 char, varchar의 비교 방식은 거의 같습니다. 
- MySQL 서버에서 대부분의 문자 집합과 콜레이션에서 char, varchar 타입을 비교할 때 <b>공백 문자를 붙혀 두 문자열의 길이를 동일하게 만든 후 비교를 수행합니다.</b> 
 ![[Pasted image 20240325191308.png]]![[Pasted image 20240325191318.png]]

- 반면 UCA 9.0.0을 지원하면서 문자열 뒤에 붙어있는 공백 문자들에 대한 비교 방식이 달라졌습니다.
	- `utf8mb4_0900_bin` 콜레이션을 보면 문자열 j뒤의 공백이 비교 결과에 영향을 미치는 것을 알 수 있음

![[Pasted image 20240325191435.png]]

- 이런 이유로 `utf8mb4` 문자집합을 사용하는 경우 `information_schema` 데이터베이스의 `collations` 뷰에서 `PAD_ATRIBUTE` 컬럼 값을 확인하는 것을 권장
- ![[Pasted image 20240325191828.png]]
- PAD SPACE: 비교 대상 문자열의 길이가 같아지도록 공백을 붙혀 비교 연산 수행
- NO PAD: 별도의 문자열 길이를 일치시키지 않고 그대로 비교

## 문자열 이스케이프 처리
- MySQL에서 SQL 문장에 사용하는 문자열은 프로그래밍 언어처럼 `\` 처리가 가능함
![[Pasted image 20240325192340.png]]![[Pasted image 20240325192347.png]]


# 숫자
