---
cssclasses:
  - my_style_width_100
---

DDL - DBMS 서버의 모든 오브젝트를 생성하거나 변경하는 쿼리

# 온라인 DDL

MySQL 서버에서 테이블의 구조를 변경하는 동안 다른 커넥션에서 DML을 실행할 수 없었습니다.

## 온라인 DDL 알고리즘

온라인 DDL은 스키마를 변경하는 작업 도중에도 다른 커넥션에서 해당 테이블의 데이터를 변경하거나 조회하는 작업을 가능하게 합니다.

온라인 DDL은 
- ALGORITHM
- LOCK
두 옵션을 이용해 어떤 모드로 스키마 변경을 실행할지 결정할 수 있습니다.

 ~~온라인 DDL 기능은 테이블의 구조를 변경하거나 인덱스 추가와 같은 대부분의 작업에 대해 작동합니다.~~

MySQL 서버에서는 `old_alter_table` 시스템 변수를 이용해 `ALTER TABLE` 명령이 온라인 DDL로 작동할지 혹은 테이블의 읽고 쓰기를 막고 스키마를 변경하는 예전 방식으로 처리할지 결정할 수 있습니다.

MySQL 8.0 버전에서는 old_alter_table 시스템 변수의 기본값은 off로 설정돼 있기 때문에 온라인 ddl이 활성화 되는데 이 때 alter table 명령을 실행하면 아래와 같은 동작 순서로 스키마 변경에 적합한 알고리즘을 찾습니다.

1. ALGORITHM=INSTANT로 스키마 변경이 가능한지 확
2. ALGORITHM=INPLACE로 스키마 변경이 가능한지 확인
3. ALGORITHM=COPY 알고리즘 선택

스키마 변경 알고리즘의 우선순위가 낮을수록 MySQL 서ㅓ는 스키마 변경을 위해서 더 큰 잠금과 많은 작업을 필요로 하고 서버의 부하도 많이 발생시킵니다.

- INSTANT: 테이블의 데이터는 변경하지 않고 메타데이터만 변경 
	- 테이블이 가진 레코드 건수와 무관하게 작업 시간은 매우 짧으며 스키마 변경 도중 테이블의 읽고 쓰기는 대기하게 되지만 스키마 변경 시간이 매우 짧기 때문에 다른 커넥션의 쿼리 처리에는 영향이 없다.
- INPLACE: 임시 테이블로 데이터를 복사하지 않고 스키마 변경을 실행합니다.
	1. 내부적으로는 테이블의 리빌드를 실행할 수도 있으며
	2. 레코드의 복사 작업은 없지만 테이블의 모든 레코드를 리빌드해야 하기 때문에 테이블의 크기에 따라 많은 시간이 소요
	3. 하지만 스키마 변경 중에도 테이블의 일기와 쓰기 모두 가능
	4. INPLACE 알고리즘으로 스키마가 변경되는 경우에도 최초 시작 시점과 마지막 종료 시점에는 테이블의 일고 쓰기가 불가능
	5. 대신 시간이 매우 짧기 때문에 다른 커넥션의 쿼리 처리에 대한 영향도는 높지 않습니다.
- COPY: 변경된 스키마를 적용한 임시 테이블을 생성하고
	1. 테이블의 레코드를 모두 임시 테이블로 복사한 후 최종적으로 임시 테이블을 rename해서 스키마 변경을 완료합니다.
	2. copy 방식은 테이블 읽기만 가능하고 dml은 실행할 수 없습니다.


+온라인 DDL 명령은 알고리즘을 사용하는 방법과 함께 잠금 수준도 함께 명시할 수 있습니다.
> 만약 잠금 수준이 명시되지 않으면 MySQL서버는 처음 언급한 세 가지 방법 중에서 적절한 수준의 알고리즘과 잠금 수준을 선택합니다.


```mysql
         ALTER TABLE salaries change to_date end_date date not null, algorithm=inplace, lock=NONE;
```

온라인 DDL에서 INSTANT 알고리즘은 테이블의 메타데이터만 변경하기 때문에 짧은 시간 동안의 메타데이터 잠금만 필요로 합니다.

INSTANT 알고리즘을 사용하는 경우에는 LOCK옵션은 명시할 수 없습니다.  대신 INPLACE, COPY 알고리즘을 사용하는 경우 LOCK은 아래 3가지 중 하나를 명시함


- NONE: 잠금을 걸지 않음
- SHARED: 읽기 잠금만 걸고 스키마 변경을 실행하기 때문에 스키마 변경 중 읽기만 가능(쓰기 x)
- EXCLUSIVE: 쓰기 잠금을 걸고 스키마 변경을 실행하기 때문에 테이블의 읽고 쓰기가 불가능함

알고리즘으로 INPLACE가 사용되는 경우 대부분 잠금은 NONE으로 설정 가능하지만, SHARED 수준까지 설정이 필요한 경우가 있습니다.
> 참고로 EXCLUSIVE는 예전 MySQL 서버의 전통적인 alter table과 동일하기 때문에 lock을 명시할 필요는 없습니다.


INPLACE 알고리즘을 사용하면 내부적으로는 테이블의 리빌드가 필요할 수 있다고 이야기 했는데 대표적으로 테이블의 프라이머리키를 추가하는 작업은 데이터 파일에서 레코드의 저장 위치가 바뀌는 작업이기 때문에 리빌드가 필요합니다. 

다만 단순한 컬럼의 이름만 변경하는 경우 INPLACE 알고리즘을 사용해야 하지만 실제 테이블의 리빌드 작업은 발생하지 않습니다.

여기서 프라이머리키를 추가하는 경우와 같이 테이블 리빌드가 필요한 상황을 MySQL 서버 메뉴얼에서는 Data Reorganizing 혹은 Table Rebuild라고 부릅니다.

결론적으로  INPLACE 알고리즘을 사용하는 경우 다음과 같이 구별할 수 있습니다.
- 데이터 재구성이 필요한 경우: 잠금을 필요로 하지 않기 때문에 읽고 쓰기는 가능하지만 여전히 테이블의 레코드 건수에 따라 상당히 많은 시간이 소요
- 데이터 재구성이 필요하지 않은 경우: INPLACE 알고리즘을 사용하지만 INSTANT 알고리즘과 비슷하게 매우 빨리 작업이 완료될 수 있습니다.


### 온라인 처리 가능한 스키마 변경

MySQL 서버의 모든 스키마 변경 작업이 온라인으로 가능한 것이 아니기 때문에 필요한 스키마 변경 작업의 형태가 온라인으로 처리될 수 있는지, 아니면 테이블의 읽고 쓰기가 대기하게 되는지 확인한 후 실행하는 것이 좋습니다. 


**실제 사용가능한 사항에 대해서는 MySQL 메뉴얼을 참고하는 것이 좋습니다.**

MySQL 서버에서 사용할 수 있는 스키마 변경 작업은 매우 다양하기 때문에 모든 명령이 온라인 DDL을 지원하는지 아닌지는 기억하는 것이 쉽지 않습니다. 
이런 이유로 ALTER TABLE 명령에 LOCK과 ALOGORITHM 절을 명시해서 온라인 스키마 변경의 처리 알고리즘을 강제할 수 있습니다. 물론 명시하는 것으로 실행을 강제할 수 있는 것은 아니지만 온라인 DDL에서 처리할 수 없다면 MySQL에서는 에러르 뱉기 때문에 확인하는 용도로 적절할 수 있습니다.

```
mysql> ALTER TABLE employees DROP PRIMARY KEY, ALGORITHM=INSTANT;

ERROR 1846 (0A000): ALGORITHM=INSTANT is not supported. Reason: Dropping a primary key is not allowed without also adding a new primary key. Try ALGORITHM=COPY/INPLACE.

mysql> ALTER TABLE employees DROP PRIMARY KEY, ALGORITHM=INPLACE, LOCK=NONE;

ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. Reason: Dropping a primary key is not allowed without also adding a new primary key. Try ALGORITHM=COPY.

mysql> ALTER TABLE employees DROP PRIMARY KEY, ALGORITHM=COPY, LOCK=SHARED;

Query OK, 300024 rows affected (6.24 sec)Records: 300024  Duplicates: 0  Warnings: 0

mysql> ALTER TABLE employees ADD PRIMARY KEY (emp_no), ALGORITHM=INPLACE, LOCK=NONE;

Query OK, 0 rows affected (1.48 sec)Records: 0  Duplicates: 0  Warnings: 0
```
위 쿼리에서는 다음 순서로 ALGORITHM과 LOCK 옵션을 시도해보면서 해당 알고리즘이 지원되는지 여부를 판단합니다. 

1. ALGORITH=INSTANT 옵션으로 스키마 변경을 시도
2. 실패하면 ALGORITHM=INPLACE, LOCK=NONE 옵션으로 스키마 변경을 시도
3. 실패하면 ALGORITHM=INPLACE, LOCK=SHARED 옵션으로 스키마 변경을 시도
4. 실패하면 ALGORITHM=COPY, LOCK=SHARED 옵션으로 스키마 변경을 시도
5. 실패하면 ALGORITHM=COPY, LOCK=EXCLUSIVE 옵션으로 스키마 변경을 시도

실행하고자 하는 스키마 변경 작업으로 인해 DML이 멈춰서는 안 된다면 1번 과 2번까지만 하는 것을 추천합니다.

만약 1,2번 옵션으로 스키마 변경이 되지 않는다면 서비스를 멈추고 DML을 멈춘 다음 스키마 변경을 해야 합니다.

실행하고자 하는 스키마 변경이 1,2번 옵션으로 가능한 작업이라면 MySQL 서버는 스키마 변경을 실행하게 되지만 온라인 DDL이라 하더라도 MySQL 서버에 부하를 유발할 수 있으며 커넥션의 쿼리들이 느려질 수 있습니다. 

그렇기 때문에 스키마 변경 작업이 직접 다른 커넥션의 DML을 대기하게 만들지는 않더라도 주의해서 사용해야 합니다.


### INPLACE 알고리즘
INPLACE 알고리즘은 임시 테이블로 레코드를 복사하지 않더라도 내부적으로 테이블의 모든 레코드를 리빌드해야 하는 경우가 많습니다. 

이 때 MySQL서버는 다음과 같은 과정을 거칩니다.

------
1. INPLACE 스키마 변경이 지원되는 스토리지 엔진의 테이블인지 확인
2. INPLACE 스키마 변경 준비
	- 스키마 변경에 대한 정보를 준비해서 온라인 DDL 작업 동안 변경되는 데이터를 추적할 준비
3. 테이블의 스키마 변경 및 새로운 DML 로깅
	- 실제 스키마 변경을 수행하는 과정으로, 작업이 수행되는 동안 다른 커넥션의 DML 작업이 대기하지 않습니다 이렇게 스키마를 온라인으로 변경함과 동시에 다른 스레드에서는 사용자에 의해서 발생한 DML들에 대해서 별도의 로그를 기록
4. 로그 적용
	- 온라인 DDL작업 동안 수집된 DML로그를 테이블에 적용
5. INPLACE 스키마 변경 완료 

INPLACE 알고리즘으로 스키마가 변경된다고 하더라도 2번과 4번 단계에서는 잠깐의 베타적 잠금이 필요하며, 이 시점에는 다른 커넥션의 DML이 잠깐 대기합니다. 하지만 실제로 많은 시간이 필요한 3번 단계는 다른 커넥션의 DML 작업이 대기 없이 즉시 처리됩니다. 

그리고 INPLACE 알고리즘으로 온라인 스키마 변경이 진행되는 동안 새로 유입된 DML 쿠ㅏ리들에 의해 변경되는 데이터를 온라인 변경 로그라는 메모리 공간에 쌓아 두었다가 온라인 스키마 변경이 완료되면 로그의 내용을 실제 테이블로 일괄 적용합니다.
여기서 온라인 변경 로그는 디스크가 아닌 메모리에만 생성되며, 메모리 공간의 크기는 `innodb_online_alter_log_max_size` 시스템 변수에 의해 결정됩니다. 

### 온라인 DDL의 실패 케이스 
온라인 DDL 명령은 여러가지 이유로 실패할 수 있습니다. 일단 온라인 DDL이 INSTANT 알고리즘을 사용하는 경우 거의 시작과 동시에 작업이 완료되기 때문에 작업 도중 실패할 가능성은 없습니다.

하지만 INPLACE 알고리즘으로 실행되는 경우 내부적으로 테이블 리빌드 과정이 필요하고 최종 로그 적용 과정이 필요해서 중간 과정에서 실패할 가능성이 상대적으로 높은 편입니다. 

INPLACE 알고리즘을 몇 시간 동안 실행되던 온라인 DDL이 실패하면 이는 상당한 자원과 시간 낭비가 됩니다.

1. ALTER TABlE 명령이 장시간 실행되고 다른 커넥션에서 DML이 많이 실행되는 경우이거나 온라인 변경 로그의 공간이 부족한 경우 온라인 스키마 변경 작업 실패

2. ALTER TABLE 명령이  실행되는 동안 ALTER TABLE 이전 버전의 테이블 구조에서는 아무런 문제가 없지만 ALTER TABLE 이후의 테이블 구조에는 적합하지 않은 레코드가 INSERT 되거나 UPDATE 됐다면 온라인 스키마 변경 작업은 마지막 과정에서 실패

3. 스키마 변경을 위해서 필요한 잠금 수준보다 낮은 잠금 옵션이 사용된 경우
4. 온라인 스키마 변경은 LOCK=NONE 으로 실행된다고 하더라도 변경 작업의 처음과 마지막 과정에서 잠금이 필요한데, 이 잠금을 회득하지 못하고 타임 아웃이 발생하면 실패

5. 온라인으로 인덱스를 생성하는 작업의 경우 정렬을 위해 tmpdir 시스템 변수에 설정된 디스크의 임시 디렉터리를 사용하는데, 이 공간이 부족한 경우 또한 온라인 스키마 변경은 실패함

### 온라인 DDL 진행 상황 모니터링
온라인 DDL 을 포함한 모든 ALTER TABLE 명령은 MySQL 서버의 performance_schema를 통해 진행 상황을 모니터링할 수 있습니다. 

온라인 DDL을 모니터링하려면 performance_schema 옵션이 ON으로 활성화돼야 합니다.

![[Pasted image 20240304152548.png]]
![[Pasted image 20240304152556.png]]

스키마 변경 작업의 진행 상황은 performance_schema.events_stages_current 테이블을 통해 확인할 수 있는데, 실행 중인 스키마 변경 종류에 따라 기록되는 내용이 상이합니다.

아래는 온라인 DDL이 아닌 전통적인 copy 알고리즘으로 스키마 변경이 진행되는 경우입니다.
![[Pasted image 20240304152734.png]]

스키마 변경 작업이 온라인 DDL로 실행되는 경우 다양한 상태를 보여주는데, 이는 온라인 ddl이 단계별로 event_name 컬럼의 값을 다르게 보여주기 때문입니다.

![[Pasted image 20240304152817.png]]
![[Pasted image 20240304152829.png]]

WORK_ESTIMATED와 WORK_COMPLETED 컬럼의 값을 비교해보면 ALTER TABLE의 진행상왕을 예측할 수 있지만 WORKESTIMATED 컬럼의 값은 예측치이기 때문에 ALTER TABLE이 진행되면서 조금씩 변경됩니다. 



# 데이터베이스 변경

MySQl에서 하나의 인스턴스는 1개 이상의 데이터베이스를 가질 수 있습니다. 
다른 RDBMS에서는 스키마와 데이터베이스를 구분해서 관리하지만 MySQL 서버에서는 스키마와 데이터베이스는 동격의 개념입니다. 

그래서 MySQL 서버에서는 굳이 스키마를 명시적으로 사용하지 않습니다. 
MySQL의 데이터베이스는 디스크의 물리적인 저장소를 구분하기도 하지만 여러 데이터베이스의 테이블을 묶어서 조인 쿼리를 사용할 수도 있기 때문에 단순히 논리적인 개념이기도 합니다. 

물론 데이터베이스는 개체에 대한 권한을 구분하는 용도로 사용되기도 하지만 큰 의미는 가지지 않습니다. 

그래서 데이터베이스 단위로 변경하거나 설정하는 DDL 명령은 그다지 많지 않습니다. 


## 데이터베이스 생성
![[Pasted image 20240304154651.png]]

## 테이터베이스 목록 조회
![[Pasted image 20240304154703.png]]

추가

# 테이블 스페이스 변경

MySQL 서버에는 전통적으로 테이블별로 전용의 테이블스페이스를 사용했습니다.  InnoDB 엔진의 시스템 테이블 스페이스만 제너럴 테이블스페이스를 사용했습니다.
> 제너럴 테이블스페이스
> 여러 테이블의 데이터를 한꺼번에 저장하는 테이블스페이스


MySQL 8.0 버전이 되면서 MySQL 서버에서도 사용자 테이블을 제너럴 테이블스페이스로 저장하는 기능이 추가되고 테이블스페이스를 관리하는 DDL 명령들이 추가 됐습니다.

그러나 MySQL 8.0 에서도 제너럴 테이블스페이스는 여러 가지 제약사항을 가집니다.

1. 파티션 테이블은 제너럴 테이블스페이스를 사용하지 못함
2. 복제 소스와 레플리카 서버가 동일 호스트에서 실행되는 경우 add datafile 문장 사용불가
3. 테이블 암호화는 테이블스페이스 단위로 설정
4. 테이블 압축 가능 여부는 테이블스페이스의 블록 사이즈와 innoDB 페이지 사이즈에 의해 결정
5. 특정 테이블을 삭제해도 디스크 공간이 운영체제로 반납되지 않음

그럼에도 불구하고,MySQL 8.0에서 사용자 테이블이 제너럴 테이블스페이스를 이용할 수 있개 개선된 것은 다음과 같은 장점이 있습니다.
1. 제너럴 테이블스페이스를 사용하면 파일 핸들러를 최소화합니다.
2. 테이블스페이스 관리에 필요한 메모리 공간을 최소화합니다.

제너럴 테이블스페이스가 가진 2가지 장점은 사실 테이블의 개수가 많은 경우에 유용합니다.

아직 일반적인 환경에서 제너럴 테이블스페이스의 장점은 취하기가 여렵습니다.

MySQL 서버에서 테이블이 개별 테이블스페이스를 사용할지 아니면 제너럴 테이블스페이스를 사용할지는 innodb_file_per_table 시스템 변수로 제어할 수 있습니다.


MySQL 8.0에서는 innnodb_file_per_table 시스템 변수의 기본값이 ON이므로 테이블은 자동으로 개별 테이블스페이스를 사용합니다.

데이터베이스에 작은 테이블이 매우 많이 필요한 응용 프로그램을 개발 중이라면 제너럴 테이블스페이스에 대한 메뉴얼을 참고하는 것을 권장합니다.


# 테이블 변경

테이블은 사용자의 데이터를 가지는 주체로서, MySQL 서버의 많은 옵션과 인덱스 등의 기능이 테이블에 종속되어 사용됩니다.

## 테이블 생성

아래는 테이블을 생성하는 create table 문장입니다.
![[Pasted image 20240304160127.png]]


TEMPORARY 키워드
- 해당 키워드를 사용하면 데이터베이스 커넥션(세션) 에서만 사용 가능한 임시 테이블을 생성합니다.
- 같은 이름의 테이블이 있으면 에러가 발생합니다.
- `IF NOT EXISTS` 옵션을 사용하면 오류없이 사용할 수 있습니다.
- MySQL 테이블을 정의한 스크립트 마지막 테이블이 사용할 스토리지 엔진을 결정하기 위해 ENGINE 이라는 키워드를 사용할 수 있습니다.

개별 컬럼
- 각 컬럼은 아래의 패턴으로 구현됩니다.
> 컬럼명 + 컬럼타입 + [타입별 옵션] + [NULL 여부] + [기본값]
- 모든 컬럼은 공통적으로 커럶의 초깃값을 설정하는 DEFAULT 절과 컬럼이 NULL을 가질 수 있는지 여부를 설정하기 위해 NULL 또는 NOT NULL 제약을 명시할 수 있습니다.
- 문자열 타입은 타입 뒤에 반드시 컬럼에 최대한 저장할 수 있는 문자수를 명시해야 합니다. 
- 숫자 타입은 선택적으로 길이를 가질 수 있지만 이는 저장될 값의 길이를 의미하는 것이 아닌 단순히 값을 표시할 떄 보여줄 길이를 지정하는 것입니다.
	- UNSIGNED 키워드를 사용하여 양수, 음수, 모두 저장하는 것이 가능합니다.
- MySQL 5.5 버전까지는 DATE나 DATETIME 타입은 기본 값을 명시할 수 없지만 MySQL 5.6버전부터는 DATE, DATETIME 타입 그리고 TIMESTAMP 타입 보두 값이 자동으로 현재 시간으로 업데이트되도록 기본값을 설정할 수 있습니다.


### 테이블 구조 조회
MySQL에서 테이블의 구조를 확인하는 방법은 `SHOW CRAETE TABLE` 명령과 DESC 명령 두 가지가 있습니다.

SHOW CREATE TABLE 명령을 사용하면 테이블의 CREATE TABLE 문장을 표시해줍니다.
하지만 SHOW CREATE TABLE 명령의 결과가 최초 테이블을 생성할 때 사용자가 실행한 내용을 보여주는 것은 아닙니다.

이는 MySQL 서버가 테이블의 메타 정보를 읽어서 이를 create table 명령으로 재작성해서 보여주는 것이며 특별한 수정 없이 바로 사용할 수 있는 create table 명령을 만들어 주기 떄문에 상당히 유용합니다.


![[Pasted image 20240304161535.png]]
SHOW CREATE TABLE 명령은 칼럼의 목록과 인덱스, 외래키 정보를 동시에 보여주기 때문에 SQL을 튜닝하거나 테이블의 구조를 확인할 때 주로 사용합니다.

DESC 명령은 테이블의 칼람 정보를 보기 편한 표 형태로 표시해줍니다. 다만 인덱스 커럶의 순서나 외래키, 테이블 자체의 속성을 보여주지는 않기 때문에 테이블의 전체적인 구조를 한 번에 확인하기는 어렵습니다.

### 테이블의 구조 변경

테이블의 구조를 변경하려면 alter table 명령을 사용합니다.
alter table 명령은 테이블 자체의 속성을 변경할 수 있을뿐만 아니라 인덱스의 추가 삭제나 컬럼을 추가/삭제하는 용도로도 사용됩니다.

ALTER TABLE 명령은 테이블 자체 옵션과 컬럼, 인덱스 등 거의 대부분의 스키마를 변경하는 작업에 사용합니다.


테이블 자체에 대한 속성 변경은 주로 테이블의 문자 집합이나 스토리지 엔진, 파티션 구조 등의 변경에서 발생합니다.

![[Pasted image 20240304161912.png]]
위 예제의 첫 번째 alter table은 테이블의 기본 문자 집합과 콜레이션을 변경하는 명령입니다. 

그뿐만 아니라 테이블의 모든 컬럼과 기존 데이터까지 모두 UTF8MB4 문자 셋의 콜레이션까지 UTF8MB4_GENRAL_CI로 변경합니다. 

두 번째 쿼리는 테이블의 스토리지 엔진을 변경하는 명령입니다. 내부적인 테이블의 저장소를 변경하는 것이라서 항상 테이블의 모든 레코드를 복사하는 작업이 필요합니다.

참고로 alter table 문장에 명시된 engine이 기존과 동일하더라도 테이블의 데이터를 복사하는 작업은 실행되기 때문에 주의해야 합니다. 

실제 테이블의 스토리지 엔진을 변경하는 목적으로도 사용하지만 테이블 데이터를 리빌드하는 목적으로도 사용합니다. 

여기서 테이블 리블드 작업은 주로 레코드의 삭제가 자주 발생하는 테이블에서 데이터가 저장되지 않은 빈 공간(프래그멘테이션, Fragmentation)을 제거해 디스크 사용 공간을 줄이는 역할을 합니다.


### 테이블 명 변경
MySQl 서버에서 테이블명을 변경하려면 `RENAME TABlE` 명령어를 사용하면 됩니다.
![[Pasted image 20240304162642.png]]
리눅스의 MV 명령어 처럼 다른 데이터베이스로 옮기는 것 또한 가능합니다.

첫 번째 명령과 같이 동일 데이터베이스 내에서는 테이블의 이름만 변경하는 작업은 단순히 메타 정보만 변경하기 때문에 매우 빠르게 처리됩니다. 

하지만 두 번째 명령어와 같이 데이터베이스를 변경하는 경우에는 메타 정보뿐만 아니라 테이블이 저장된 파일까지 다른 디렉터리로 이동해야 합니다.

여기서 db1과 db2 데이터베이스가 서로 다른 파티션에 만들어졌다고 가정해보겠습니다. 

일반적으로 유닉스나 윈도우에서 서로 다른 파티션으로 파일을 이동할 때는 데이터 파일을 먼저 복사하고 복사를 완료하면 원본 파티션의 파일을 삭재하는 형태로 처리하는데 RENAME TABLE에서도 똑같이 작동합니다.


`RENAME TABLE`를 이용해 테이블을 db1에서 db2로 이동할 때 db1과 db2가 서로 다른 운영체제의 파일 시스템을 사용하고 있었다면 이 RENAME TABLE 명령은 데이터 파일의 복사 작업이 필요하기 때문에 데이터 파일의 크기에 비례해서 시간이 소요됩니다.

때로는 일정 주기로 테이블을 교체(SWAP) 해야 하는 경우도 있습니다.

> 상황 가정
> 
> BATCH 라는 테이블이 사용 중
> BATCH_NEW 라는 테이블을 생성하고 새로운 데이터를 저장하고자 함
> 최종적으로 응용 프로그램에서 사용할 수 있게 batch_new 테이블을 batch라는 이름으로 변경하는 방식으로 작성

![[Pasted image 20240304163141.png]]

여기서 문제가 발생할 수 있는데

배치 프로그램이 작성되면 마지막의 기존 테이블과 신규 테이블을 교체하는 동안 일시적으로 batch 테이블이 없어지는 시점이 발생합니다. 

2개의 `RENAME TABLE` 얼마나 간격을 두고 실행되느냐에 따라 시간은 더 길어질 수 있으며 이 시점 동안 응용 프로그램은 batch 테이블을 찾지 못해서 에러를 발생시키게 됩니다. 

결국 이분제를 막기 위해서 MySQL 서버의 RENAME TABLE 명령은 다음과 같이 여러 테이블의 RENAMe 명령을 하나의 문장으로 묶어서 실행할 수 있습니다. 


![[Pasted image 20240304163343.png]]
이렇게 여러 테이블의 RENAME 명령을 하나의 문장으로 묶으면 MySQl 서버는 RENAME TABLE 명령에 명시된 모든 테이블에 대해 잠금을 걸고 테이블의 이름 변경 작업을 실행하게 됩니다.

응용 프로그램이 입장에서 보면 batch 테이블을 조회하려고 할 때 이미 잠금이 걸려있기 때문에 대기합니다. 

그리고 rename table 명령이 완료되면 batch 테이블의 잠금이 해제되어 batch 테이블의 읽기를 실행하며 쿼리가 시작될 때와 실제 쿼리를 실행할 때의 대상 테이블이 변경됐지만 응용 프로그램은 이를 알아차리지 못하고 투명하게 실행된다. 

잠깐의 잠금 대기가 발생할 뿐 에러가 발생하지는 않는다.

### 테이블의 상태 조회
MySQL 모든 테이블은 만들어진 시간, 대략의 레코드 건수, 데이터 파일의 크기 등의 정보를 가지고 있습니다. 

또한 데이터 파일의 버전이나 레코드 포맷 등과 같이 자주 사용되는 않지만 중요한 정보도 가지고 있는데, 이러한 정보를 조회할 수 있는 명령이 `SHOW TABLE STATUS` 입니다.

SHOW TABLE STATUS 명령은 LIKE 패턴과 같은 조건을 사용해 특정 테이블의 상태만 조회하는 것이 가능합니다.

![[Pasted image 20240304163701.png]]

show table status 명령뿐 아니라 select 쿼리를 이용해서 조회할 수 있습니다.

![[Pasted image 20240304163738.png]]



### 테이블 구조 복사 
테이블의 구조는 같지만 이름만 다른 테이블을 생성할 때는 show create table 명령을이용해 테이블의 생성 ddl을 조회한 후에 조금 변경해서 만들 수 있습니다. 

또한 `CREATE TABLE .... AS SELECT ... LIMIT 0` 명령으로 테이블을 생성할 수 있습니다. 하지만 show create table 명령을 이용하면 내용을 조금 변경해야할 수 있으며 인덱스를 생성하지 않는다는 단점이 있습니다. 

데이터는 복사하지 않고 테이블의 구조만 동일하게 복사하는 명령으로 create table ...like를 사용하면 구조가 같은 테이블을 손쉽게 생성할 수 있습니다. 

위의 명령은 employees 테이블에 존재하는 컬럼과 인덱스가 같은 temp_employees 라는 테이블을 생성하는 예제입니다. 

create table ... as select ...와 마찬가지로 데이터까지 복사하려면 create table like 명령을 실행하고 다음과 같은 insert ...select 명령을 실행하면 됩니다. 

### 테이블 삭제

일반적으로 MySQl에서 레코드가 많지 않은 테이블을 삭제하는 작업은 서비스 도중이라고 하더라도 문제가 되지 않습니다. MySQL 8.0 버전에서는 특정 테이블을 삭제하는 작업이 다른 테이블의 DML이나 쿼리를 직접 방해하지는 않습니다. MySQL 서버에서 테이블 삭제는 DROP TABLE 명령으로 실행합니다. 

하지만 용량이 매우 큰 테이블을 삭제하는 작업은 상당히 부하가 큰 작업인데 테이블이 삭제되면  MySQL 서버는 해당 테이블이 사용하던 데이터 파이를 삭제해야 하는데 이 파일의 크기가 매우크고 디스크에서 파일의 조각들이 너무 분산되어 저장돼 있다면 많은 디스크 읽기 쓰기를 반복하낟.

즉 MySQL 서버의 디스크 읽고 쓰기 부하가 높아지면 다른 커넥션의 커리 처리성능이 떨어지는 것을 의미합니다.

그래서 테이블이 크다면 서비스 도중에 삭제 작업은 수행하지 않는 것이 좋습니다. 

테이블 삭제에서 한 가지 더 주의해야 하는 것은 InnoDB 스토리지 엔진의 어댑티브 해시 인덱스입니다. 

어댑티브 해시 인덱스는 INnnoDB 버퍼 풀의 각 페이지가 가진 레코드에 대한 해시 인덱스 기능을 제공하는데, 어댑티브 해시 인덱스가 활성화돼 있는 경우 테이블이 삭제되면 어댑티브 해시 인덱스 정보도 모두 삭제해야합니다. 

어댑티브 해시 인덱스가 삭제될 때 테이블에 대한 정보를 많이 가지고 있다면 어댑티브 해시 인덱스 삭제 작ㄷ업으로 인해 MySQL 서버의 부하가 높아지고 간접적으로 다른 쿼리 처리에 영향을 미칠 수 있습니다.


# 컬럼 변경

테이블의 구조 변경 작업은 대부분 칼럼을 추가하거나 칼럼 타입을 변경하는 작업입니다

## 컬럼 추가 
MySQL 8.0 버전으로 업그레이드되면서 테이블의 컬럼 추가 작업은 대부분 INPLACE 알고리즘을 사용하는 온라인 DDL로 처리가 가능합니다. 그 뿐만 아니라 컬럼을 테이블의 제일 마지막 컬럼으로 추가하는 경우 INSTANT 알고리즘으로 즉시 추가됩니다.

![[Pasted image 20240304165711.png]]


위 예제의 첫 번째 DDL 문장은 테이블의 마지막에 새로운 컬럼을 추가하므로 INSTANT 알고리즘으로 즉시 추가가 가능합니다. 

하지만 두 번째 쿼리는 테이블의 기존 컬럼 중간에 새로 추가하기 때문에 테이블의 리빌드가 필요합니다. 

그래서 INSTANT 알고리즘으로 처리기 불가능하며, INPACE 알고리즘으로 처리돼야 합니다.

그래서 테이블이 큰 경우라면 가능하다면 컬럼을 테이블의 마지막 컬럼으로 추가하는 것이 좋습니다.

### 컬럼 삭제

컬럼을 삭제하는 작업은 항상 테이블의 리빌드를 필요로 하기 때문에 ISNTANT 알고리즘을 사용할 수 없습니다. 
그래서 항상 INPLACE 알고리즘으로 컬럼 삭제 가능합니다. 

![[Pasted image 20240304171129.png]]


### 커럼 이름 및 타입 변경

![[Pasted image 20240304171151.png]]![[Pasted image 20240304171159.png]]

1. 첫 번째 DDL은 salaries 테이블의 to_date 컬럼의 이름만 end_date로 변경했으며 INSTANT 알고리즘으로 동작합니다.
2. 두 번째 DDL은 INT타입의 컬럼을 varchar 타입으로 변경합니다. 컬럼의 데이터 타입이 변경되는 경우 copy 알고리즘이 필요하며 온라인 ddl로 실행돼도 스키마 변경 도중에는 테이블의 쓰기 작업은 불가능합니다. 
3. 세 번째 DDL은 varchar 타입의 길이를 16에서 30으로 변경합니다. varchar 타입의 길이를 확장하는 경우는 현재 길이와 확장하는 길이의 관계에 따라 테이블의 리빌드가 필요할 수도 있고 아닐 수 있습니다. 
4. 네 번째 DDL은 varchar 타입의 길이를 16에서 10으로 변경하는 예제입니다. varchar 타입의 길이를 축소하는 경우는 완전히 다른 타입으로 변경되는 경우와 같이 copy 알고리즘을 사용하며 스키마를 변경하는 중 해당 테이블의 데이터 변경은 허용되지 않기 때문에 LOCk은 shared로 사용합니다.

추가
# 인덱스 변경

MMySQL 8.0 버전에서는 대부분의 인덱스 변경 작어빙 온라인 ddl로 처리 가능하도록 개선됐습니다.

## 인덱스 추가 
MySQl 서버에서 사용 가능한 인덱스의 종류나 인덱싱 알고리즘별로 대략 사용 가능한 alter table add index 문장의 형태를 나열했습니다. 

![[Pasted image 20240304171647.png]]

(추가)

## 테이블 변경 묶음 실행

하나의 테이블에 대해 여러 가지 스키마를 변경하는 경우 ALTER TABLE 명령으로 차례대로 실행할 때가 있습니다. 온라인 DDL로 빠르게 스키마 변경을 처리할 수 있다면 개별로 실행하는 것이 좋지만 그렇지 않다면 모아서 실행하는 것이 효율적입니다. 

![[Pasted image 20240305132914.png]]

2개의 alter table 명령어로 인덱스를 각각 생성하면 인덱스를 생성할 때마다 테이블의 레코드를 스캔해서 인덱스를 생성합니다. 하지만 하나의 alter table 명령으로 모아서 실행하면 MySQL 서버는 테이블 레코드를 한 번만 풀 스캔해서 2개의 인덱스를 한꺼번에 생성할 수 있습니다.
![[Pasted image 20240305133027.png]]

2개의 인덱스를 한 번에 생성하면 인덱스 하나를 생성할 때보다 더 많은 시간일 걸리지만 2개의 인덱스를 각각 생성하는 데 걸리는 시간보다는 훨씬 시간을 단축할 수 있습니다.

단 서로 다른 알고리즘을 사용하는 경우라면 굳이 모아서 실행할 필요는 없습니다.

# 프로세스 조회 및 강제 종료

MySQL 서버에 접속된 사용자의 목록이나 각 클라이언트 사용자가 현재 어떤 쿼리를 실행하고 있는지는 SHOW PROCESSLIST 명령으로 확인할 수 있습니다.

SHOW PROCESSLIST 명령의 결과에는 현재 MySQL 서버에 접속된 클라이언트의 요청을 처리하는 스레드 수만큼의 레코드가 표시됩니다.

- ID : MySQQL 서버의 스레드 아이디, 쿼리나 커넥션을 강제 종료할 때는 컬럼값을 식별자로 사용
- User: 클라이언트가 MySQL 서버에 접속할 떄 인증에 사용한 계정
- Host: 클라이언트의 호스트명이나 IP주소
- DB: 클라이언트가 기본으로 사용하는 데이터베이스의 이름
- Command: 해당 스레드가 현재 어떤 작업을 처리하고 있는지 표시
- Time: Command 컬럼에 표시되는 작업이 얼마나 실행되고 있는지 표시
- State: Command 컬럼에 표시되는 내용이 해당 스레드가 처리하고 있는 작업의 큰 분류를 보여준다면 State 컬럼에는 소분류 작업 내용을 보여줌
- Info: 해당 스레드가 실행중인 쿼리 문장을 보여줌. 쿼리는 화면의 크기에 맞춰서 표시 가능한 부분까지만 표시
	- 전체를 보기 원한다면 SHOW FULL PROCESSLIST명령을 활용

SWHO PROCESSLIST 명령의 결과에서 ID 컬럼값은 접속된 커넥션의 요청을 처리하는 전용 스레드 번호인데 해당 스레드 id를 kill 하게 되면 실행 중인 쿼리나 커넥션 자체를 강제 종료할 수 있습니다. 



# 활성 트랜잭션 조회
쿼리가 오랜 시간 실행되고 있는 경우도 문제지만 트랜잭션이 오랜 시간 완료되지 않고 활성 상태로 남아있는 것도 MySQL 서버의 성능에 영향을 미칠 수 있습니다. 

MySQL 서버의 트랜잭션 목록은 information_schema.innodb_trx 테이블을 통해 확인할 수 있습니다.



# 쿼리 성능 테스트


## 쿼리의 성능에 영향을 미치는 요소

### 운영체제의 캐시
MySQL 서버는 운영체제의 파일 시스템 관련 기능(시스템 콜)을 이용해 데이터 파일을 읽어옵니다. 

일반적으로 운영체제는 한 번 읽은 데이터는 운영체제가 관리하는 별도의 캐시 영역에 보관해 뒀다가 해당 데이터가 요청되면 디스크를 읽지 않고 캐시의 내용을 바로 MySQL 서버로 반환합니다.

InnoDB 스토리지 엔진은 파일 시스템의 캐시나 버퍼를 거치지 않는 Direct/IO를 사용하므로 운영체제의 캐시가 큰 영향을 미치지 않지만 MyISAM 스토리지 엔진은 운영체제의 캐시에 대한 의존도가 높기 때문에 운영체제의 캐시에 따라 성능 차이가 큰 편입니다. 

운영체제가 관리하는 캐시나 버퍼는 공용 공간이기 떄문에 MySQL 서버와 같은 응용프로그램이 종료된다고 해도 여전히 남아있을 수 있습니다. 그래서 운영체제가 가지고 있는 캐시나 버퍼가 전혀 없는 상태에서 쿼리의 성능을 테스트 하려면 운영체제의 캐시 삭제 명령을 실행하고 테스트하는 것이 좋습니다.

![[Pasted image 20240305135953.png]]


### MySQL 서버의 버퍼 풀

운영체제의 버퍼나 캐시와 마찬가지로 MySQL 서버에서도 데이터 파일의 내용을 페이지(블록) 단위로 캐시하는 기능을 제공합니다. 

InnoDB 스토리지 엔진이 관리하는 캐시를 버퍼풀이라고 합니다.
여기서 InnoDB의 버퍼 풀은 인덱스 페이지는 물론이고 데이터 페이지까지 캐시하며, 쓰기 작업을 버퍼링 작업까지 겸해서 처리합니다.

InnoDB 버퍼 풀은 MySQL 서버가 종료될 때 자동으로 덤프됐다가 다시 시작될 때 자동으로 적재되는데 
innodb_buffer_pool_load_at_startup 시스템 변수를 off로 설정한 후 재시작 해야 합니다.

MySQL 서버가 종료될 때 버퍼 풀의 내용을 덤프하지 않고자 한다면 innodb_buffer_poll_dump_at_shutdown 시스템 변수도 off로 변경하면됩니다.


### 독립된 MySQL 서버
MySQL 서버가 기동 중인 장비에 웹 서버나 다른 배치용 프로그램이 실행되고 있다면 테스트하려는 쿼리의 성능이 영향을 받습니다. 

또한 테스트 쿼리를 실행하는 클라이언트 프로그램이나 네트워크의 영향 요소도 고려해야 합니다. 


### 쿼리 테스트 횟수

실제 쿼리의 성능 테스트를 MySQL 서버의 상태가 워밍업된 상태에서 진행할지 아니면 콜드 상태에서 진행할지 고려해야 합니다.

일반적으로 쿼리의 성능 테스트는 콜드 상태가 아닌 워밍업된 상태를 가정하고 테스트 합니다. 

그렇기에 어느 정도 사용량이 있는 서비스라면 콜드 상태에서 워밍업 상태로 전환하는데 그다지 오래 걸리지 않기 때문에 실제 서비스 환경의 쿼리는 대부분 콜드 상태보다 워밍업 상태에서 실행된다고 볼 수 있습니다. 

