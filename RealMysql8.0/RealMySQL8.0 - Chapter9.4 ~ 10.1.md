---
cssclasses:
  - my_style_width_100
---
# 쿼리 힌트 

> 💡 옵티마이저 힌트가 필요한 이유
> MySQL 서버는 우리가 서비스하는 비즈니스를 100% 이해하지 못합니다. 그렇기에 서비스 개발자나 DBA보다 MySQL 서버가 부족한 실행 계획을 수립할 때가 있는데 이때 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 알려줘야합니다.
> 
> 🗒 결국 힌트는 옵티마이저에게 우리가 원하는 실행 계획의 의도를 명확하게 파악하도록 하기 위함이다.
>  > 어떤 경우에 힌트가 실패할까? (이전에 살펴본 프라이머리키 선호 방식이 있겠다)

MySQL 서버에서 사용 가능한 쿼리 힌트는 2가지가 있습니다.
1. 인덱스 힌트
2. 옵티마이저 힌트


## 인덱스 힌트

> 인덱스 힌트가 뭐지? (책에서 설명이 없는데..?)
> 없어서 공식문서에서 가져옴

Index hints give the optimizer information about how to choose indexes during query processing.

### 🤔 인덱스 힌트의 적용 범위
> index hints apply to [`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html "13.2.13 SELECT Statement") and [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html "13.2.17 UPDATE Statement") statements. They also work with multi-table [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html "13.2.2 DELETE Statement") statements, but not with single-table `DELETE`, as shown later in this section

책에서 인덱스 힌트는 SELECT, UPDATE에서만 사용가능하다고 한다.
하지만 공식문서에서는 다중 테이블 delete에서도 동작 가능하다고 설명한다.
어떤게 맞는지 책을 보면서 찾아보자


### STRAIGHT_JOIN

STRAIGHT_JOIN는 여러 개의 테이블이 조인될 떄 조인 순서를 고정하는 역할을 합니다. 일반적으로 드라이빙 테이블과 드리븐 테이블을 결정하는 것은 옵티마이저의 역할입니다.
테이블의 레코드 수를 기준으로 적은 테이블은 드라이빙 테이블, 반대는 드리븐테이블로 결정됩니다.
![[Pasted image 20240104202650.png]]
참고로 STRAIGHT_JOIN을 사용하기 위한 기준이 있다.
1. 임시 테이블과 일반 테이블의 조인
	- 일반적으로 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋습니다.
	- 만약 일반 테이블에 인덱스가 없는 경우 레코드가 적은 쪽을 선택하는 것이 좋습니다 (이러면 옵티마이저가 해주는 것 아닌가?) 
2. 임시 테이블끼리 조인
	 - 임시테이블은 인덱스가 없기 때문에 어느 테이블을 먼저 드라이빙으로 읽어도 무관하기에 크기가 작은 테이블을 드라이빙 테이블로 선택해주는 것이 좋습니다.
3. 일반 테이블끼리 조인
	- 양쪽 테이블 모두 조인 컬럼에 인덱스가 있거나 양쪽 테이블 모두 조인 컬럼에 인덱스가 없는 경우에는 레코드 건수가 적은 테이블을 드라이빙으로 선택해주는 것이 좋으며, 그 이외에는 조인 컬럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋습니다. 

### USE INDEX / FORCE INDEX / IGNORE INDEX

위 세종류의 인덱스 힌트는 조인의 순서를 변경하는 것 다음으로 자주 사용됩니다. 
사용하는 방법은 인덱스를 가지는 테이블 뒤에 힌트를 명시하는 것입니다.

#### 왜 사용하나요?
대부분의 경우 옵티마이저는 어떤 인덱스를 선택할지 잘 고르지만 3~4개 이상의 컬럼을 포함하는 비슷한 인덱스가 여러개 존재할 때 실수를 한다. 

#### 어떤 종류가 있나요?
1. `USE INDEX`
2. `FORCE INDEX`
3. `IGNORE INDEX`

##### USE INDEX
가장 자주 사용하는 인덱스 힌트입니다. 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 정도입니다.

##### FORCE INDEX
USE INDEX 보다 옵티마이저에게 미치는 영향이 더 큰 인덱스 힌트입니다.
> ⚠ (주의)
> 단 USE INDEX로도 줄 수 없는 경우에는 FORCE INDEX도 적용이 안됩니다.
 
##### IGNORE INDEX
두 인덱스 힌트와 다르게 옵티마이저가 해당 인덱스를 사용할 수 없도록 합니다.


#### 어떤 용도로 사용하나요
위 3종류의 인덱스 힌트 모두 용도를 명시해줄 수 있으며 *선택 사항*인데 특별히 인덱스 힌트에 용도가 명시되지 않으면 주어진 인덱스를 3가지 용도로 사용합니다.
##### USE INDEX FOR JOIN
조인 + 테이블을 검색하는 용도로 사용할 수 있습니다.
##### USE INDEX FOR [ORDER BY | GROUP BY]
명시된 인덱스를 ORDER BY혹은 GROUP BY로 사용할 수 있습니다.

#### 예제
![[Pasted image 20240106001935.png]]

처음 세 쿼리는 정상적으로 인덱스를 사용하는 것을 확인할 수 있습니다.
반면 아래 두 쿼리는 emp_no를 인덱스로 사용하지 않기 때문에 풀 테이블 스캔을 하는데 옵티마이저는 이런 터무니없는 지시를 수행하는 것을 알 수 있습니다.

#### 종합
결론은 위 예제 처럼 힌트를 사용하는 것은 주의해야 합니다. 


> "가장 훌륭한 최적화는 그 쿼리를 서비스에서 없애 버리거나 튜닝할 필요가 없게 데이터를 최소화하는 것"
> -> 검색할 데이터의 크기를 줄이는  것
> ex) 카카오톡 같은 서비스를 예시로 볼 수 있음 채팅 같은 데이터는 크기가 큰데 서버에서 저장하는 데이터의 크기를 3일로 제한 해버리고 나머지 데이터는 로그로 저장하는 방식


### SQL_CALC_FOUND_ROWS

MySQL에서 Limit를 사용하면 limit 건수만큼 찾았다면 검색을 멈춥니다.
하지만 SQL_CALC_FOUND_ROWS 힌트를 사용했을 때 제한된 수만큼 찾더라도 조건에 맞는 모든 레코드를 읽습니다.
보통 `FOUND_ROWS()` 를 통해 직전에 읽은 쿼리의 레코드 수를 가져오는 조합으로 사용하면 온라인 트랜잭션 환경에서 페이지네이션으로 사용할 때 유용하다고 생각할 수 있습니다.

하지만 이는 생각과 다르게 흘러갑니다.

![[Pasted image 20240106031003.png]]

#### SQL_CALC_FOUND_ROWS 사용
먼저 맨 위 두 쿼리를 사용하는 경우 만족하는 레코드의 건수는 253건 중 20건의 레코드를 결과를 가져옵니다. 
하지만 실제 실행의 결과는 조금 다릅니다.
앞서 LIMIT는 제한된 레코드의 건수를 읽은 다음 검색을 멈추지만 위 쿼리는 그렇지 않습니다.

SQL_CALC_FOUND_ROWS를 사용했을 때 인덱스를 타는 쿼리라도 랜덤 io가 limit의 건수만큼 발생하는 것이 아닌 조건에 맞는 모든 쿼리에 대해 발생하기 때문에
불필요한 랜덤 io가 발생합니다. 

#### 기존 2개 쿼리로 쪼개어 실행하는 방법
아래의 첫 번째 쿼리는 커버링 인덱스 쿼리로 실제 데이터를 찾아오기 위한 랜덤 IO가 발생하지 않습니다.
그리고 밑의 쿼리에서는 인덱스를 읽고 20건의 조건에 일치하는 데이터를 찾은 다음 랜덤 IO가 발생하기 때문에 앞서 사용한 쿼리보다 훨씬 효율적으로 동작합니다.

#### 결론
전기적 처리인 메모리나 CPU의 연산 작업에 비해 기계적 처리인 디스크 작업이 얼마나 느린 작업인지를 고려하면 비교할 수 도 없을 만큼 SQL_CALC_FOUND_ROWS를 사용하는 경우가 느리다는 것을 알수 있습니다.
이는 개발의 편의성을 위해 만들어진 것이며 현재 deprecated 됐기 떄문에 사용하는 것은 권장하지 않습니다. 




# 부록

### 2가지 형태의 옵티마이저 힌트
```
/*! */
/*+ */
```
https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html


370p를 보면 `여전히 MySQL 서버는 우리가 서비스하는 비즈니스를 100% 이해하지는 못한다. 그래서 서비스 개발자나 DBA 보다 MySQL 서버가 부족한 실행 계획을 수립할 때가 있을 수 있다` 에서 어떤 상황에서 주로 MySQL 서버의 옵티마이저가 실행 계획 수립 실패예시입니다.

https://medium.com/daangn/mysql-optimizer-error-e438aa02e622



