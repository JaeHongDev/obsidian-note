---
cssclasses:
  - my_style_width_100
---
	# 쿼리 힌트 

> 💡 옵티마이저 힌트가 필요한 이유
> MySQL 서버는 우리가 서비스하는 비즈니스를 100% 이해하지 못합니다. 그렇기에 서비스 개발자나 DBA보다 MySQL 서버가 부족한 실행 계획을 수립할 때가 있는데 이때 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 알려줘야합니다.
> 
> 🗒 결국 힌트는 옵티마이저에게 우리가 원하는 실행 계획의 의도를 명확하게 파악하도록 하기 위함이다.
>  

MySQL 서버에서 사용 가능한 쿼리 힌트는 2가지가 있습니다.
1. 인덱스 힌트
2. 옵티마이저 힌트


## 인덱스 힌트

> 인덱스 힌트가 뭐지? (책에서 설명이 없는데..?)
> 없어서 공식문서에서 가져옴

Index hints give the optimizer information about how to choose indexes during query processing.
인덱스 힌트는 쿼리 처리 중에 옵티마이저에게 어떤 인덱스를 선택해야 하는지에 대한 정보를 제공합니다.

### 🤔 인덱스 힌트의 적용 범위
> index hints apply to [`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html "13.2.13 SELECT Statement") and [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html "13.2.17 UPDATE Statement") statements. They also work with multi-table [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html "13.2.2 DELETE Statement") statements, but not with single-table `DELETE`, as shown later in this section

책에서 인덱스 힌트는 SELECT, UPDATE에서만 사용가능하다고 한다.
하지만 공식문서에서는 다중 테이블 delete에서도 동작 가능하다고 설명한다.
어떤게 맞는지 책을 보면서 찾아보자

### STRAIGHT_JOIN

STRAIGHT_JOIN는 여러 개의 테이블이 조인될 떄 조인 순서를 고정하는 역할을 합니다. 일반적으로 드라이빙 테이블과 드리븐 테이블을 결정하는 것은 옵티마이저의 역할입니다.
테이블의 레코드 수를 기준으로 많은 테이블은 드라이빙 테이블, 반대는 드리븐테이블로 결정됩니다.
![[Pasted image 20240104202650.png]]
참고로 STRAIGHT_JOIN을 사용하기 위한 기준이 있다.
1. 임시 테이블과 일반 테이블의 조인
	- 일반적으로 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋습니다.
	- 만약 일반 테이블에 인덱스가 없는 경우 레코드가 적은 쪽을 선택하는 것이 좋습니다 (이러면 옵티마이저가 해주는 것 아닌가?) 
2. 임시 테이블끼리 조인
	 - 임시테이블은 인덱스가 없기 때문에 어느 테이블을 먼저 드라이빙으로 읽어도 무관하기에 크기가 작은 테이블을 드라이빙 테이블로 선택해주는 것이 좋습니다.
3. 일반 테이블끼리 조인
	- 양쪽 테이블 모두 조인 컬럼에 인덱스가 있거나 양쪽 테이블 모두 조인 컬럼에 인덱스가 없는 경우에는 레코드 건수가 적은 테이블을 드라이빙으로 선택해주는 것이 좋으며, 그 이외에는 조인 컬럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋습니다. 

### USE INDEX / FORCE INDEX / IGNORE INDEX

위 세종류의 인덱스 힌트는 조인의 순서를 변경하는 것 다음으로 자주 사용됩니다. 
사용하는 방법은 인덱스를 가지는 테이블 뒤에 힌트를 명시하는 것입니다.

#### 왜 사용하나요?
대부분의 경우 옵티마이저는 어떤 인덱스를 선택할지 잘 고르지만 3~4개 이상의 컬럼을 포함하는 비슷한 인덱스가 여러개 존재할 때 실수를 한다. 

#### 어떤 종류가 있나요?
1. `USE INDEX`
2. `FORCE INDEX`
3. `IGNORE INDEX`

##### USE INDEX
가장 자주 사용하는 인덱스 힌트입니다. 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 정도입니다.

##### FORCE INDEX
USE INDEX 보다 옵티마이저에게 미치는 영향이 더 큰 인덱스 힌트입니다.
> ⚠ (주의)
> 단 USE INDEX로도 줄 수 없는 경우에는 FORCE INDEX도 적용이 안됩니다.
 
##### IGNORE INDEX
두 인덱스 힌트와 다르게 옵티마이저가 해당 인덱스를 사용할 수 없도록 합니다.


#### 어떤 용도로 사용하나요
위 3종류의 인덱스 힌트 모두 용도를 명시해줄 수 있으며 *선택 사항*인데 특별히 인덱스 힌트에 용도가 명시되지 않으면 주어진 인덱스를 3가지 용도로 사용합니다.
##### USE INDEX FOR JOIN
조인 + 테이블을 검색하는 용도로 사용할 수 있습니다.
##### USE INDEX FOR [ORDER BY | GROUP BY]
명시된 인덱스를 ORDER BY혹은 GROUP BY로 사용할 수 있습니다.

#### 예제
![[Pasted image 20240106001935.png]]

처음 세 쿼리는 정상적으로 인덱스를 사용하는 것을 확인할 수 있습니다.
반면 아래 두 쿼리는 emp_no를 인덱스로 사용하지 않기 때문에 풀 테이블 스캔을 하는데 옵티마이저는 이런 터무니없는 지시를 수행하는 것을 알 수 있습니다.

#### 종합
결론은 위 예제 처럼 힌트를 사용하는 것은 주의해야 합니다. 

힌트를 사용하기 전에 우선적으로 고려해야 할 부분이 있습니다.
- 가장 훌륭한 최적화는 그 쿼리를 서비스에서 없애 버리거나 튜닝할 필요가 없게 데이터를 최소화하는 것
- 데이터 모델의 단순화를 통해 쿼리를 간결하게 만들어 힌트가 필요 없도록 함
- 힌트 사용
/sms -> message 
> "가장 훌륭한 최적화는 그 쿼리를 서비스에서 없애 버리거나 튜닝할 필요가 없게 데이터를 최소화하는 것"
> -> 검색할 데이터의 크기를 줄이는  것
> ex) 카카오톡 같은 서비스를 예시로 볼 수 있음 채팅 같은 데이터는 크기가 큰데 서버에서 저장하는 데이터의 크기를 3일로 제한 해버리고 나머지 데이터는 로그로 저장하는 방식


### SQL_CALC_FOUND_ROWS

MySQL에서 Limit를 사용하면 limit 건수만큼 찾았다면 검색을 멈춥니다.
하지만 SQL_CALC_FOUND_ROWS 힌트를 사용했을 때 제한된 수만큼 찾더라도 조건에 맞는 모든 레코드를 읽습니다.
보통 `FOUND_ROWS()` 를 통해 직전에 읽은 쿼리의 레코드 수를 가져오는 조합으로 사용하면 온라인 트랜잭션 환경에서 페이지네이션으로 사용할 때 유용하다고 생각할 수 있습니다.

하지만 이는 생각과 다르게 흘러갑니다.

![[Pasted image 20240106031003.png]]

#### SQL_CALC_FOUND_ROWS 사용
먼저 맨 위 두 쿼리를 사용하는 경우 만족하는 레코드의 건수는 253건 중 20건의 레코드를 결과를 가져옵니다. 
하지만 실제 실행의 결과는 조금 다릅니다.
앞서 LIMIT는 제한된 레코드의 건수를 읽은 다음 검색을 멈추지만 위 쿼리는 그렇지 않습니다.

SQL_CALC_FOUND_ROWS를 사용했을 때 인덱스를 타는 쿼리라도 랜덤 io가 limit의 건수만큼 발생하는 것이 아닌 조건에 맞는 모든 쿼리에 대해 발생하기 때문에
불필요한 랜덤 io가 발생합니다. 

#### 기존 2개 쿼리로 쪼개어 실행하는 방법
아래의 첫 번째 쿼리는 커버링 인덱스 쿼리로 실제 데이터를 찾아오기 위한 랜덤 IO가 발생하지 않습니다.
그리고 밑의 쿼리에서는 인덱스를 읽고 20건의 조건에 일치하는 데이터를 찾은 다음 랜덤 IO가 발생하기 때문에 앞서 사용한 쿼리보다 훨씬 효율적으로 동작합니다.

#### 결론
전기적 처리인 메모리나 CPU의 연산 작업에 비해 기계적 처리인 디스크 작업이 얼마나 느린 작업인지를 고려하면 비교할 수 도 없을 만큼 SQL_CALC_FOUND_ROWS를 사용하는 경우가 느리다는 것을 알수 있습니다.
이는 개발의 편의성을 위해 만들어진 것이며 현재 deprecated 됐기 떄문에 사용하는 것은 권장하지 않습니다. 


370p를 보면 `여전히 MySQL 서버는 우리가 서비스하는 비즈니스를 100% 이해하지는 못한다. 그래서 서비스 개발자나 DBA 보다 MySQL 서버가 부족한 실행 계획을 수립할 때가 있을 수 있다` 에서 어떤 상황에서 주로 MySQL 서버의 옵티마이저가 실행 계획 수립 실패예시입니다.

https://medium.com/daangn/mysql-optimizer-error-e438aa02e622



# 옵티마이저 힌트

옵티마이저 힌트는 영향 범위에 따라 네 가지로 구분 됩니다.
- 인덱스
- 테이블
- 쿼리 블록 
- 글로벌

> 💡 (쿼리블록)
> 여기서 쿼리블록이란 select 키워드로 시작하는 서브 쿼리 영역을 의미합니다.
> 또한 특정 쿼리블록에 영향을 미치는 옵티마이저 힌트는 쿼리 블록에서 사용하는 것 뿐만 아니라 외부 쿼리 블록에서 사용 가능합니다.
> 이때 쿼리 블록을 명시하기 위해 `QB_NAME` 힌트를 이용해 이름을 부여해야 합니다.

 ![[Pasted image 20240107215104.png]]

서브쿼리 블록 내 qb_name 힌트를 사용해 subq1이라는 이름을 부여했고 밖의 쿼리 블록에서 join_order 힌트에서 해당 테이블에 대한 정보를 사용한 것을 알 수 있습니다.


## MAX_EXECUTION_TIME

옵티마이저 힌트 중 유일하게 쿼리의 실행 계획에 영향을 주지 않습니다. 
MAX_EXECUTION_TIME은 밀리초 단위로 설정해서 해당 쿼리의 실행시간이 제한 시간을 넘으면 실패하도록 처리하는 힌트입니다.

![[Pasted image 20240107234721.png]]


## SET_VAR

SET_VAR 힌트는 실행 게획을 바꾸는 용도 뿐 아니라 조인 버퍼, 소트버퍼의 크기를 일시적으로 증가시켜 대용량 처리의 쿼리 성능 향상의 목적으로 사용할 수 있습니다.

![[Pasted image 20240107235434.png]]

## SEMIJOIN & NOSEMIJOIN

앞서 살펴봤듯이 세미조인은 5종류의 세부전략이 있습니다.
- DUPLICATE WEED-OUT
- FirstMatch
- LooseScan
- Materialization
- Table Pull-Out

`SEMIJOIN(세부전략)` 형태로 사용가능함
단 Table Pull-OUT 세부전략은 사용할 수 없습니다. 다른 세부전략은 상황에 따라 다른 최적화 전략으로 우회해서 사용하거나 현재 전략을 사용하는 것이 효율적이지만 Table PullOut은 다른 세부전략을 사용하도록 변경하는 것이 더 좋은 방법이기 때문입니다.

![[Pasted image 20240108000845.png]]
추가로 세미지조인 힌트는 외부쿼리가 아닌 서브쿼리에 명시해야 합니다. 앞서 살펴본 `qb_name`을 활용해서 외부에서 사용하는 방법도 가능합니다.
> NO_SEMIJOIN힌트로 해당 세미조인을 사용하지 않도록 하는 방법도 있습니다.

## SUBQUERY 
서브쿼리 최적화는 In(subquery) 형태의 쿼리에 사용될 수 있는 세미조인 최적화가 아닌 안티 세미조인에서 주로 사용합니다.
- IN-to-EXISTS
- Materialization
위 두 형태의 서브쿼리에서 최적화 할때 주로 사용하지만 현실적으로 안티 세미 조인 힌트는 사용할 일이 많지 않습니다.

## (NO) BNL & (NO) HASHJOIN
블록 네스티드 루프 조인 알고리즘은 MySQL 8.0.20 버전부터는 해시조인 으로 대체하도록 개선되었습니다.
`BNL()`힌트를 통해서 해시 조인 알고리즘 사용하도록 유도할 수 있습니다. 
HASHJOIN 힌트는 블록 네스티드 루프 조인 알고리즘과 해시조인 알고리즘이 공존할 때 사용하던 힌트로 둘 사이의 선택지를 고르는 힌트입니다.


## JOIN_FIXED_ORDER & JOIN_ORDER  & JOIN_PREFIX & JOIN_SUFFIX
Straight 조인을 대체하기 위해 등장한 힌트입니다. 기존에 Straight join 힌트는 from 절에 명시된 순서대로 조인 순서가 강제 됩니다.
하지만 특정 인덱스만 순서를 정한 다음 나머지는 옵티마이저에게 위임할 수 없는 문제 때문에 아래 네 종류의 힌트가 등장했습니다.
- JOIN_FIXED_ORDERS
	- STRAIGHT_JOIN 힌트와 동일하게 FROM 절의 테이블 순서대로 조인을 실행
- JOIN_ORDER
	- FROM 절에 사용된 테이블의 순서가 아닌 힌트에 명시된 테이블의 순서대로 조인을 실행
- JOIN_PREFIX 
	- 조인에서 드라이빙 테이블만 강제하는 힌트
- JOIN_SUFFIX
	- 조인에서 드리븐 테이블만 강제하는 힌트

## MERGE  & NO_MERGE
이전 버전의 MySQL 서버에서는 FROM 절에 사용된 서브쿼리를 항상 파생 테이블로 만들었습니다. 이는 자원을 불필요하게 낭비하곤 하는데 이를 개선하기 위해 MySQL 서버에서는 서브쿼리와 외부 쿼리로 병합하여 문제를 해결하곤 했습니다.
간혹 파생 테이블이 사용하는 것이 서브쿼리와 외부쿼리를 병합하는 것보다 효율적인 상황이 있기 때문에 `MERGE, NO_MERGE` 힌트를 사용하여 적절하게 대처하는 것이 좋습니다.

## INDEX_MERGE & NO_INDEX_MERGE
MySQL 서버는 가능하다면 테이블당 하나의 인덱스만을 사용하고자 합니다. 간혹 하나의 인덱스만으로 범위를 좁힐 수 없을 때 index_merge의 합, 교집합을 사용하여 범위를 좁힐 수 있습니다.
모든 힌트가 그렇듯이 간혹 그렇지 않은 경우가 있기 때문에 Index_merge 와 no_index_merge를 통해 이를 조절할 수 있습니다. 

## NO_ICP
인덱스 컨디션 푸시다운 최적화는 사용 가능하다면 대부분 성능향상에 도움이 되므로 MySQL 옵티마이저는 최대한 인덱스 컨디션 푸시다운 기능을 사용하는 방향으로 실행 계획을 수립합니다.
하지만 인덱스 컨디션 푸시다운 최적화가 모든 상황에서 더 나은 성능을 보장하지 않는 경우가 있습니다. 
이는 테이블의 데이터 분포가 항상 균등한 것이 아니기 때문에 쿼리 검색 범위에 따라 다를 수 있기 때문입니다. 

## SKIP_SCAN & NO_SKIP_SKAN
인덱스 스킵 스캔은 인덱스의 선행 컬럼에 대한 조건이 없어도 옵티마이저가 해당 인덱스를 사요할 수 있게 해주는 최적화 기능입니다.
하지만 조건이 누락된 선행 컬럼이 가지는 유니크한 값의 개수가 많아진다면 인덱스 스킵 스캔의 성능이 떨어지기 때문에 이를 사용하거나, 사용하지 않도록 힌트를 주는 것도 하나의 방법입니다.

# 통계 정보


## MySQL 서버의 통계 정보

MySQL5.5버전에서는 Show index 명령어만을 통해서 인덱스 컬럼 분포도를 볼 수 있었고 메모리로 저장되기 때문에 휘발성인 문제점이 있었습니다. 특히 서버 재시작의 경우 기존 통계 정보가 날라갔습니다.

5.6버전에서는 이런 문제를 해결하기 위해 현재는 innodb_index_stats과 innodb_table_stats 테이블로 관리되고 있으며 서버가 재시작돼도 기존의 통계 정보를 유지할 수 있습니다. 

```mysql
create table tab_test () engine=InnoDB stats_persistent = { DEFAULT | 0 | 1}
```

stats_persistent 옵션은 0, 1, default 로 구성돼있습니다.
- 0: 5.5이전의 방식대로 관리하며, innodb_index_stats innodb_table_stats테이블에 저장하지 않음
- 1: 테이블의 통계 정보를 mysql 데이터베이스의 innodb_index_stats와 innodb_table_stats 테이블에 저장(기본설정임)
- default: 테이블의 통계를 영구적으로 관리할지 말지를 innodb_stats_persistent 시스템 변수의 값으로 결정합니다. 


## 히스토그램

MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 옵티마이저가 최적의 실행 계획을 수립하기에 많이 부족했습니다.
이를 개선하기위해 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용했으며 8.0부터는 컬럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 됐습니다.

### 히스토그램 정보 수집 및 삭제
MySQL 8.0 버전에서 히스토그램 정보는 컬럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 `ANALYZE TABLE ...UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리됩니다.
![[Pasted image 20240109011759.png]]

먼저 히스토그램은 버킷 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리됩니다.
MySQL 8.0 버전에서는 위 사진과 같이 2종류의 히스토그램 타입을 지원합니다.
- Singleton(싱글톤 히스토그램)
	- 칼럼값 개별로 레코드 건수를 관리하는 히스토그램으로, Value-Based 히스토그램 혹은 도수 분포라고 합니다.
	- 싱글톤 히스토그램은 컬럼이 가지는 값별로 할당됩니다.
	- 싱글톤 히스토그램은 각 버킷이 컬럼의 값과 발생 빈도의 비율 2개의 값을 가짐
- Equal-Hight(높이 균형 히스토그램) 
	- 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로, Height-Balanced 히스토그램이라고 합니다.
	- 높이 균형 히스토그램은 개수가 균등한 컬럼값의 범위별로 하나의 버킷이 할당됩니다. 
	 - 높이 균형 히스토그램은 각 버킷이 범위 시작 값과 마지막 값, 그리고 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 4개의 값을 가집니다.

![[Pasted image 20240109012818.png]]

![[Pasted image 20240109012828.png]]


information_schema.column_statistics 테이블의 histogram 컬럼이 가진 나머지 필드들은 다음 의미를 가집니다.
- sampling-rate
	- 히스토그램 정보를 수집하기 위해 스캔한 페이지의 비율을 저장한다. 샘플링 비율이 0.35라면 전체 데이터 페이지의 35%를 스캔해서 수집함을 의미
- histogram-type
	- 히스토그램의 종류
- number-of-buckets-specified
	- 히스토그램을 생성할 때 설정했던 버킷의 개수를 저장

참고로 생성된 히스토그램은 아래의 방식으로 삭제할 수 있습니다.
![[Pasted image 20240109013044.png]]
단 히스토그램이 사라지게 되면 쿼리의 실행 계획이 사라질 수 있기에 주의해야 합니다.

만약 히스토그램을 삭제하지 않고 MySQL 옵티마이저가 히스토그램을 사용하지 않게 하려면 optimizer_switch 시스템 변수의 값을 변경합니다.
> set global optimizer_switch='condition_fanout_filter=off'  이전에 살펴본 방식임  (세션 단위, 쿼리 힌트로도 가능)

### 히스토그램의 용도

MySQL 서버에 히스토그램이 도입되기 이전에도 테이블과 인덱스에 대한 통계 정보는 존재했지만 기존 MySQL 서버가 가지고 있던 통계 정보는 테이블의 전체 레코드 건수와 인덱스된 컬럼이 가지는 유니크한 값의 개수 정도였습니다.

> 테이블 레코드가 1000건이고 유니크한 값의 개수가 100개라면 동등 비교 검색을 하면 대략 10개의 레코드가 일치할 것으로 생각함

결국 이런 방식은 애플리케이션의 데이터가 항상 균등한 분포도를 가지지 않는다는 것을 간과합니다. 

히스토그램의 유무에 따라 실제 성능 차이가 많이 발생합니다.
![[Pasted image 20240109121146.png]]

![[Pasted image 20240109121312.png]]

먼저 처음 사진을 보면 히스토그램이 없을 때 조건절에 일치하는 레코드가 224건이 있고, 그중에서 대략 11.11%가 조건절과 일치하는 것으로 예측했다.

하지만 히스토그램을 사용한 경우 61.33% 일것으로 예측했는데 이는 히스토그램과 단순 통계 정보만 이용하는 것의 차이가 있다는 것을 알 수 있습니다.

결국 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측하지만 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.

p406의 조인 순서에 대한 예시 처럼 드라이빙 테이블과 드리븐이 어떤 테이블이 각각 가져가느냐에 따라 확연한 성능 차이가 발생한다 그렇기에 조건절을 명확하게 할 수록 쿼리의 성능은 빨라진다. 

### 히스토그램과 인덱스 

인덱스 다이브는 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴보는 작업을 의미한다.

이런 인덱스 다이브가 필요한 이유는 MySQL 서버에서 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 파악하고 최종적으로 가장 나은 실행 계획을 선택하기 때문이다.

쿼리의 검색 조건으로 많이 사용되는 컬럼에 대해서 인덱스를 주로 생성하는데 해당 컬럼에 대해 히스토그램 정보를 수집하는 것을 고민할 때 몇 가지 주의할 점이 있습니다.
```
select * from employees  
 where first_name = 'Tonny'  
 and birth_date between '195-01-01' and '1955-01-01';
```
옵티마이저는 테이블 풀 스캔을 할지 first_name 컬럼의 인덱스를 이용할지 고민하는데 MySQL 8.0 서버에서는 인덱스된 컬럼을 검색 조건으로 사용하는 경우 컬럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.
이렇게 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것이므로 항상 히스토그램보다 정확한 결과값을 기대할 수 있기 때문입니다.

즉 히스토그램을 사용하는 것은 인덱스되지 않은 컬럼에 대한 데이터 분포도를 참조하는 용도로 사용됩니다.

> 히스토그램을 사용하는 작업이 더 좋을 때가 있지만 아직 관련 힌트는 없음
## 코스트 모델

MySQL 서버가 쿼리를 처리하려면 다음과 같은 다양한 작업을 필요로 합니다. 
- 디스크로 부터 데이터 페이지 읽기
- 메모리로 부터 데이터 페이지 읽기
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업
MySQL 서버는 사용자의 쿼리에 대해 위 작업이 얼마나 필요할지 예측하고 비용을 계산해서 최적의 실행 계획을 찾습니다.  이런 작업을 *코스트 모델*이라고 합니다. 

이런 코스트 모델의 문제점이 있는데 바로 MySQL 서버 코드에서 상수화 해서 사용했다. 이는 사용자 하드웨어에 따라 달라지는 것을 식별하지 못하고 고정된 비용을 일률적으로 적용하기 때문에 최적의 실행 계획 수립에 있어서 방해 요소였습니다.

결국 이런 단점을 보완하기 위해 MyQL 5.7 버전부터 MySQL 서버의 소스 코드에 상수화돼 있던 각 단위 작업의 비용을 DBMS 관리자가 조정할 수 있게 개선됐습니다.

현재 코스트 모델은 2개 테이블에 저장돼 있는 설정 값을 사용합니다.
- server_cost : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
	- cost_name : 코스트 모델의 각 단위 작업
	- default_value : 각 단위 작업의 비용
	- cost_value: DBMS 관리자가 설정한 값
	- last_updated: 단위 작업의 비용이 변경된 시점
	- comment: 비용에 대한 추가 설명
- engine_cost : 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리
	- engine_name : 비용이 적용된 스토리지 엔진
	- device_type: 디스크 타입

MySQL 8.0버전의 코스트 모델에서 지원하는 단위 작업은 8개가 존재합니다.

| 테이블 이름 | cost_name | default_value | 설명 | 옵티마이저에게 영향 미치는 영향 |
| ---- | ---- | ---- | ---- | ---- |
| engine_cost | io_block_read_cost | 1 | 디스크 데이터 페이지 읽기 | 해당 단위 작업의 비용을 높이면 innodb 버퍼 풀에 데이터 페이지가 만힝 적재돼 있는 인덱스를사용할 가능성이 높아짐 |
| engine_cost | memory_block_read_cost | 0.25 | 메모리 데이터 페이지 읽기 | 해당 단위 작업의 비용을 높이면 메모리 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아짐 |
| server_cost | disk_temptable_cost | 20 | 디스크 임시 테이블 생성 | 해당 단위 작업의 비용을 높이면 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아짐 |
| server_cost | disk_temptable_row_cost | 0.5 | 디스크 임시 테이블의 레코드 읽기 | // |
| server_cost | key_compare_cost | 0.05 | 인덱스 키 비교 | 해당 비용을 높이면 MySQL 서버 옵티마이저가 간으하면 정렬을 수행하지 않는 방향의 실행 계획을 선택함 |
| server_cost | memory_temptable_create_cost | 1 | 메모리 임시 테이블 생성 | 해당 단위 작업과 아래 행의 단위 작업의 비용을 높이면 메모리 임시 테이블을 만들지 않을 가능성이 높아짐 |
| server_cost | memory_temptable_row_cost | 0.1 | 메모리 임시 테이블의 레코드 읽기 | // |
| server_cost | row_evaluate_cost | 0.1 | 레코드 비교 | 해당 단위 작업의 비용을 높이면 풀 스캔을 실행하는 쿼리들의 비용이 높아지고 ,가능한 인덱스 레인지 스캔을 사용함 |


여기서 row_evaluate_cost는 스토리지 엔진이 반환한 레코드가 쿼리의 조건에 일치하는지를 평가하는 다누이 작업을 의미합니다 .

MySQL 서버에서 각 실행 계획의 개산된 비용은 다음과 같이 확인할 수 있습니다.

![[Pasted image 20240109164836.png]]

코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 비용이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행 계획들이 저비용으로 바뀌는지를 파악하는 것입니다.
	