---
cssclasses:
  - my_style_width_100
---
# 쿼리 힌트 

> 💡 옵티마이저 힌트가 필요한 이유
> MySQL 서버는 우리가 서비스하는 비즈니스를 100% 이해하지 못합니다. 그렇기에 서비스 개발자나 DBA보다 MySQL 서버가 부족한 실행 계획을 수립할 때가 있는데 이때 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 알려줘야합니다.
> 
> 🗒 결국 힌트는 옵티마이저에게 우리가 원하는 실행 계획의 의도를 명확하게 파악하도록 하기 위함이다.
>  > 어떤 경우에 힌트가 실패할까? (이전에 살펴본 프라이머리키 선호 방식이 있겠다)

MySQL 서버에서 사용 가능한 쿼리 힌트는 2가지가 있습니다.
1. 인덱스 힌트
2. 옵티마이저 힌트


## 인덱스 힌트

> 인덱스 힌트가 뭐지? (책에서 설명이 없는데..?)
> 없어서 공식문서에서 가져옴

Index hints give the optimizer information about how to choose indexes during query processing.

### 🤔 인덱스 힌트의 적용 범위
> index hints apply to [`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html "13.2.13 SELECT Statement") and [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html "13.2.17 UPDATE Statement") statements. They also work with multi-table [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html "13.2.2 DELETE Statement") statements, but not with single-table `DELETE`, as shown later in this section

책에서 인덱스 힌트는 SELECT, UPDATE에서만 사용가능하다고 한다.
하지만 공식문서에서는 다중 테이블 delete에서도 동작 가능하다고 설명한다.
어떤게 맞는지 책을 보면서 찾아보자


### STRAIGHT_JOIN

STRAIGHT_JOIN는 여러 개의 테이블이 조인될 떄 조인 순서를 고정하는 역할을 합니다. 일반적으로 드라이빙 테이블과 드리븐 테이블을 결정하는 것은 옵티마이저의 역할입니다.
테이블의 레코드 수를 기준으로 적은 테이블은 드라이빙 테이블, 반대는 드리븐테이블로 결정됩니다.
![[Pasted image 20240104202650.png]]
참고로 STRAIGHT_JOIN을 사용하기 위한 기준이 있다.
1. 임시 테이블과 일반 테이블의 조인
	- 일반적으로 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋습니다.
	- 만약 일반 테이블에 인덱스가 없는 경우 레코드가 적은 쪽을 선택하는 것이 좋습니다 (이러면 옵티마이저가 해주는 것 아닌가?) 
2. 임시 테이블끼리 조인
	 - 임시테이블은 인덱스가 없기 때문에 어느 테이블을 먼저 드라이빙으로 읽어도 무관하기에 크기가 작은 테이블을 드라이빙 테이블로 선택해주는 것이 좋습니다.
3. 일반 테이블끼리 조인
	- 양쪽 테이블 모두 조인 컬럼에 인덱스가 있거나 양쪽 테이블 모두 조인 컬럼에 인덱스가 없는 경우에는 레코드 건수가 적은 테이블을 드라이빙으로 선택해주는 것이 좋으며, 그 이외에는 조인 컬럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋습니다. 

### USE INDEX / FORCE INDEX / IGNORE INDEX

위 세종류의 인덱스 힌트는 조인의 순서를 변경하는 것 다음으로 자주 사용됩니다. 
사용하는 방법은 인덱스를 가지는 테이블 뒤에 힌트를 명시하는 것입니다.

#### 왜 사용하나요?
대부분의 경우 옵티마이저는 어떤 인덱스를 선택할지 잘 고르지만 3~4개 이상의 컬럼을 포함하는 비슷한 인덱스가 여러개 존재할 때 실수를 한다. 

#### 어떤 종류가 있나요?
1. `USE INDEX`
2. `FORCE INDEX`
3. `IGNORE INDEX`

##### USE INDEX
가장 자주 사용하는 인덱스 힌트입니다. 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 정도입니다.

##### FORCE INDEX
USE INDEX 보다 옵티마이저에게 미치는 영향이 더 큰 인덱스 힌트입니다.
> ⚠ (주의)
> 단 USE INDEX로도 줄 수 없는 경우에는 FORCE INDEX도 적용이 안됩니다.
 
##### IGNORE INDEX
두 인덱스 힌트와 다르게 옵티마이저가 해당 인덱스를 사용할 수 없도록 합니다.


#### 어떤 용도로 사용하나요
위 3종류의 인덱스 힌트 모두 용도를 명시해줄 수 있으며 *선택 사항*인데 특별히 인덱스 힌트에 용도가 명시되지 않으면 주어진 인덱스를 3가지 용도로 사용합니다.
##### USE INDEX FOR JOIN
조인 + 테이블을 검색하는 용도로 사용할 수 있습니다.
##### USE INDEX FOR [ORDER BY | GROUP BY]
명시된 인덱스를 ORDER BY혹은 GROUP BY로 사용할 수 있습니다.

#### 예제
![[Pasted image 20240106001935.png]]

처음 세 쿼리는 정상적으로 인덱스를 사용하는 것을 확인할 수 있습니다.
반면 아래 두 쿼리는 emp_no를 인덱스로 사용하지 않기 때문에 풀 테이블 스캔을 하는데 옵티마이저는 이런 터무니없는 지시를 수행하는 것을 알 수 있습니다.

#### 종합
결론은 위 예제 처럼 힌트를 사용하는 것은 주의해야 합니다. 


> "가장 훌륭한 최적화는 그 쿼리를 서비스에서 없애 버리거나 튜닝할 필요가 없게 데이터를 최소화하는 것"
> -> 검색할 데이터의 크기를 줄이는  것
> ex) 카카오톡 같은 서비스를 예시로 볼 수 있음 채팅 같은 데이터는 크기가 큰데 서버에서 저장하는 데이터의 크기를 3일로 제한 해버리고 나머지 데이터는 로그로 저장하는 방식


### SQL_CALC_FOUND_ROWS

MySQL에서 Limit를 사용하면 limit 건수만큼 찾았다면 검색을 멈춥니다.
하지만 SQL_CALC_FOUND_ROWS 힌트를 사용했을 때 제한된 수만큼 찾더라도 조건에 맞는 모든 레코드를 읽습니다.
보통 `FOUND_ROWS()` 를 통해 직전에 읽은 쿼리의 레코드 수를 가져오는 조합으로 사용하면 온라인 트랜잭션 환경에서 페이지네이션으로 사용할 때 유용하다고 생각할 수 있습니다.

하지만 이는 생각과 다르게 흘러갑니다.

![[Pasted image 20240106031003.png]]

#### SQL_CALC_FOUND_ROWS 사용
먼저 맨 위 두 쿼리를 사용하는 경우 만족하는 레코드의 건수는 253건 중 20건의 레코드를 결과를 가져옵니다. 
하지만 실제 실행의 결과는 조금 다릅니다.
앞서 LIMIT는 제한된 레코드의 건수를 읽은 다음 검색을 멈추지만 위 쿼리는 그렇지 않습니다.

SQL_CALC_FOUND_ROWS를 사용했을 때 인덱스를 타는 쿼리라도 랜덤 io가 limit의 건수만큼 발생하는 것이 아닌 조건에 맞는 모든 쿼리에 대해 발생하기 때문에
불필요한 랜덤 io가 발생합니다. 

#### 기존 2개 쿼리로 쪼개어 실행하는 방법
아래의 첫 번째 쿼리는 커버링 인덱스 쿼리로 실제 데이터를 찾아오기 위한 랜덤 IO가 발생하지 않습니다.
그리고 밑의 쿼리에서는 인덱스를 읽고 20건의 조건에 일치하는 데이터를 찾은 다음 랜덤 IO가 발생하기 때문에 앞서 사용한 쿼리보다 훨씬 효율적으로 동작합니다.

#### 결론
전기적 처리인 메모리나 CPU의 연산 작업에 비해 기계적 처리인 디스크 작업이 얼마나 느린 작업인지를 고려하면 비교할 수 도 없을 만큼 SQL_CALC_FOUND_ROWS를 사용하는 경우가 느리다는 것을 알수 있습니다.
이는 개발의 편의성을 위해 만들어진 것이며 현재 deprecated 됐기 떄문에 사용하는 것은 권장하지 않습니다. 




### 2가지 형태의 옵티마이저 힌트
```
/*! */
/*+ */
```
https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html


370p를 보면 `여전히 MySQL 서버는 우리가 서비스하는 비즈니스를 100% 이해하지는 못한다. 그래서 서비스 개발자나 DBA 보다 MySQL 서버가 부족한 실행 계획을 수립할 때가 있을 수 있다` 에서 어떤 상황에서 주로 MySQL 서버의 옵티마이저가 실행 계획 수립 실패예시입니다.

https://medium.com/daangn/mysql-optimizer-error-e438aa02e622



# 옵티마이저 힌트

옵티마이저 힌트는 영향 범위에 따라 네 가지로 구분 됩니다.
- 인덱스
- 테이블
- 쿼리 블록 
- 글로벌

> 💡 (쿼리블록)
> 여기서 쿼리블록이란 select 키워드로 시작하는 서브 쿼리 영역을 의미합니다.
> 또한 특정 쿼리블록에 영향을 미치는 옵티마이저 힌트는 쿼리 블록에서 사용하는 것 뿐만 아니라 외부 쿼리 블록에서 사용 가능합니다.
> 이때 쿼리 블록을 명시하기 위해 `QB_NAME` 힌트를 이용해 이름을 부여해야 합니다.

 ![[Pasted image 20240107215104.png]]

서브쿼리 블록 내 qb_name 힌트를 사용해 subq1이라는 이름을 부여했고 밖의 쿼리 블록에서 join_order 힌트에서 해당 테이블에 대한 정보를 사용한 것을 알 수 있습니다.


## MAX_EXECUTION_TIME

옵티마이저 힌트 중 유일하게 쿼리의 실행 계획에 영향을 주지 않습니다. 
MAX_EXECUTION_TIME은 밀리초 단위로 설정해서 해당 쿼리의 실행시간이 제한 시간을 넘으면 실패하도록 처리하는 힌트입니다.

![[Pasted image 20240107234721.png]]


## SET_VAR

SET_VAR 힌트는 실행 게획을 바꾸는 용도 뿐 아니라 조인 버퍼, 소트버퍼의 크기를 일시적으로 증가시켜 대용량 처리의 쿼리 성능 향상의 목적으로 사용할 수 있습니다.

![[Pasted image 20240107235434.png]]

## SEMIJOIN & NOSEMIJOIN

앞서 살펴봤듯이 세미조인은 5종류의 세부전략이 있습니다.
- DUPLICATE WEED-OUT
- FirstMatch
- LooseScan
- Materialization
- Table Pull-Out

`SEMIJOIN(세부전략)` 형태로 사용가능함
단 Table Pull-OUT 세부전략은 사용할 수 없습니다. 다른 세부전략은 상황에 따라 다른 최적화 전략으로 우회해서 사용하거나 현재 전략을 사용하는 것이 효율적이지만 Table PullOut은 다른 세부전략을 사용하도록 변경하는 것이 더 좋은 방법이기 때문입니다.

![[Pasted image 20240108000845.png]]
추가로 세미지조인 힌트는 외부쿼리가 아닌 서브쿼리에 명시해야 합니다. 앞서 살펴본 `qb_name`을 활용해서 외부에서 사용하는 방법도 가능합니다.
> NO_SEMIJOIN힌트로 해당 세미조인을 사용하지 않도록 하는 방법도 있습니다.

## SUBQUERY 
서브쿼리 최적화는 In(subquery) 형태의 쿼리에 사용될 수 있는 세미조인 최적화가 아닌 안티 세미조인에서 주로 사용합니다.
- IN-to-EXISTS
- Materialization
위 두 형태의 서브쿼리에서 최적화 할때 주로 사용하지만 현실적으로 안티 세미 조인 힌트는 사용할 일이 많지 않습니다.

## (NO) BNL & (NO) HASHJOIN
블록 네스티드 루프 조인 알고리즘은 MySQL 8.0.20 버전부터는 해시조인 으로 대체하도록 개선되었습니다.
`BNL()`힌트를 통해서 해시 조인 알고리즘 사용하도록 유도할 수 있습니다. 
HASHJOIN 힌트는 블록 네스티드 루프 조인 알고리즘과 해시조인 알고리즘이 공존할 때 사용하던 힌트로 둘 사이의 선택지를 고르는 힌트입니다.


## JOIN_FIXED_ORDER & JOIN_ORDER  & JOIN_PREFIX & JOIN_SUFFIX
Straight 조인을 대체하기 위해 등장한 힌트입니다. 기존에 Straight join 힌트는 from 절에 명시된 순서대로 조인 순서가 강제 됩니다.
하지만 특정 인덱스만 순서를 정한 다음 나머지는 옵티마이저에게 위임할 수 없는 문제 때문에 아래 네 종류의 힌트가 등장했습니다.
- JOIN_FIXED_ORDERS
	- STRAIGHT_JOIN 힌트와 동일하게 FROM 절의 테이블 순서대로 조인을 실행
- JOIN_ORDER
	- FROM 절에 사용된 테이블의 순서가 아닌 힌트에 명시된 테이블의 순서대로 조인을 실행
- JOIN_PREFIX 
	- 조인에서 드라이빙 테이블만 강제하는 힌트
- JOIN_SUFFIX
	- 조인에서 드리븐 테이블만 강제하는 힌트

## MERGE  & NO_MERGE
이전 버전의 MySQL 서버에서는 FROM 절에 사용된 서브쿼리를 항상 파생 테이블로 만들었습니다. 이는 자원을 불필요하게 낭비하곤 하는데 이를 개선하기 위해 MySQL 서버에서는 서브쿼리와 외부 쿼리로 병합하여 문제를 해결하곤 했습니다.
간혹 파생 테이블이 사용하는 것이 서브쿼리와 외부쿼리를 병합하는 것보다 효율적인 상황이 있기 때문에 `MERGE, NO_MERGE` 힌트를 사용하여 적절하게 대처하는 것이 좋습니다.

## INDEX_MERGE & NO_INDEX_MERGE
MySQL 서버는 가능하다면 테이블당 하나의 인덱스만을 사용하고자 합니다. 간혹 하나의 인덱스만으로 범위를 좁힐 수 없을 때 index_merge의 합, 교집합을 사용하여 범위를 좁힐 수 있습니다.
모든 힌트가 그렇듯이 간혹 그렇지 않은 경우가 있기 때문에 Index_merge 와 no_index_merge를 통해 이를 조절할 수 있습니다. 

## NO_ICP
인덱스 컨디션 푸시다운 최적화는 사용 가능하다면 항상 성능향상에 도움이 되므로 MySQL 옵티마이저는 최대한 인덱스 컨디션 푸시다운 기능을 사용하는 방향으로 실행 계획을 수립합니다.
하지만 인덱스 컨디션 푸시다운 최적화가 모든 상황에서 더 나은 성능을 보장하지 않는 경우가 있습니다. 
이는 테이블의 데이터 분포가 항상 균등한 것이 아니기 때문에 쿼리 검색 범위에 따라 다를 수 있기 때문입니다. 

## SKIP_SCAN & NO_SKIP_SKAN
인덱스 스킵 스캔은 인덱스의 선행 컬럼에 대한 조건이 없어도 옵티마이저가 해당 인덱스를 사요할 수 있게 해주는 최적화 기능입니다.
하지만 조건이 누락된 선행 컬럼이 가지는 유니크한 값의 개수가 많아진다면 인덱스 스킵 스캔의 성능이 떨어지기 때문에 이를 사용하거나, 사용하지 않도록 힌트를 주는 것도 하나의 방법입니다.

