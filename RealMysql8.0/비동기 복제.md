

MySQL은 기본적으로 비동기 복제 방식으로 동작합니다. 


> [!NOTE] 비동기 방식
> 
> 소스 서버가 자신과 복제 연결된 레플리카 서버에서 변경 이벤트가 정상적으로 전달돼 적용됐는지를 확인하지 않는 방식

![[Pasted image 20240416122057.png]]

1. 소스 서버에서 커밋된 트랜잭션은 바이너리 로그에 기록
2. 레플리카서 서버에서 주기적으로 신규 트랜잭션에 대한 바이너리 로그를 소스 서버에 요청

[[../MySQL 복제 아키텍처|MySQL 복제 아키텍처]]

비동기 복제 방식에서 소스 서버는 레플리카 서버로 변경 이벤트가 잘 전달됐는지, 실제로 적용됐는지 알지 못하며 어떠한 보장도 하지 않는다.
- 즉 누락된 트랜잭션이 발생할 수 있다.
	- 이런 경우 소스 서버로부터 전달받지 못한 트랜잭션이 있는지 직접 확인하고, 필요 시 레플리카 서버에 수동으로 다시 적용해야 한다.

## 단점
- 이처럼 비동기 복제는 소스 서버가 레플리카 서버의 동기화 여부를 보장하지 않는다는 것이 가장 큰 단점이다.
## 장점
- 소스 서버가 각 트랜잭션에 대해 레플리카 서버로 전송되는 부분을 고려하지 않기 때문에 트랜잭션 처리에 있어서 더 빠른 성능을 보인다. 
- 소스 서버에 레플리카 서버를 여러 대 연결한다 해도 소스 서버에서 큰 성능 저하가 없기 때문에 레플리카 서버를 확장해서 읽기 트래픽을 분산하는 용도로 사용할 수 있다. (10대 이상 연결하는 경우는 있다네요)
- 레플리카 서버에 무거운 쿼리가 실행되어 성능 저하가 있다고 하더라도 분산하는 용도로 제격


> [!NOTE] 참고
> 
> 비동기 복제에서는 사용자가 소스 서버에서 데이터를 변경한 후 바로 레플리카 서버에서 해당 데이터를 확인 했을 때 변경 전 데이터가 보여질 수도 있다.
> 특별한 문제가 없다면 소스 서버에서 실행된 쿼리는 2~300밀리초 이내의 짧은 시간 내 레플리카 서버에도 적용된다.
> 다만 즉각적으로 반영된 데이터를 조회해야 하는 민감한 경우에는 레플리카 서버보다는 소스 서버에서 직접 데이터를 읽어 가도록 구현하는 것이 좋다. 




