---
cssclasses:
  - my_style_width_100
---
- 파티션 기능은 테이블을 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리해서 관리
- 주로 대용량 테이블을 물리적을 여러 개의 소규모 테이블로 분산하는 목적으로 사용
- 파티션 기능을 사용한다고 해서 성능이 빨라지지는 않으며, 더 나빠지는 경우도 있음



# 파티션
> ⚠ 학습목표
> MySQL 파티션이 적용된 테이블에서 insert, select 등과 같은 쿼리가 어떻게 실행되는지 이해하기
> 파티션이 SQL 문장을 수행하는 데 어떻게 영향을 미치는지 기대할 수 있는 장점은 무엇인지


## 파티션을 사용하는 이유
파티션이 필요한 경우는 하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 크거나 데이터 특성상 주기적인 삭제 작업이 필요한 경우 

### 단일 insert 와 단일 또는 범위 select의 범위 처리
테이블의 레코드가 많아지면 인덱스가 커지게 된다. 이는 select, update,delete 작업도 느려지는 문제가 발생한다.
- 특히 한 테이블의 인덱스 크기가 물리적으로 MySQL이 사용 가능한 메모리 공간보다 크다면 그 영향은 더 심각하다. 

- 테이블의 데이터는 실질적인 물리 메모리보다 큰 것이 일반적이지만 인덱스의 워킹 셋이 실질적인 메모리보다 큳면 쿼리 처리가 느려집니다. 

![[Pasted image 20240317174427.png]]
- 그림에서 볼 수 있듯이 파티션 하지 않고 하나의 큰 테이블로 사용하면 인덱스도 커지며 물리적인 메모리 공간도 많이 필요해진다는 사실을 알 수 있습니다.

> 참고
> 
> 테이블의 데이터가 10GB이고 인덱스가 3GB
> 
> 13GB를 사용하는 것이 아닌 일저 부분만 활발하게 사용된다.
> 게시물이 100만 건이 저장된 테이블이라고 하더라도 20~30% 정도만 활용한다. 
> 대부분의 테이블 데이터가 이런 형태로 사용되는데 이를 워킹 셋(Working Set)이라고 표현 


### 데이터의 물리적인 저장소를분리
- 데이터 파일 혹은 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다면 백업, 관리 작업이 어렵다.
- MySQL은 인덱스를 파일 단위로 관리하기에 문제가 발생할 여지가 있다.
- 결국 이런 문제를 해결하기 위해 파티션을 통해 파일의 크기를 조절하거나 파티션별 파일들이 저장될 위치나 디스크를 구분해서 지정해 해결하는 것이 가능하지만 MySQL에서는 테이블의 파티션 단위 인덱스 생성 및 파티션별로 다른 인덱스를 가지는 형태를 지원하지 않는다. 


### 이력 데이터의 효율적인 관리

로그 데이터는 대부분의 애플리케이션이 가지는 데이터입니다.  이는 단기간에 대량으로 누적됨과 동시에 일정 기간이 지나면 쓸모가 없어집니다. 

쓸모가 없어진 로그 데이터는 별도로 아카이빙하거나 백업한 후 삭제해버리는 것이 일반적이며 다른 데이터에 비해 라이프 사이크이 상당히 짧습니다. 

로그 테이블에서 불필요해진 데이터를 백업하거나 삭제하는 작업은 일반 테이블에서는 상당히 고부하의 작업에 속하지만 로그 테이블을 파티션 테이블로 관리한다면 불필요한 데이터 삭제 작ㅇㅂ은 파티션을 추가하거나 삭제하는 방식으로 간단하게 해결할 수 있습니다.
![[Pasted image 20240317175748.png]]

대량의 데이터가 저장된 로그 테이블을 기간 단위로 삭제한다면 MySQL 서버 전체에 미치는 부하뿐만 아니라 로그 테이블 자체의 동시성에도 영향을 미칠 수 있기에 파티션을 활용하면 이러한 문제를 쉽게 해결할 수 있습니다. 


## MySQL 파티션의 내부 처리

![[Pasted image 20240317180201.png | 600]]


#### 파티션 테이블의 레코드 insert 
insert 쿼리가 실행되면 MySQL 서버는 insert되는 컬럼의 값 중에서 파티션 키인 reg_date 컬럼의 값을 이용해 파티션 표현식을 평가하고, 그 결과를 이용해 레코드가 저장될 파티션을 결정합니다.

![[Pasted image 20240317191350.png]]

#### 파티션 테이블의 update
update 쿼리를 실행하려면 변경 대상 레코드가 어느 파티션에 저장돼 있는지 찾습니다. 이때 update 쿼리의 where 조건에 파티션 키 컬럼이 조건으로 존재한다면 그 값을 이용해 레코드가 저장된 파티션에서 빠르게 대상 레코드를 검색합니다. 

하지만 where 조건에 파티션 키 컬럼의 조건이 명시되지 않았다면 MySQL 서버는 변경 대상 레코드를 찾기 위해 모든 파티션을 검색합니다.

또한 실제 레코드를 변경하는 작업의 절차는 update 쿼리가 어떤 컬럼의 값을 변경하느냐에 따라 큰 차이가 발생합니다.
- 파티션 키 이외의 컬럼만 변경될 떄는 파티션이 적용되지 않은 일반 테이블과 마찬가지로 컬럼 값만 변경
- 파티션 키 컬럼이 변경될 떄는 아래와 같이 기존 레코드가 저장된 파티션에서 해당 레코드를 삭제 후 그 결과를 이용해 레코드를 이동시킬 파티션을 결정해서 레코드를 저장합니다. 
![[Pasted image 20240317191628.png]]

#### 파티션 테이블의 검색





## 문제

1. 워킹 셋이 무엇인가요?
2. MySQL에서는 테이블 파티션 단위 인덱스 생성 기능을 지원한다 (O, X)