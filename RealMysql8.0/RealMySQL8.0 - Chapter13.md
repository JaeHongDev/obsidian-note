---
cssclasses: []
---
- 파티션 기능은 테이블을 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리해서 관리 (이거 MySQL에서도 물리적으로 분리함?)
- 주로 대용량 테이블을 물리적을 여러 개의 소규모 테이블로 분산하는 목적으로 사용
- 파티션 기능을 사용한다고 해서 성능이 빨라지지는 않으며, 더 나빠지는 경우도 있음



# 파티션
> ⚠ 학습목표
> MySQL 파티션이 적용된 테이블에서 insert, select 등과 같은 쿼리가 어떻게 실행되는지 이해하기
> 파티션이 SQL 문장을 수행하는 데 어떻게 영향을 미치는지 기대할 수 있는 장점은 무엇인지


## 파티션을 사용하는 이유
파티션이 필요한 경우는 하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 크거나 데이터 특성상 주기적인 삭제 작업이 필요한 경우 

### 단일 Insert 와 단일 또는 범위 select의 범위 처리
테이블의 레코드가 많아지면 인덱스가 커지게 된다. 이는 select, update,delete 작업도 느려지는 문제가 발생한다.
- 특히 한 테이블의 인덱스 크기가 물리적으로 MySQL이 사용 가능한 메모리 공간보다 크다면 그 영향은 더 심각하다. 
- 테이블의 데이터는 실질적인 물리 메모리보다 큰 것이 일반적이지만 인덱스의 워킹 셋이 실질적인 메모리보다 크다면 쿼리 처리가 느려집니다. 

![[Pasted image 20240317174427.png]]
- 그림에서 볼 수 있듯이 파티션 하지 않고 하나의 큰 테이블로 사용하면 인덱스도 커지며 물리적인 메모리 공간도 많이 필요해진다는 사실을 알 수 있습니다.

> 참고
> 
> 테이블의 데이터가 10GB이고 인덱스가 3GB
> 
> 13GB를 사용하는 것이 아닌 일정 부분만 활발하게 사용된다.
> 게시물이 100만 건이 저장된 테이블이라고 하더라도 20~30% 정도만 활용한다. 
> 대부분의 테이블 데이터가 이런 형태로 사용되는데 이를 워킹 셋(Working Set)이라고 표현 


### 데이터의 물리적인 저장소를 분리
- 데이터 파일 혹은 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다면 백업, 관리 작업이 어렵다.
- MySQL은 <u>인덱스를 파일 단위로 관리</u>하기에 문제가 발생할 여지가 있다.
- 결국 이런 문제를 해결하기 위해 파티션을 통해 파일의 크기를 조절하거나 파티션별 파일들이 저장될 위치나 디스크를 구분해서 지정해 해결하는 것이 가능하지만 MySQL에서는 테이블의 파티션 단위 인덱스 생성 및 파티션별로 다른 인덱스를 가지는 형태를 지원하지 않는다. 

> 그래서..?


### 이력 데이터의 효율적인 관리

로그 데이터는 대부분의 애플리케이션이 가지는 데이터입니다.  이는 단기간에 대량으로 누적됨과 동시에 일정 기간이 지나면 쓸모가 없어집니다. 

쓸모가 없어진 로그 데이터는 별도로 아카이빙하거나 백업한 후 삭제해버리는 것이 일반적이며 다른 데이터에 비해 라이프 사이클이 상당히 짧습니다. 

로그 테이블에서 불필요해진 데이터를 백업하거나 삭제하는 작업은 일반 테이블에서는 상당히 고부하의 작업에 속하지만 로그 테이블을 파티션 테이블로 관리한다면 불필요한 데이터 삭제 작업은 파티션을 추가하거나 삭제하는 방식으로 간단하게 해결할 수 있습니다.
![[Pasted image 20240317175748.png]]

대량의 데이터가 저장된 로그 테이블을 기간 단위로 삭제한다면 MySQL 서버 전체에 미치는 부하뿐만 아니라 로그 테이블 자체의 동시성에도 영향을 미칠 수 있기에 파티션을 활용하면 이러한 문제를 쉽게 해결할 수 있습니다. 


## MySQL 파티션의 내부 처리

![[Pasted image 20240317180201.png | 600]]


#### 파티션 테이블의 레코드 insert 
insert 쿼리가 실행되면 MySQL 서버는 insert되는 컬럼의 값 중에서 파티션 키인 reg_date 컬럼의 값을 이용해 파티션 표현식을 평가하고, 그 결과를 이용해 레코드가 저장될 파티션을 결정합니다.

![[Pasted image 20240317191350.png]]

#### 파티션 테이블의 update
update 쿼리를 실행하려면 변경 대상 레코드가 어느 파티션에 저장돼 있는지 찾습니다. 이때 update 쿼리의 where 조건에 파티션 키 컬럼이 조건으로 존재한다면 그 값을 이용해 레코드가 저장된 파티션에서 빠르게 대상 레코드를 검색합니다. 

하지만 where 조건에 파티션 키 컬럼의 조건이 명시되지 않았다면 MySQL 서버는 변경 대상 레코드를 찾기 위해 모든 파티션을 검색합니다.

또한 실제 레코드를 변경하는 작업의 절차는 update 쿼리가 어떤 컬럼의 값을 변경하느냐에 따라 큰 차이가 발생합니다.
- 파티션 키 이외의 컬럼만 변경될 때는 파티션이 적용되지 않은 일반 테이블과 마찬가지로 컬럼 값만 변경
- 파티션 키 컬럼이 변경될 떄는 아래와 같이 기존 레코드가 저장된 파티션에서 해당 레코드를 삭제 후 그 결과를 이용해 레코드를 이동시킬 파티션을 결정해서 레코드를 저장합니다. 
![[Pasted image 20240317191628.png]]

#### 파티션 테이블의 검색

> 파티션 테이블을 검색할 때 성능에 영향을 미치는 조건
- where절의 조건으로 검색해야 할 파티션을 선택할 수 있는가?
- where절의 조건이 인덱스를 효율적으로 사용할 수 있는가?


 - 파티션 선택 가능 + 인덱스 효율적 사용 가능: 두 선택사항이 모두 사용 가능할 때 쿼리가 가장 효율적으로 처리
 - 파티션 선택 불가 + 인덱스 효율적 사용 가능
	 - where 조건에 일치하는 레코드가 저장된 파티션을 걸러낼 수 없기 때문에 테이블의 모든 파티션을 대상으로 검색해야 함. 각 파티션에 대해서는 인덱스 레인지 스캔을 사용할 수 있기 때문에 파티션 개수만큼 인덱스 레인지 스캔을 한 다음, 결과를 병합해서 가져옴
- 파티션 선택 가능 + 인덱스 효율적 사용 불가
	- 레코드가 저장된 파티션을 선별할 수 있기에 파티션 개수와 관계없이 특정 파티션만 읽으면 됩니다. 
	- 다만 인덱스는 이용할 수 없기 때문에 풀 테이블 스캔을 함
- 파티션 선택 불가 + 인덱스 효율적 사용 불가
	- 테이블 모든 파티션을 검색 + 풀 테이블 스캔을 하기 떄문에 상당히 느리다. 


### 파티션 테이블의 인덱스 스캔과 정렬
- MySQL의 파티션 테이블에서 인덱스는 로컬 인덱스에 해당
- 모든 인덱스는 파티션 단위로 생성되며, 파티션과 관계없이 테이블 전체 단위로 하나의 통합된 인덱스는 지원하지 않음


![[Pasted image 20240318114254.png]]

#### 파티션 테이블은 어떻게 정렬된 결과를 반환할까?
- 파티션되지 않은 테이블에서는 인덱스를 순서대로 읽으면 해당 컬럼으로 정렬된 결과를 <b>바로</b> 얻을 수 있지만 파티션되지 않은 테이블은 그렇지 않습니다.
![[Pasted image 20240318115329.png]]
![[Pasted image 20240318115350.png]]
파티션 테이블은 물리적인 저장공간이 분리돼 있기 때문에 여러 파티션에 거쳐 데이터를 가져온다면 정렬 작업이 필요할 것으로 보입니다.

실제 내부 동작에서는 인덱스 스캔을 수행할 때 각 파티션으로 부터 조건에 일치하는 레코드를 정렬된 순서로 읽으며 우선순위 큐에 임시로 저장한 이후 필요한 데이터를 가져오는 방식으로 동작합니다.

이는 파티션 테이블 내부에서는 이미 인덱스를 기준으로 정렬돼 있기 때문에 별도의 정렬 작업은 필요없지만 일반 테이블의 인덱스 스캔처럼 결과를 바로 반환하는 것이 아닌 내부적으로 머지&소트를 필요로 합니다.


### 파티션 프루닝

파티션 프루닝은 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 것을 의미합니다. 
- 파티션 프루닝정보로 실제 어떤 파티션만 접근하는지 확인할 수 있습니다. 
![[Pasted image 20240318120454.png | 1000]]


# 주의 사항

## 파티션의 제약 사항
![[Pasted image 20240318120556.png]]

파티션 테이블을 만드는 sql
- `PARTITION BY RANGE` 절에서 테이블이 레인지 파티션을 사용하는 것을 의미
- 파티션 컬럼은 `reg_date`
- 표현식으로 `year(reg_date)`가 사용
=> tb_article에서 re_date 컬럼에서 year 내장 함수를 사용해서 연도만 추출

아래는 MySQL 서버의 파티션이 가지는 제약 사항

![[Pasted image 20240318120923.png]]

MySQL 서버에서 파티션 표현식에는 기본적인 산술 연산자인 `+`, `-`,`*` 같은 연산자만 사용할 수 있으며 아래 내장 함수를 사용할 수 있습니다. 
![[Pasted image 20240319131600.png]]

## 파티션 사용시 주의사항


### 파티션과 유니크 키 (프라이머리 키 포함)
종류와 관계없이 테이블에 유니크 인덱스가 있으면 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 컬럼을 포함해야합니다.

![[Pasted image 20240318122050.png]]
![[Pasted image 20240318122102.png]]
위 예시는 모두 잘못된 테이블 파티션을 생성하는 방법입니다. 
1. 첫 번째 쿼리는 유니크 키와 파티션 키가 전형 연관이 없다.
2. 첫 번째 유니크 키 컬럼인 fd1만으로 파티션 결정이 되지 않는다. 
3. 세 번째 쿼리  또한 두 번째 쿼리와 같이 프라이머리키 컬럼인 fd1값만으로 파티션 판단이 되지 않으며, 유니크 키인 fd2와 fd3로도 파티션 위치를 결정할 수 없다.
![[Pasted image 20240319165557.png | 200]]
### 파티션과 open_files_limit 시스템 변수 설정
MySQL에서는 일반적으로 테이블을 파일 단위로 관리하기 때문에 MySQL 서버에서 동시에 오픈된 파일의 개수가 많아질 수 있습니다.
이를 제한하기 위해 open_files_limit 시스템 변수에 동시에 오픈할 수 있는 적절한 파일의 개수를 설정할 수 있습니다.

파티션되지 않은 일반 테이블은 테이블 1개당 오픈된 파일의 개수가 2~3개 수준이지만 파티션 테이블에서는 파티션의 개수x 2~3개 가 된다. 

# MySQL 파티션의 종류

MySQL에서는 4가지 기본파티션 기법을 제공하고 있습니다.
- 레인지 파티션
- 리스트 파티션
- 해시 파티션
- 키 파티션

## 레인지 파티션
레인지 파티션은 파티션 키의 연속된 범위로 파티션을 정의하는 방법으로 가장 많이 사용하는 방법입니다. 
> MAXVALUE키워드를 이용해  명시되지 않은 범위의 키 값이 담긴 레코드를 저장하는 파티션을 정의할 수 있습니다. 


### 용도
레인지 파티션의 경우 아래의 상황에 주로 사용할 수 있습니다.
- 날짜를 기반으로 데이터가 누적되고 연도나 월, 일 단위로 분석하고 삭제할 때
- 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
- 파티션 키 위주로 검색이 실행될 때


### 레인지 파티션 테이블 생성

![[Pasted image 20240318175004.png]]
- PARTITION BY RANGE 키워드로 레인지 파티션을 정의
- PARTITION BY RANGE 뒤에 컬럼 또는 내장 합수를 이용해 파티션 키를 명시, 사원의 입사 일자에서 연도만을 파티션 키로 사용
- VALUE LESS THAN으로 명시된 값보다 작은 값만 해당 파티션에 저장하게 설정한다.
	- `PARTITION .. values less than n` n보다 작은 값만 포함
- VALUES LESS THAN MAXVALUE로 며이되지 않은 레코드를 저장할 파티션을 지정
- VALUES LESS THAN MAXVALUE가 정의되지 않으면 hired컬럼의 값이 2011-02-30인 레코드가 insert될 때 에러가 발생
- 테이블과 각 파티션은 같은 스토리지 엔진으로 정의, MySQL 8.0부터 InnoDB 스토리지 엔진이 기본 스토리지 엔진


### 레인지 파티션의 분리와 병합
#### 단순 파티션의 추가

테이블에 새로운 파티션을 추가하는 명령어
![[Pasted image 20240318175721.png]]
해당 명령어를 실행하고자 할 때 LESS THAN MAXVALUE로 파티션이 나눠져 있다면 새로운 파티션을 추가할 수 없는 에러가 발생합니다. 
![[Pasted image 20240318175901.png]]
이는 이미 나눠져 있는 파티션과 새로운 파티션이 나눠지며 중복된 저장공간이 발생하면 안되는 기본조건을 지키지 못했기 때문입니다.

![[Pasted image 20240318180024.png]]
이 경우 `ALTER TABLE ... REORGANIZE PARTITION` 명령어를 사용해야 합니다. 

`참고로 해당 명령어는 파티션의 레코드를 모두 새로운 두 개의 파티션으로 복사하는 작업이기 때문에 파티션의 레코드가 매우 많다면 이 작업은 매우 오랜 시간이 걸립니다`
> (궁금)
> 어떻게 파티션을 복사하지?



#### 파티션 삭제
레인지 파티션을 사용하는 테이블에서 파티션을 삭제하려면 `DROP PARTITION` 키워드에 파티션의 이름을 지정하면 됩니다.
![[Pasted image 20240318180413.png]]
주의점
1. 레인지 파티션을 사용하는 테이블에서는 가장 오래된 파티션 순서로만 사제할 수 있습니다.
2. 레인지 파티션을 사용하는 테이블에서는 가장 마지막 파티션만 새로 추가할 수 있고, 가장 오래된 파티션만 삭제할 수 있습니다.



#### 기존 파티션의 분리

하나의 파티션을 두 개 이상의 파티션으로 분리하고자 할 때는 `REORGANIZE PARTITION`  명령어를 사용하면 됩니다. 
![[Pasted image 20240318180636.png]]


#### 기존 파티션의 병합
![[Pasted image 20240318181122.png]]


## 리스트 파티션

리스트 파티션은 레인지 파티션과 많은 부분 흡사하지만 둘의 가장 큰 차이는 레인지 파티션은 파티션 키 값의 범위로 파티션을 구성할 수 있지만 리스트 파티션은 파티션 키 값  하나하나를 리스트로 나열합니다. 


### 리스트 파티션의 용도
- 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
- 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때

### 리스트 파티션 테이블 생성
![[Pasted image 20240318181749.png]]
![[Pasted image 20240318181757.png]]
- `PARTITION BY LIST` 리스트 파티션임을 명시
- `PARTITION BY LSIT` 키워드 뒤에 파티션 키를 정의
- `VALUES IN (...)`을 사용해 파티션별로 저장할 파티션 키 값의 목록을 나열
- 파티션별로 NULL을 생성할 수 있음
- 레인지 파티션과 달리, 나머지 모든 값을 저장하는 MAXVALUE 파티션은 정의할 수 없음

### 리스트 파티션의 분리와 병합
파티션을 정의하는 부분에서 VALUES LESS THAN이 아닌 VALUES IN을 사용하는 것 외에 레인지 파티션의 추가 및 삭제 병합 작업이 모두 같습니다. 


### 리스트 파티션 주의사항
- 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파티션을 정의할 수 없습니다.
- 레인지 파티션과는 달리 NULL을 저장하는 파티션을 별도로 생성할 수 있습니다. 


## 해시 파티션
해시 파티션은 MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법입니다. 
MySQL에서 정의한 해시 함수는 복잡한 알고리즘이 아닌 파티션 표현식의 결괏값을 파티션의 개수로 나눈 나머지로 저장될 파티션을 결정하는 방식입니다. 


### 용도
- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 떄

### 생성

![[Pasted image 20240319153942.png]]
![[Pasted image 20240319153950.png]]
- PARTITION BY HASH 키워드로 파티션 종류를 해시 파티션으로 지정
- PARTITION BY HASH 키웓 뒤에 파티션 키를 명시
- 해시 파티션의 파티션 키 또는 파티션 표현식은 반드시 정수 타입의 값을 반홚
- PARTITIONS n으로 몇 개의 파티션을 생성할 것인지 명시
### 해시 파티션의 분리와 병합
해시 파티션의 분리와 병합은 리스트 파티션이나 레인지 파티션과 달리 대상 테이블의 모든 파티션에 저장된 레코드를 재분배하는 작업이 필요합니다.

파티션의 분리나 병합으로 인해 파티션의 개수가 변경된다는 것은 해시 함수의 알고리즘을 변경하는 것으로 전체 파티션이 영향을 받는 것은 피할 수 없습니다.


#### 해시 파티션 추가
- 해시 파티션은 특정 파티션 키 값을 테이블 파티션 개수로 MOD 연산한 결괏값에 의해 각 레코드가 저장될 파티션을 결정합니다. 
- 해시 파티션은 테이블에 존재하는 파티션의 개수에 의해 파티션 알고리즘이 변한다.
- 따라서 새로운 파티션이 추가된다면 기존의 각 파티션에 저장된 모든 레코드가 재배치돼야 한다.
- 아래 예시에서 파티션을 새로 추가하면 별도의 영역이나 범위 명시 없이 파티션 추가의 개수를 지정할 수 있습니다.
![[Pasted image 20240319154210.png]]
- 해시 파티션이 사용되는 테이블에 새로운 파티션을 추가하면 기존의 모든 파티션에 저장돼 있던 레코드를 새로운 파티션으로 재분배하는 작업이 발생한다.
- 해시 파티션에서 파티션을 추가하는 작업은 INPLACE알고리즘으로 실행된다고 핟라도 테이블 리빌드 작업이 필요하며 테이블에 대하 읽기 잠금이 발생할 수 있기 때문에 해시 파티션에서 파티션을 추가하거나 생성하는 작업은 많은 부하를 발생시키며, 트랜잭션에서 동일 테이블에 데이터 변경작업을 허용하지 않습니다.

![[Pasted image 20240319154303.png]]

#### 해시 파티션 삭제
해시 파티션이나 키 파티션을 사용한 텓이블에서 파티션 단위로 데이터를 삭제하는 작업은 의미가 없다.
-> 파티션 키 값을 가공해서 ㄷ제이터를 각 파티션으로 분산했기 떄문 어떤 데이터가 저장될 지 사용자는 예상할 수 없다.

#### 해시 파티션 분할
해시나 키 파티션은 파티션 단위로 레코드를 분할하는 방법이 없습니다.

#### 해시 파티션 병합

해시나 키 파티션은 2개 이상의 파티션을 하나의 파티션으로 통합하는 기능을 제공하지 않습니다. 단지 파티션의 개수를 줄이는 것만 가능하며, `COALESCE PARTITION` 명령어를 사용하면 됩니다.

명령어 자체로만 보면 파티션을 통합하는 것처럼 보이지만 원래 파티션 4개로 구성된 테이블에 다음 명령이 실행되면 3개의 파티션을 가진 테이블로 다시 재구성하는 작업이 수행된다. 

![[Pasted image 20240319155721.png]]
`CLLAESCE PARTITION` 뒤에 명시한 숫자 값은 줄이고자 하는 파티션의 개수를 의미
- 4개의 파티션을 사용하고 있다면 3개만 사용하도록 변경
![[Pasted image 20240319155833.png]]

#### 해시  파티션 주의사항
- 특정 파티션만 삭제하는 것은 불가능
- 새로운 파티션을 추가하는 작업은 단순히 파티션만 추가하는 것이 아닌 기존 모든 데이터의 재배치 작업이 필요함
- 해시 파티션은 레인지 파티션이나 리스트 파티션과는 상당히 다른 방식으로 관리하기 때문ㅇ 파티션이 용도에 적합한 해결책인지 확인이 필요
- 
## 키 파티션
- 키 파티션은 해시 파티션과 사용법과 특성이 비슷함
- 해시 파티션은 해시 값을 계산하는 방법을 파티션 키나 표현식에 사용자가 명시한다.
- MySQL 서버가 그 값을 다시 MOD연산을 수행해서 최종 파티션을 결정하기는 하지만 말이다.

- 키 파티션에서는 해시 값의 계산도 MySQL 서버가 수행한다. 키 파티션에서는 정수  타입이나 정숫값을 반환하는 표현식뿐만 아니라 대부분의 데이터 타입에 대해 파티션 키를 적용할 수 있습니다.

![[Pasted image 20240319003744.png | 600]]
- PARTITION BY KEY 키워드로 파티션을 정의
- PARTITION BY KEY 키워드 뒤에 파티션 키 컬럼을 명시
- 첫 번째, 두 번째 예제에서 PARITION  BY KEY에 아무 컬럼도 명시하지 않으면 MySQL 서버가 자동으로 프라이머리 키나 유니크 키의 모든 컬럼을 파티션 키로 선택
- 테이블에 프라이머리 키가 있다면 프라이머리 키의 모든 컬럼으로, 프라이머리 키가 없는 경우에는 유니크 인덱스의 모든 컬럼으로 파티션 키를 구성 
- 세 번째 예제 쿼리에서는 프라이머리 키나 유니크 키를 구성하는 컬럼 중에서 일부만 파티션 키로 명시하는 것이 가능
- PARTITIONS 키워드로 생성할 파티션 개수를 지정


### 키 파티션 주의사항 및 특이사항
- 키 파티션은 MySQL 서버가 내부적으로 MD5함수를 이용해 파티션하기 떄문에 키가 반드시 정수 타입이 상관없음
- 프라이머리 키나 유니크 키를 구성하는 컬럼 중 일부만으로 파티션 가능 
- 유니크 키를 파티션 키로 사용할 때 유니크 키는 반드시 NOT NULL
- 해시 파티션에 비해 파티션 간의 레코드를 더 균등하게 분할할 수 있기 때문에 키 파티션이 더 효율적
## 리니어 해시 파티션/ 리니어 키 파티션
해시 파티션이나 키 파티션은 새로운 파티션을 추가하거나 파티션을 통합해서 개수를 줄일 때 대상 파티션만이 아니라 테이블 전체 파티션에 저장된 레코드의 재분배 작업이 발생

이런 문제를 최소화하기 위해 리니어 해시 파티션/리니어 키 파티션 알고리즘이 등장.
리니어 해시 파티션/리니어 키 파티션은 각 레코드 분배를 위해 `Power-of-two`(2의 승수)알고리즘을 사용해 파티션의 추가나 통합 시 파티셔네 미치는 영향을 최소화 함

### 리니어 해시 파티션/리니어 키 파티션의 추가 및 통합
- 리니어 해시 파티션이나 리니어 키 파티션의 경우 단순히 나머지 연산으로 레코드가 저장될 파티션을 결정하는 것이아닌 `power-of-two` 분배 방식을 사용하기 때문에 파티션의 추가나 통합 시 특정 파티션의 데이터에 대해서만 이동 작업을 하면 됩니다.

#### 리니어 해시 파티션/리니어 키 파티션의 추가
- 리니어 해시 파티션이나 리니어 키 파티션에 새로운 파티션을 추가하는 명령은 일반 해시 파티션이나 키 파티션과 동일
- 하지만 리니어 해시 파티션, 리니어 키 파티션은 `Power-of-two` 알고리즘으로 레코드가 분배돼 있기 때문에 새로운 파티션을 추가할 때도 아래 그림 처럼 특정 파티션의 레코드만 재분배되면 됩니다. 

![[Pasted image 20240319100050.png]]


#### 리니어해시 파티션/리니어 키 파티션의 통합
- 리니어 해시 파티션이나 키 파티션에서 여러 파티션을 하나의 파티션으로 통합하는 작업 또는 새로운 파티션을 추가할 때와 같이 일부 파티션에 대해서만 레코드 통합 작업이 필요합니다.
- 아래 그림 처럼 통합되는 파티션만 레코드 이동이 필요하며, 나머지 레코드는 레코드 재분배 작업에서 제외됩니다.

![[Pasted image 20240319100348.png]]




---

## 문제

1. 워킹 셋이 무엇인가요?
2. MySQL에서는 테이블 파티션 단위 인덱스 생성 기능을 지원한다 (O, X)
3. a
4. 범위 조건에 사용할 수 있는 타입 (int, varchar,date,datetime)