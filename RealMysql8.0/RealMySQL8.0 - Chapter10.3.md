---
cssclasses:
  - my_style_width_100
aliases:
---
## rows

MySQL 실행 계획의 rows 컬럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다. 

rows 컬럼은 몇 가지 주의 할 점이 있습니다.
1.  각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출한 예상값으로 정확하지 않습니다. 
2.  표시되는 값은 반환하는 레코드의 예측치가 아닌 ==쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미합니다== 
3.  실행 계획의 rows 컬럼에 출력되는 값과 실제 쿼리 결과 반환된 레코드 건수는 일치하지 않는 경우가 많습니다. 


![[Pasted image 20240120195037.png]]
위 쿼리는 `from_date >= 1985-01-01` 조건을 만족하는 레코드를 검색하는 쿼리입니다.

해당 쿼리는 ix_fromdate 인덱스를 이용해 처리할 수 있지만 풀 테이블 스캔을 선택했습니다.
![[Pasted image 20240120195242.png]]

이는 전체 테이블 레코드의 건수는 33만건이고 실행 계획에서 나온 결과와 비교했을 때 거의 차이가 없는 것을 알 수 있습니다.
결국 인덱스를 사용하는 것 보다 풀테이블 스캔을 활용하는 것이 더 낫다고 옵티마이저가 선택한 것입니다.

![[Pasted image 20240120195526.png]]
![[Pasted image 20240120201259.png]]
위 쿼리 실행 계획을 보면 MySQL 옵티마이저는 대략 292건의 레코드만 읽고 쳌해 보면 원하는 결과를 가져올 수 있을 것으로 예측했습니다.  더 나아가 이전 쿼리와 달리 풀 테이블 스캔이 아닌 range로 인덱스 스캔을 사용했다는 것 또한 알 수 있습니다.

이는 옵티마이저가 from_date 컬럼의 값이 위 조건을 만족하는 경우를 292건만 존재할 것으로 예측했고, 전체 테이블 건수와 비교하면 8.8% 밖에 되지 않습니다. 

최종적으로 옵티마이저는 ix_fromdate 인덱스를 range 방식으로 처리한 것입니다.


### 정리
결국 row 컬럼은 옵티마이저가 해당 테이블의 실행 계획의 효율성 판단을 위해 예측치며 표현된 값은 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미합니다.


## filtered 컬럼

옵티마이저는 각 테이블에서 일치하는 레코드 개수를 가능하면 정확히 파악해야 좀더 효율적인 실행 계획을 수립할 수 있습니다.

대부분의 쿼리에서 where절에 사용되는 조건이 모두 인덱스를 사용할 수 있는 것은 아닙니다.

특히 조인이 사용되는 경우에는 where절에서 인덱스를 사용할 수 있는 조건도 중요하지만 인덱스를 사용하지 못하는 조건에 일치하는 레코드 건수를 파악하는 것도 매우 중요합니다.

> 책 예시 실행 결과가 다름

![[Pasted image 20240120205346.png]]

### 정리
filtered 컬럼의 값은 필터링되어 버려지는 레코드의 비율이 아닌 필터링되고 남은 레코드의 비율을 의미한다.

# Extra zjffja
