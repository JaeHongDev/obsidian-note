---
cssclasses:
  - my_style_width_100
---
# Group by

##  정의
group by는 특정 컬럼의 값으로 그루핑하고, 그룹별로 집계된 레코드를 하나의 레코드로 조회할 때 사용합니다. (group by에 대한 1줄 정리)


## With ROLLUP

group by가 사용된 쿼리에서는 그룹별로 소계를 가져오는 ROLLUP기능이 존재합니다.

> 💡ROLLUP
>  주로 데이터 처리나 프로그래밍에서 사용되는 기능으로 여러 항목을 하나로 요약하거나 통합하는 것입니다.


![[Pasted image 20240218214044.png|600 ]]

여기서 소계로 사용되는 컬럼은 dept_no만 존재하기 때문에 하나만 null로 표시됩니다. 만약 group by에 사용되는 컬럼의 수가 늘어나면 마찬가지로 늘어납니다.

여기서 소계로 표현되는 컬럼의 값은 null로 표시되는데 MySQ 8.0에서는 `IF(grouping(column))` 문법을 활용해서 이를 해결할 수 있습니다
![[Pasted image 20240218214844.png | 600]]


## 레코드를 컬럼으로 변환

group by의 결과는 레코드 단위로 표현됩니다. 하지만 레코드 단위가 아닌 컬럼 단위로 해당 값을 표현해줘야 할 때가 있습니다.
이는 엑셀의 피벗과 같은 개념이지만 MySQL에서는 지원하는 기능은 아니기 때문에 별도의 구현이 필요합니다.
![[Pasted image 20240218215916.png | 600 ]]
레코드를 컬럼으로 변환하는 것 뿐만 아니라 하나의 레코드를 여러 값으로 표현할 수 있습니다.

![[Pasted image 20240218225242.png | 600]]

# Order by

order by는 검색된 레코드의 결과를 조건에 따라 정렬 해주는 것을 의미합니다.

order by를 통해 정렬된 쿼리는 임시 테이블에 저장되면 실행 계획에서 using filesort로 명시됩니다. 단 실제로 정렬을 위해서 임시 파일을 사용했는지 확인하려면![[Pasted image 20240218225659.png || 600]]
해당 명령어를 통해서 확인하면 된다. 확인된 결과에 따라서 임시 파일을 자주 사용하게 된다면 정렬에 사용되는 메모리 사이즈를 늘리는 방법을 통해 최적화가 가능하다.

## Order by 사용시 주의점

order by를 사용한 쿼리에서 order by 절에 사용된 컬럼이 리터럴 문자열의 경우 옵티마이저가 이를 무시한다. 
상수로 표현된 경우는 select 절의 컬럼의 인덱스로 지정해서 컬럼 대신 사용 가능하다.
![[Pasted image 20240218230145.png |600]]


## order by에서 사용하는 함수

order by에서 컬럼에 특정 함수를 적용해서 정렬하는 것이 가능합니다. 이는 인덱스를 사용할 수 없습니다. 단 8.0부터 추가된 가상 컬럼을 적용하면 인덱스를 적용할 수 있습니다.


# 서브쿼리

먼저 서브쿼리는 쿼리 내에서 사용하는 다른 쿼리입니다. select, from, where 절에서 사용할 수 있습니다. 하지만 사용하는 위치에 따라 서브쿼리의 성능이 문제 될 수 있기 떄문에 주의해서 사용해야 합니다.

## Select 절에 사용된 서브쿼리

먼저 select 절에 사용된 서브쿼리는 내부적으로 임시테이블을 만들거나 쿼리를 비효율적으로 실행하지 않습니다. 이는 결과값을 하나만 만들어내는 스칼라 서브쿼리이기 때문입니다.

단 Select 절에 서브쿼리를 사용할 때 지켜야 할 주의점이 있습니다.
1. 서브쿼리 결과 레코드 건수가 0이라면 표시되는 레코드는 NULL입니다.
2. 서크쿼리 결과 레코드 건수가 2건 이상이라면 에러가 발생합니다.
3. 서브쿼리 결과 레코드가 1건이라고 하더라도 컬럼의 개수가 2건이라면 에러가 발생합니다.

정리하면 Select 절에서 사용되는 서브쿼리는 로우 서브쿼리가 아닌 스칼라 서브쿼리만 사용이 가능합니다.


## From 절에 사용된 서브쿼리

From 절에서 사용된 서브쿼리의 경우 5.7 버전 이전에는 임시 테이블을 만들어서 결과를 저장하고 나중에 읽어오는 방식으로 처리됐지만 현재는 옵티마이저가 외부쿼리와 병합하는 형태를 사용하도록 하고  있습니다.
하지만 외부쿼리와 병합이 안되는 경우가 있기 때문에 그부분에 있어 주의해야 합니다.
1. 집합 함수 (SUM, MIN, MAX, COUNT)
2. DISTINCT
3. LIMIT
4. UNION, UNION ALL
5. Select 절에 서브쿼리가 사용된 경우
6. 사용자 변수 사용

## Where 절에 사용된 서브쿼리
Where절의 서브쿼리는 다음 세 가지 형태로 사용됩니다.
- 동등 비교 대소 비교
- IN 비교
- Not In 비교


### 동등, 대소 비교

MySQL 5.5 이전 버전까지는 서브쿼리 외부의 조건으로 쿼리를 실행하고, 최종적으로 서브쿼리를 체크 조건으로 사용했습니다. 

MySQL 5.5 버전 부터는 쿼리의 실행 계획은 서브 쿼리를 먼저 실행한 후 상수로 변환하도록 변경됐습니다. 
![[Pasted image 20240220000222.png |600]]


### IN 비교

실제 조인은 아니지만 테이블의 레코드가 다른 테이블의 레코드를 이용한 표현식과 일치하는지를 체크하는 형태를 세미조인이라고 합니다.


![[Pasted image 20240220000436.png |600]]

MySQL 5.5버전까지는 세미조인에 대한 최적화 지원이 빈약했지만 현재는 5개의 최저고하 전략을 지원함
- 테이블 풀 아웃
- 퍼스트 매치
- 루스 스캔
- 구체화
- 중복 제거

### NOT IN 비교

IN와 비슷한 형태지만 이 경우를 안티 세미지 조인이라고 표현합니다. 일반적으로 Not-EQUAL 비교는 인덱스를 제대로 활용할 수 없기 때문에 
- Not EXISTS
- 구체화 
2개의 최적화 전략을 짇원하비다.


# CTE (common TAble Expression)
CTE는 이름을 가지는 임시 테이블로 SQL 문장 내에서 한 번 이상 사용될 수 있으며 SQL 문장이 종료되면 자동으로 CTE 임시 테이블은 삭제됩니다.

CTE는 재귀적 반복 실행 여부를 기준으로 
- Non-recursive
- Recursive 
로 구분됩니다. 

![[Pasted image 20240220000824.png| 600]]

## 비 재귀적 CTE 

MySQL 서버에서는 ANSI 표준을 그대로 이용해서 WITH 절을 이용해 CTE를 정의합니다. 

![[Pasted image 20240220001106.png|600]]

### 여러 개의 임시테이블을 만드는 사용법
![[Pasted image 20240220002035.png|600]]


### CTE를 이용한 쿼리의 실행 계획

![[Pasted image 20240220002224.png]]
![[Pasted image 20240220002351.png]]
위는 CTE를 활용한 쿼리의 실행 계획이고 아래는 FROM 절의 서브쿼리를 활용한 실행 계획입니다.

CTE를 사용한 경우 임시테이블을 한 번만 생성하지만 FROM 절의 서브쿼리를 이용한 쿼리에서는 2개의 임시 테이블을 생성한 것을 알 수 있습니다.

즉 CTE를 재귀적으로 사용하지 않더라도 기존 FROM 절에 사용되던 서브쿼리에 비해 아래의 장점이 있습니다.
1. CTE 임시 테이블은 재사용 가능
2. CTE로 선언된 임시 테이블을 다른 CTE 쿼리에서 참조할 수 있다.
3. CTE는 임시 테이블의 생성 부분과 사용 부분의 쿼드를 분리할 수 있기에 가독성이 높다. 

## 재귀적 CTE
재귀 쿼리는 MySQL 8.0부터 추가된 기능입니다. 

![[Pasted image 20240220002738.png | 600]]

위 쿼리는 두 가지 파트로 나눌 수 있습니다. 
- select 1 -> 비 재귀적 파트
- select (no + 1) from no < 5 재귀적 파트

여기서 이야기하는 비 재귀적 파트는 처음 한 번만 실행되지만 재귀적 파트는 쿼리 결과가 없을 때 까지 반복 실행됩니다.

1. CTE 쿼리의 비 재귀적 파트의 쿼리를 실행
2. 1번의 결과를 이용해 cte라는 임시 테이블 생성
3. 1번의 결과를 cte 임시 테이블에 저장
4. 1번 결과를 입력으로 사용해 cte 쿼리의 재귀적 파트의 쿼리를 실행
5. 4번의 결과를 cte라는 임시 테이블에 저장
6. 전 단계의 결과를 입력으로 사용해 cte 쿼리의 재귀적 파티 쿼리 실행
7. 6번 단계에서 쿼리 결과가 없으면 cte 쿼리 종료
8. 6번 의 결과를 cte 라는 임시테이블에 저장
9. 6번으로 돌아가서 반복 실행

![[Pasted image 20240220004637.png|]]

1번 과정이 생각보다 중요한데 CTE 임시 테이블의 구조가 결정되기 떄문입니다.
즉 비 재귀적 쿼리 파트에서 임시 테이블의 구조를 준비하고, 재귀적 쿼리 파트에서는 이후 데이터를 생성해내는 역할을 합니다. 


재귀의 문제점은 데이터의 오류나 작성자의 실수로 인한 무한 반복입니다.
MySQL 서버는 cte_max_recursion_depth 시스템 변수를 이용해 최대 반복 실행 횟수를 제한할 수 있습니다.

기본값이 1000이지만 실제로 너무 큰 값이기 때문에 줄인 다음 필요에 따라 사용자 변수로 늘리는 것이 좋습니다
![[Pasted image 20240220005449.png]]


## 재귀적 CTE 활용

재귀적 CTE 쿼리는 


# 윈도우 함수
윈도우 함수는 조회하는 현재 레코드를 기준으로 연관된 레코드 집합의 연산을 수행합니다. 
집계 함수는 주어진 그룹별로 하나의 레코드로 묶어서 출력하지만 윈도우 함수는 조건에 일치하는 레코드 건수는 변하지 않고 그대로 유지하는 것 입니다.
> 문제1.
> 윈도우 함수와 집계함수의 차이점은?


## 쿼리 각 절의 실행 순서

윈도우 함수를 사용하는 쿼리의 결과에 보여지는 레코드는 from 절과 where절, group by와 having 절에 의해 결정되고, 그 이후 윈도우 함수가 실행됩니다.
![[Pasted image 20240220015949.png]]


생각보다 순서가 많이 중요합니다.

![[Pasted image 20240220112752.png]]

위 쿼리는 전체에서 사번이 1001명인 사람들을 조회하는 쿼리입니다.

![[Pasted image 20240220112924.png]]
반면 현재 쿼리는 사번이 1001명인 사람들 중에서 먼저 상위 5명을 조회한 다음 평균을 구한 쿼리입니다.

실제 쿼리의 실행순서가 다르기 때문에 동작원리를 잘  파악해야 합니다.

## 윈도우 함수 기본 사용법

윈도우 함수는 집계 함수와 달리 함수 뒤에 over절을 이용해 연산 대상을 파티션하기 위한 옵션을 명시할 수 있으며 over절에 의해 만들어진 그룹을 파티션 또는 윈도우라고 합니다.

![[Pasted image 20240220114216.png]]
위 쿼리는 입사 순서 순서를 조회합니다. 여기서 부서별로 입사 순위를 매기고자 하면
![[Pasted image 20240220114414.png]]
위와 같이 parition by column_name order by column으로 실제 활용할 수 있습니다.


윈도우 함수의 각 파티션 안데서도 연산 대상 레코드별로 연산을 수행할 소그룹이 사용되는데 이를 프레임이라고 합니다. 

> 프레임의 정의(definition)
```
AGGREGATE_FUNC() OVER(<partition> <order> <frame>) AS 

window_func_columnframe:  {ROWS | RANGE} {
frame_start | frame_between
}

frame_between:  BETWEEN frame_start AND frame_end


frame_start, frame_end: { 
CURRENT ROW  
| UNBOUNDED PRECEDING  
| UNBOUNDED FOLLOWING  
| expr PRECEDING  
| expr FOLLOWING
}
```

프레임을 만드는 기준 
- rows: 레코드의 위치를 기준으로 생성
- range: order by절에 명시된 컬럼을 기준으로 값의 범위 생성

프레임의 시작과 끝을 의미하는 키워드
- current row: 현재 레코드
- unbounded preceding: 파티션의 첫 번째 레코드
- unbounded pollowing: 파티션의 마지막 레코드
- expr preceding: 현재 레코드로부터 n번째 이전 레코드
- expr following: 현재 레코드로부터 n번쨰 이후 레코드

rows와 range에 따라 변경되는 것은 expr이 위치한 부분인데 rows로 설정하면 레코드의 위치를 명시하고 Range로 구분되면 컬럼과 비교할 값이 서정돼야 하빈다.
- 10 preceding: 현재 레코드로부터 10건 이전까지

프레임 절
- ROWS UNBOUNDED PRECEDING: 파티션의 첫 번째 레코드로부터 현재 까지
- ROWS BETWEEN UNBOUND PRECEDING AND CURRENT ROW: 파티션의 첫 번째 레코드로부터 현재 레코드까지
- ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING: 파티션에서 현재 레코드를 기준으로 앞 레코드부터 뒤 레코드까지
- RANGE INTERVAL 5 DAY PRECEDING: Order by에 명시된 컬럼의 값이 5일 전인 레코드부터 현재까지


## 윈도우 함수
서버의 운도우 함수에는 집계함수와 비집계함수가 있습니다.

집계 함수는 over 절 없이 단독으로 사용될 수 있고 over절을 가진 윈도우 함수로 사용할 수 있습니다.
![[Pasted image 20240220123207.png]]![[Pasted image 20240220123221.png]]


# 잠금을 사용하는 select 

InnoDB테이블에 대해서는 레코드를 select할 때 레코드에 아무런 잠금도 걸지 않는데, 이를 잠금 없는 읽기라고 합니다. 하지만 SELECT 쿼리를 이용해 읽은 레코드의 컬럼값을 애플리케이션에서 가공해서 다시 업데이트하고자 할 때는 select가 실행된 