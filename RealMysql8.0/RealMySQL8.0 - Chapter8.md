---
cssclasses:
  - my_style_width_100
---

인덱스는 데이터베이스 쿼리의 성능을 언급하면서 빼놓을 수 없는 부분이다.
-> 맞음

> ⚠ 학습 목표 
> 쿼리의 개발 튜닝을 설명하기 전 MySQL에서 사용 가능한 인덱스의 종류 및 특성을 학습함


인덱스의 특성과 차이는 물리 수준의 모델링을 활 때도 중요한 요소가 된다.
> 저자는 인덱스에 대한 기본 지식은 쿼리 튜닝의 기본이 된다고 설명함.


# 디스크 읽기 방식

사용된 키워드
- 랜덤 I/O
- 순차 I/O

컴퓨터의 CPU나 메모리처럼 전기적 특성을 띤 장치의 성능은 짧은 시간 동안 매우 빠른 속도로 발전했지만 디스크 같은 기계식 장치의 성능은 상당히 제한적으로 발전했다.
최근에는 자기 디스크 원판에 의존하는 하드 디스크가 아닌 SSD 드라이브가 많이 활용되고 있지만, 여전히 데이터 저장 매체는 컴퓨터에서 가장 느린 부분이라는 사실에는 변함이 없다 

데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 대가 상당히 많다.
-  데이터 저장 매체는 컴퓨터에서 가장 느린 부분이기 때문
-  전기적 특성을 띤 장치인 CPU, 메모리는 빠르게 발전했지만 디스크 같은 기계식 장치는 제한적으로 발전함.
- SSD가 나왔지만 그래도 느린 편임


## 하드 디스크 드라이브(HDD) 와 솔리드 스테이트 드라이브(SSD)
컴퓨터에서 CPU나 메모리 같은 주요 장치는 대부분 전자식 장치지만 하드 디스크 드라이브는 기계식 장치다. 
그래서 데이터베이스 서버에서는 항상 디스크 장치가 병목이 된다.
-> 기계식 장치이기 때문에 병목이 발생하는 건가요?
-> 이러한 기계식 하드 디스크 드라이브를 대체하기 위해 전자식 저장 매체인 SSD가 많이 출시되고 있습니다.


SSD는 기존 하드 디스크 드라이브에서 데이터 저장용 플래터(원판)를 제거하고 그 대신 플래시 메모리를 장작하고 있습니다.
- 원판을 회전시킬 필요가 없기 때문에 데이터를 빠르게 읽고 쓸 수 있다.
- 물리적인 삭제가 발생하지 않는다. ( 이거 맞나? )
- 컴퓨터 메모리 보다 느리지만 기계식 하드 디스크 드라이브보다는 훨씬 빠르다.

디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 하드 디스크 드라이브보다 조금 빠르거나 거의 비슷한 성능을 보이기도 한다. 
하지만 SSD의 장점은 기존 하드 디스크 드라이브보다 랜덤 I/O가 훨씬 빠르다는 것이다.
데이터베이스 서버에서 순차 I/O 작업은 그다지 비중이 크지 않고 랜덤 IO를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로 SSD의 장점은 DBMS용 스토리지에 최적이라고 볼 수 있다.

일반적인 웹 서비스 환경의 데이터베이스에서는 SSD가 하드 디스크드라이브 보다는 훨씬 빠르다.


## 랜덤 I/O와 순차 I/O
https://hudi.blog/storage-and-random-sequantial-io/

랜덤 I/O라는 표현은 하드 디스크 드라이브의 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미합니다. 
순차 I/O도 디스크 헤더를 이동시켜 데이터를 읽는 방식은 동일하다.

순차 I/O는 3개의 페이지(3x16kb)를 디스크에 기록하기 위해 1번 시스템 콜을 요청했지만, 랜덤 I/O는 3개의 페이지 디스크에 기록하기 위해 3번 시스템 콜을 요청했다. 
즉, 디스크에 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 1번 움직였고, 랜덤 I/O는 디스크 헤드를 3번 움직였다.
-> <u>디스크에 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.</u>
그래서 순차 IO는 랜덤 IO보다 3배 빠르다고 할 수 있다.
-> 디스크의 성능은 디스크의 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다고 볼 수 있다.
-> 여러 번 쓰기 또는 읽기를 요청하는 랜덤 IO 작업이 작업 부하가 훨씬 더 크다.
-> 이런 문제점을 최소한으로 하기 위해 그룹 커밋, 바이너리 로그 버퍼, InnoDB 로그 버퍼 등의 기능이 내장돼 있다.



# 인덱스

책을 보면 맨끝에 색인이 존재합니다. 책 에서 필요한 내용을 쉽게 찾기 위한 장치로 초성으로 정렬돼 있는 것이 특징입니다.
마찬가지로 DBMS의 인덱스는 데이터베이스 테이블의 데이터 검색을 쉽게 하기 위한 장치로 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 만들어집니다.

인덱스의 특징을 보기 앞서 다음 세 자료구조를 봐야 합니다.
- SortedList 
	- DBMS의 인덱스와 같은 자료 구조입니다.
	- 저장되는 값을 항상 정렬된 상태로 유지하는 자료 구조
- ArrayList
	- ArrayList는 데이터 파일과 같은 자료구조로 사용됩니다.
	- 값을 저장되는 순서 그대로 유지하는 자료 구조


SortedList의 장단점을 통해 인덱스의 장단점을 확인해보겠습니다.
- 단점
	- 데이터가 저장될 때 마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느립니다. (SortedList)
	- 인덱스가 많은 테이블은 `INSERT` `UPDATE` `DELETE` 문장의 처리가 느려집니다. (인덱스)
- 장점 
	- 이미 정렬된 상태이기 때문에 원하는 값을 빠르게 찾아올 수 있습니다. (SortedList)
	- 이미 정렬된 표(인덱스)를 가지고 있기 때문에 `SELECT` 문장은 매우 빠르게 처리할 수 있습니다. (인덱스)

결국 DBMS에서 인덱스는 <u>데이터의 저장 성능을 희생하는 대신 데이터의 읽기 속도를 높이는 기능입니다.</u>
그렇기 때문에 테이블의 인덱스 추가를 고려 할 때  <u>데이터의 저장 속도를 어디까지 희생할지, 읽기 속도를 얼마나 더 빠르게 할지 결정해야 합니다.</u>
또한 `SELECT` 쿼리의 `WHERE` 조건절에 사용하는 컬럼이라고 해서 전부 인덱스로 생성하는 것은 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해지는 문제점이 발생합니다.




> ⚠ 이 책에서는 키 라는 말과 인덱스는 같은 의미로 사용함

인덱스는 데이터를 관리하는 방식, 중복 값 허용 여부에 등에 따라 여러 가지로 나눌 수 있습니다.
먼저 인덱스를 역할별로 구분하면 `프라이머리 키`와 `보조 키`로 구분할 수 있습니다.
- [[프라이머리 키 (Primary Key)]]
- [[보조 키(Secondary Key)]]

데이터 저장 방식(알고리즘)별로 구분할 경우 `B-Tree` 인덱스와 `Hash` 인덱스로 구분할 수 있습니다. 
- [[B-Tree 알고리즘]]
- [[Hash 인덱스 알고리즘]]

데이터의 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다.
- 유니크 인덱스(Unique index)
- 유니크 하지 않은 인덱스 (Non-Unique index)

그 외 기능 인덱스의 기능별로 분류하면 전문 검색용 인덱스, 공간 검색용 인덱스 등이 있습니다.


# B-Tree 인덱스

B-Tree는 데이터베이스 인덱싱 알고리즘 가운데 가장 일반적이며 현재 가장 범용적인 목적으로 사용되는 인덱스 알고리즘입니다.
DBMS에서 사용하는 인덱스 알고리즘은 B-Tree를 변형한 B+-Tree, B*-Tree(B star tree)가 있습니다.
B-Tree는 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.


## 구조 및 특성

B-Tree는 트리 구조로 최상위에 하나의 루트 노드가 존재하고 하위에 자식 노드가 붙어 있는 형태입니다.
트리 구조에서 가장 하위에 있는 노드를 리프 노드라 하고, 루트 노드도 아니며 리프 노드도 아닌 중간의 노드를 브랜치 노드라고 합니다.
인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있습니다.
![[Pasted image 20231208164309.png]]


> ⚠ 참고
> 
> 데이터 파일의 레코드는 Insert된 순서대로 저장되는 것은 아니다.
> 만약 테이블의 레코드를 전혀 삭제하거나 변경하지 않고 INSERT만 수행한다면 맞을 수 있도 있다.
> 하지만 레코드가 삭제되어 빈 공간이 생기면 그다음의 INSERT는 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계되기 때문에 항상 INSERT된 순서로 저장되는 것은 아니다.

인덱스의 키 값으로 모두 정렬 되어 있지만 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.
- 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
- 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다.


![[Pasted image 20231208192438.png]]

- InnoDB 테이블의 인덱스의 데이터 파일의 관계를 보여주는데, InnoDB 스토리지 엔진을 사용하는 테이블에서는 프라이머리 키가 ROWID의 역할을 한다.
- 두 스토리지 엔진의 인덱스에서 가장 큰 차이점은 세컨드리 인덱스를 통해 데이터 파일의 레코드를 찾아가는 방법에 있다.
- InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.
- InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
- InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다. 

