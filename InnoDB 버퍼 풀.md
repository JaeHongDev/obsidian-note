---
cssclasses:
  - my_style_width_100
---

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간입니다.
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할
- DML의 경우 데이터를 변경하는 쿼리는 여러 위치의 데이터 파일을 변경하기 때문에 랜덤한 디스크 작업을 발생시키는데 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.
	- 그러면 UPDATE, UPDATE, UPDATE 이렇게 처리되는 상황에서 순서대로 처리되는게 아니라는 거야..?

디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
- 왜 캐시할까요?
- 캐시한다면 지우는 시점은 언제인가요?

### 장점이라고 판단한 개인적인 이유
1. 버퍼를 따로 두기 때문에 I/O가 빈번하게 발생하는 것을 줄일 수 있음


### 버퍼 풀의 크기 설정

버퍼 풀의 크기를 설정할 때는 운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려해서 설정해야 합니다.
- MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없ㄱ지만 아주 독특한 경우 레코드 버퍼가 상당한 메모리를 사용하기도 합니다.


레코드 버퍼는 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간.
케넥션이 많고 사용하는 테이블이 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 많이 필요해질 수 있습니다.
> 커넥션이 많아지면 버퍼가 많이 필요함 (당연)
- MySQL 서버가 사용하는 레코드 버퍼 공간은 별도로 설정할 수 없음
- 전체 커넥션 개수와 각 커네겻ㄴ에서 읽고 쓰는 테이블의 개수에 따라서결정
- 버퍼 공간은 동적으로 해제되기도 하므로 정확히 필요한 메모리 공간의 크기를 계산할 수 없다.
-> 레코드 버퍼 공간 설정은 쉽지 않다.

MySQL 5.7버전부터는 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있다. 
가능한 InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정하고 상황을 봐 가면서 증가시키는 방법이 최적
-> 어떤 상황을 봐야하죠?
-> 사용하고 있는 MySQL 서버 메모리 설정 기준으로 InnoDB 버퍼 풀의 크기를 조정
-> 처음 설정하면 다음과 같은 방법을 고려
1. 운영체제의 전체 메모리 공간이 8GB 미만이면 50%정도만 InnoDB 버퍼 풀로 설정
2. 나머지 메모리 공간은 MySQL 서버와 운영체제, 그리고 다른 프로그램이 사용할 수 있는 공간으로 확보
3. 전체 메로리 공간이 그 이상이라면 InnoDB 버퍼 풀의 크기를 전체 메모리의 50%에서 시작해 조금씩 올려가면서 최적점을 찾는다.
4. 운영체제의 메모리 공간이 50GB 이상이라면 15GB에서 30GB정도를 운영체제와 다른 응용 프로그램을 위해서 남겨두고 나머지를 InnoDB 버퍼 풀로 할당

InnoDB 버퍼 풀은 `innodb_buffer_pool_size` 시스템 변수로 크기를 설정할 수 있으며, 동적으로 버퍼풀의 크기를 확장할 수 있다. 
버퍼 풀의 크기 변경은 치명적인 변경상항이기에 MySQL 서버가 한가한 시점에 진행
<u>InnoDB 버퍼 풀을 더 크게 변경하는 작업은 시스템 영향도가 크지 않지만, 줄이는 작업의 경우 서비스 영향도가 매우 크기 때문에 가능하면 줄이는 작업을 하지 말자</u>

InnoDB 버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되는데, 이는 버퍼 풀의 크기를 줄이거나 늘리기 위한 단위 크기로 사용
버퍼 풀의 크기를 동적으로 변경해야 한다면 128MB 단위로 처리함

InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금(세마포어)으로 인해 내부 잠금 경합을 많이 유발해왔습니다.
이런 경합을 줄이기 위해 버퍼 풀을 여러 개로 쪼개어 관리할 수 있게 개선했기에 버퍼 풀이 여러 개의 작은 버퍼 풀로 쪼개지면서 개별 버퍼 풀 전체를 관리하는 잠금 자체도 경합이 분산되는 효과를 내게 됩니다.

1GB 미만이라면 버퍼풀 인스턴스는 1개
5GB당 1개 정도를 설정해주도록 하는 것이 좋음


### 버퍼 풀의 구조
InnoDB 스토리지 엔진은 버퍼 풀을 페이지 크기의 조각으로 쪼개어 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다.

버퍼 풀의 페이지 크기 조각을 관리 하기 위해 
- LRU ( Least Recently Used ) 리스트
- 플러시 (Flush) 리스트
- 프리 (Free) 리스트
3개의 자료구조를 관리한다. 
(109페이지에서 각 자료구조의 특징이해 필요 지금은 필요없음)
![[Pasted image 20231126184600.png]]

프리 리스트는 [[InnoDB 버퍼 풀]]에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.
LRU 리스트는 위 그림과 같은 구조를 띄고 있는데 LRU와 MRU리스타가 결합된  형태라고 이해하면 된다.
`Old 서브리스트` 영역은 LRU에 해당하며, `New 서브리스트` 영역은 MRU 정도로 이해하면 된다.

LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 [[InnoDB 버퍼 풀]]의 메모리에 유지해서 디스크 읽기를 최소화하는 것이다. 
[[InnoDB]] 스토리지 엔진에서 데이터를 찾는 과정은 다음과 같습니다.
1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
2. 디스크에 필요한 데이터 페이지를 버퍼 풀ㅇ ㅔ적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이작 실제로 읽히면 MRU 헤더 부분으로 이동
4. 버퍼 풀에 상중하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고 결국 해당 페이지는 버퍼 풀에서 제거 된다. 
5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 [[어댑티브 해시 인덱스]]에 추가

한 번 읽힌 데이터 페이지가 자주 사용된다면 그 데이터 페이지는 MRU영역에서 계속 살아남고 거의 사용되지 않는다면 새롭게 디스크에서 읽히는 데이터 페이지들에 밀려서 버퍼 풀에서 제거된다.

플러시 리스트는 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준의 페이지 목록을 관리한다.

### 버퍼 풀과 리두 로그

[[InnoDB]]의 [[InnoDB 버퍼 풀]]과 [[InnoDB 리두 로그]]는 매우 밀접한 관계를 맺고 있습니다.
[[InnoDB 버퍼 풀]]은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라집니다.
[[InnoDB 버퍼 풀]]은 데이터베이스 서버의 성능 향상을 위해 [[데이터 캐시]]와 [[쓰기 버퍼링]] 이라는 두 가지 용도가 있는데, 버퍼 풀의 메모리 공간만 단순히 늘리는 것은 데이터 캐시 기능만 향상시키는 것입니다.
[[InnoDB 버퍼 풀]]의 쓰기 버퍼링 기능까지 향시키려면 [[InnoDB 버퍼 풀]]과 [[InnoDB 리두 로그]]의 관계를 먼저 이해해야 합니다.


![[Pasted image 20231126185828.png]]

[[InnoDB 버퍼 풀]]은 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지와 함께 DML 명령으로 변경된 데이터를 가진 더티 페이지도 가지고 있습니다. 


선행 지식
- 레코드 버퍼

