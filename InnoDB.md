---
cssclasses:
  - my_style_width_100
---
[[스토리지 엔진]] 의 한 종류
### 특징
- MySQL의 스토리지 엔진 가운데 가장 많이 사용된다.
- 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공
- 레코드 기반의 잠금 덕분에 높은 동시성 처리가 가능하며 안정적이고 성능이 뛰어나다.



![[Pasted image 20231124193437.png]]


### 프라이머리 키에 의한 클러스터링
![[프라이머리 키에 의한 클러스트링]]

### 외래 키 지원
외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능입니다.
- 외래 키는 데이터베이스 서버 운영의 불편함 떄문에 서비스용 데이터베이스에서는 생성하지 않는 경우도 자주 있지만 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 할 수 있습니다.

#### 외래키 사용의 주의점
- 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의해야 합니다.

### 외래키 사용중 급하게 중지하려고 할 때
서비스에 문제가 있어서 급하게 조치를 해야 하는데 외래키가 복잡하게 얽힌경우 쉽게 문제를 해결할 수 없을 수 있다.
이런 경우에는 `foreign_key_checks` 시스템 변수를 OFF로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.
왜래키 체크 작업을 일시적으로 멈추면 레코드 적재나 삭제 등의 작업도 부가적인 체크가 필요 없기 때문에 훨씬 빠르게 처리할 수 있다.
```mysql
SET FOREIGN_KEY_CHEKS=OFF
```
왜래 키 체크를 일시적으로 해제했다고 해서 부모와 자식 테이블 간의 관계가 꺠진 상태 그대로 유지해도 된다는 것을 의미하지 않습니다.


### MVCC(Multi Version Concurrency Control)
[[MVCC(Multi Version Concurrency Control)]]
일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있습니다.
-> 레코드를 잠그지 않고 일관된 읽기를 제공하는 목적을 가지고 있다. 

InnoDB는 언두 로그를 이용해 이 기능을 구현합니다.

여기서 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미입니다.


```mysql
mysql> create table member (
    ->  m_id int not null,
    ->  m_name varchar(20) not null,
    ->  m_area varchar(100) not null,
    ->  primary key (m_id),
    ->  index ix_area (m_area)
    -> );
mysql> insert into member (m_id, m_name,m_area) values (12, '홍길동', '서울');
mysql> commit;
```

```mysql
update member set m_area='경기' where m_id=12;
```

![[Pasted image 20231125133455.png]]

Update문장이 실행되면 커밋 실행 여부와 관계없이 InnoDB의 버퍼 풀은 새로운 값인 '경기'로 업데이트 된다. 그리고 디스크의 데이터 파일에는 체크포인트나 InnoDB의 write스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있다.
<u>InnoDB가 ACID를 보장하기 때문에 일반적으로는 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방합니다</u>


#### 아직 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 다음 같은 쿼리로 작업 중인 레코드를 조회하면 어디에 있는 데이터를 조회할 까?

MySQL 서버의 시스템 변수(`transaction_isolation`)에 설정된 격리 수준에 따라 다름


### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
[[InnoDB]] 는 [[MVCC(Multi Version Concurrency Control)]] 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행합니다.
-> 읽기 작업만 잠금을 걸지 않음
- 격리 수준이 `SERIALIZABLE` 이 아닌 `READ_UNCOMMITED`, `READ_COMMITED` , `REPEATABLE_READ` 수준인 경우 INSERT와 연결되지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행됩니다.
	- Insert와 연결되지 않는 순수한 읽기 작업은 무슨 말이지..?
(그림 추가 예정)
![[Pasted image 20231126180132.png]]
위 그림에서 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않는다.
이를 `잠금없는 일관된 읽기` 라고 표현하며 [[InnoDB]] 에서는 변경되기 전의 데이터를 읽기 위해 [[언두 로그]]를 활용합니다.

만약 오랜 시간 동안 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 가끔 있는데, 바로 이러한 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제다. <u>따라서 트랜잭션이 시작됐다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다</u>

> 선행 지식
> - 언두 로그 
> - innoDB 버퍼 풀
## 4.2.5 자동 데드락 감지

InnoDB 스토리지 엔진은
- 내부적으로 잠금이 교착상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리합니다.
- 데드락 감지 스레드를 가지고 있어 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그중 하나를 강제 종료합니다.
	- 이때 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은 트랜잭션의 언두 로그 양이며, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다.
	- 트랜잭션이 언두 레코드를 적게 가졌다는 이야기는 롤백을 해도 언두 처리를 해야 할 내용이 적다는 것이며, 트랜잭션 강제 롤백으로 인한 MySQL 서버의 부하도 덜 유발함

- 교착 상태에 빠진 트랜잭션을 왜 하나만 종료해도 되는지
- 언두 로그 레코드가 무엇인지

InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금은 볼 수가 없어서 데드락 감지가 불확실할 수도 있다.
`innodb_table_locks` 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지할 수 있게 된다.
-> 시스템 변수를 활성화하자

동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다.
-> 왜?
데드락 감지 스레드가 가지는 특성중에서 잠금 목록을 검사할 때 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트(잠금 테이블)에 새로운 잠금을 걸고 데드락 스레드를 찾게 된다.
-> 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미치게 된다.
-> 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.

`innodb_deadlock_detect` 시스템 변수에 대해 확인 및 구글 사례
그리고 innodb_deadlock_detect를 활성화 해서 성능 비교

## 4.2.6 자동화된  장애 복구
[[자동화된 장애 복구]]
(현재 전체 흐름을 이해하는데 크게 도움은 안됨 이후 다시와서 확인)

##  4.2.7 InnoDB 버퍼 풀
![[InnoDB 버퍼 풀]]

## 4.2.9 언두 로그

InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업합니다. 
이렇게 백업된 데이터를 언두 로그(Undo Log)라고 합니다. 

언두 로그는 다음과 같은 방법으로 사용됩니다.

- 트랜잭션 보장
	- 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구한다.
- 격리 수준 보장
	- 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 합니다. 

<u>언두 로그는 InnoDB 스토리지 엔진에서 매우 중요한 역할을 담당하지만 관리 비용도 많이 필요합니다.</u>

> 한줄 요약
> InnoDB 스토리지 엔진에서 트랜잭션과 격리수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 백업하는데 이를 언두 로그라고 합니다.
> -> InnoDB에서만 사용하는 용어인가? (NO)
> DBMS에서 광범위하게 사용하는 용어

### 언두 로그 모니터링
언두 영역은 `INSERT`, `UPDATE`, `DELETE` 같은 문장으로 데이터를 변경했을 때 변경되기 전의 데이터(이전 데이터)를 보관하는 곳이다. 


```mysql
update member set name = '~' where member_id = 1;
```

위 쿼리가 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일(데이터/인덱스 버퍼) 내용은 지정한 문자열로 변경됩니다. 만약 변변경되기 전의 값이 있다면, 언두 영역에는 이전 값이 백업되는 것이죠. 이 상태에서 커밋하면 현재 상태가 유지되고, 롤백하면 언두 영역의 백업된 데이터를 다시 데이터 파일로 복구합니다.

언두 로그는 다음과 같이 사용됩니다.
1. 트랜잭션의 롤백 대비용
2. 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공
	 - 트랜잭션의 격리 수준이라는 개념은 동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보일지를 결정하는 기준이다. 자세한건 5장에서 설명

언두로그를 사용했을 때 발생할 수 있는 문제점은 다음과 같습니다. 
1억건의 데이터를 삭제할 때 1억건의 데이터는 모두 언두영역에 위치하게 된다. 이 때 한번 증가한 언두 영역은 다시 줄어들지 않는다. 그렇기에 대용량의 데이터를 처리하는 트랜잭션뿐만 아니라 트랜잭션이 오랜 시간 동안 실행될 때도 언두 로그의 양은 급격하게 증가할 수 있습니다. 또한 트랜잭션이 완료됐다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 없습니다.

![[Pasted image 20231125012903.png]]

원래는 언두 영역이 한번 늘어난 경우 서버를 재구축하지 않는 한 줄일 수 없었지만 8.0부터는 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄이는 것도 가능하며 서버가 필요한 시점에 사용 공간을 자동을 줄여 주기도 합니다.

하지만 여전히 서비스 중인 MySQL 서버에서화성 상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않습니다. 그래서 MySQL 서버의 언두 로그가 얼마나 증가했는지는 항상 모니터링하는 것이 좋으며 다음과 같이 MySQL 서버의 언두 로그 건수를 확인할 수 있습니다.

```mysql
SHOW ENGINE INNODB STATUS \G
```

MySQL 서버에서 실행되는 DML문장이 얼마나 많은 데이터를 변경하느냐에 따라 평상시 언두 로그 건수는 상이합니다. 그래서 MySQL 서버별로 이 값은 차이를 보이며 서버별로 안정적인 시점의 언두 로그 건수를 확인해 이를 기준으로 언두 로그의 급증 여부를 모니터링하는 것이 좋습니다. 

> MySQL 서버에서 INSERT 문장으로 인한 언두 로그와 UPDATE 문장으로 인한 언두 로그는 별도로 관리된다. UPDATE DELETE 문장으로 인한 언두 로그는 MVCC와 데이터 복구에 모두 사용되지만 INSERT 문장으로 인한 언두 로그는 MVCC를 위해서는 사용되지 않고 롤백이나 데이터 복구만을 위해서 사용되기 때문이다.


### 언두 테이블 스페이스 관리
언두 로그가 저장되는 공간을 언두 테이블스페이스라고 합니다. 
> 언두 영역이랑 다른게 있나..?


연관 자료
- MVCC

## 4.2.10 체이지 버퍼

RDMS에서 레코드가 INSERT 되거나 UPDATE될 때는 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요합니다.

그런데 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이작업으 상당히 많은 자원을 소모하게 됩니다.
