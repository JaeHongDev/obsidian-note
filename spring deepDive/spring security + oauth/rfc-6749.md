https://datatracker.ietf.org/doc/html/rfc6749

https://www.latera.kr/category/reference/etc/page/2/


Abstract
  
OAuth 2.0 인증 프레임워크는 HTTP 서비스에 대해 제한된 액세스를 얻을 수 있도록 제3자 응용 프로그램이 리소스 소유자와 HTTP 서비스 간의 승인 상호 작용을 조율하거나, 제3자 응용 프로그램이 자체적으로 액세스를 얻도록 하는 것을 허용함으로써 작동합니다. 
이 사양은 RFC 5849에 설명된 OAuth 1.0 프로토콜을 대체하고 폐기합니다.

Status of This Memo



# Introduction 
전통적인 클라이언트-서버 인증 모델에서 클라이언트는 리소스 소유자의 자격 증명을 사용하여 서버와 인증하여 액세스 제한된 리소스(보호된 리소스)에 대한 요청을 합니다. 제 3자 응용 프로그램이 제한된 리소스에 액세스할 수 있도록 하기 위해 리소스 소유자는 제 3자와 자신의 자격 증명을 공유합니다. 이로 인해 여러 가지 문제와 제한이 발생합니다:

- 제 3자 응용 프로그램은 리소스 소유자의 자격 증명을 저장하여야 하며, 일반적으로 이는 평문으로 된 암호입니다.
- 서버는 암호에 내재된 보안 약점에도 불구하고 암호 인증을 지원해야 합니다.
- 제 3자 응용 프로그램은 리소스 소유자의 보호된 리소스에 대해 지나치게 광범위한 액세스를 획득하여, 리소스 소유자는 제한된 기간 또는 리소스의 제한된 하위 집합에 대한 액세스를 제어할 수 없게 됩니다.
- 리소스 소유자는 개별적인 제 3자의 액세스를 취소할 수 없으며, 모든 제 3자의 액세스를 취소하기 위해 해당 제 3자의 암호를 변경해야 합니다.
- 
OAuth는 인증 계층을 도입하여 문제를 해결하고 클라이언트와 리소스 소유자의 역할을 분리합니다. OAuth에서 클라이언트는 리소스 소유자가 제어하고 리소스 서버에서 호스팅하는 리소스에 대한 액세스를 요청하며, 리소스 소유자의 자격 증명과는 다른 일련의 자격 증명을 발급받습니다.

보호된 리소스에 액세스하기 위해 리소스 소유자의 자격 증명을 사용하는 대신, 클라이언트는 특정 범위, 수명 및 기타 액세스 속성을 나타내는 문자열 인 액세스 토큰을 얻습니다. 액세스 토큰은 리소스 소유자의 승인을 받아 인가 서버가 제 3자 클라이언트에게 발급합니다. 클라이언트는 액세스 토큰을 사용하여 리소스 서버에서 호스팅하는 보호된 리소스에 액세스합니다.

예를 들어, 최종 사용자(리소스 소유자)는 프린팅 서비스(클라이언트)가 자신의 사용자 이름과 암호를 공유하지 않고도 사진 공유 서비스(리소스 서버)에 저장된 보호된 사진에 액세스할 수 있도록 할 수 있습니다. 대신, 그녀는 사진 공유 서비스에 의해 신뢰되는 서버와 직접 인증하여 프린팅 서비스 위임별 자격 증명(액세스 토큰)을 발급받습니다.

이 명세서는 HTTP([RFC2616])와 함께 사용하기 위해 설계되었습니다. HTTP 이외의 프로토콜을 통한 OAuth 사용은 범위를 벗어납니다.

OAuth 1.0 프로토콜([RFC5849])은 소규모의 임시 커뮤니티 노력의 결과로 정보 문서로 발표되었습니다. 이 표준 트랙 명세서는 OAuth 1.0 배포 경험을 바탕으로 넓은 IETF 커뮤니티에서 수집된 추가 사용 사례 및 확장성 요구 사항에 기반을 두고 있습니다. OAuth 2.0 프로토콜은 OAuth 1.0과 역사적으로 호환되지 않습니다. 두 버전은 네트워크에서 공존할 수 있으며, 구현은 두 버전을 모두 지원할 수 있습니다. 그러나 이 명세서의 의도는 새로운 구현이 이 문서에서 지정된 대로 OAuth 2.0을 지원하고, OAuth 1.0은 기존 배포를 지원하기 위해서만 사용되어야 한다는 것입니다. OAuth 2.0 프로토콜은 OAuth 1.0 프로토콜과 구현 세부 사항을 거의 공유하지 않습니다. OAuth 1.0에 익숙한 구현자는 이 문서의 구조와 세부 사항에 대한 어떠한 가정도 하지 않고 접근해야 합니다.


## 1.1 Roles
OAuth는 네 가지 역할을 정의합니다.

- 리소스 소유자(resource owner): 보호된 리소스에 액세스할 수 있는 엔티티입니다. 리소스 소유자가 사람인 경우 최종 사용자(end-user)로 지칭됩니다.
- 리소스 서버(resource server): 보호된 리소스를 호스팅하는 서버로, 액세스 토큰을 사용하여 보호된 리소스 요청을 수락하고 응답할 수 있습니다.
- 클라이언트(client): 리소스 소유자를 대신하여 보호된 리소스 요청을 만들고 해당 요청에 대한 인증을 받는 응용 프로그램입니다. "클라이언트"라는 용어는 특정 구현 특성(예: 응용 프로그램이 서버, 데스크톱 또는 기타 장치에서 실행되는지 여부)을 의미하지 않습니다.
- 인가 서버(authorization server): 리소스 소유자를 성공적으로 인증한 후 클라이언트에게 액세스 토큰을 발급하는 서버입니다.

이 명세서의 범위를 벗어나는 인가 서버와 리소스 서버 간의 상호 작용입니다. 인가 서버는 리소스 서버와 동일한 서버일 수도 있고 별도의 엔티티일 수도 있습니다. 단일 인가 서버는 여러 리소스 서버에서 수락하는 액세스 토큰을 발급할 수 있습니다.

## 1.2 Protocol Flow
![[Pasted image 20240314124716.png]]
그림 1에 설명된 추상적인 OAuth 2.0 흐름은 네 가지 역할 간의 상호 작용을 설명하며 다음 단계를 포함합니다:

(A) 클라이언트는 리소스 소유자로부터 권한 부여를 요청합니다. 권한 요청은 리소스 소유자에게 직접(그림에 표시된 대로) 또는 중개자로서의 인가 서버를 통해 간접적으로 이루어질 수 있습니다.
(B) 클라이언트는 권한 부여를 나타내는 자격 증명인 권한 부여 허가를 받습니다. 권한 부여 허가의 유형은 이 명세서에서 정의된 네 가지 권한 부여 유형 또는 확장 권한 부여 유형을 사용하여 표현됩니다. 권한 부여 허가 유형은 클라이언트가 권한을 요청하는 방법과 인가 서버가 지원하는 유형에 따라 달라집니다.
(C) 클라이언트는 인가 서버와 인증을 통해 액세스 토큰을 요청하고 권한 부여 허가를 제시합니다.
(D) 인가 서버는 클라이언트를 인증하고 권한 부여 허가를 유효성 검사하고 유효하다면 액세스 토큰을 발급합니다.
(E) 클라이언트는 액세스 토큰을 제시하여 리소스 서버로부터 보호된 리소스를 요청하고 인증합니다.
(F) 리소스 서버는 액세스 토큰을 유효성 검사하고, 유효하다면 요청을 처리합니다.
클라이언트가 리소스 소유자로부터 권한 부여를 받는 선호하는 방법(단계 (A) 및 (B)에 표시됨)은 인가 서버를 중개자로 사용하는 것입니다. 이는 4.1절의 그림 3에서 설명됩니다.


## 1.3 Authorization Grant
인가 부여는 클라이언트가 액세스 토큰을 얻기 위해 사용하는 리소스 소유자의 권한을 나타내는 자격 증명(보호된 리소스에 대한 액세스를 허용하기 위함)입니다. 이 명세서는 인가 코드, 암시적, 리소스 소유자 암호 자격 증명 및 클라이언트 자격 증명과 같이 네 가지 권한 부여 유형을 정의하며 추가 유형을 정의하기 위한 확장성 메커니즘도 제공합니다.

### 1.3.1 Authorization Code
인가 코드는 클라이언트와 리소스 소유자 사이에 중개자로서 인가 서버를 사용하여 얻습니다. 리소스 소유자에게 직접 권한을 요청하는 대신, 클라이언트는 리소스 소유자를 인가 서버(정의된대로 사용자 에이전트를 통해 [RFC2616]에서 정의함)로 이동시킵니다. 인가 서버는 다시 리소스 소유자를 클라이언트에게 인가 코드와 함께 돌려보냅니다.

리소스 소유자를 클라이언트에게 인가 코드와 함께 다시 이동시키기 전에, 인가 서버는 리소스 소유자를 인증하고 인가를 얻습니다. 리소스 소유자는 인가 서버와만 인증하기 때문에 리소스 소유자의 자격 증명은 클라이언트와 공유되지 않습니다.

인가 코드는 클라이언트를 인증하고 액세스 토큰을 리소스 소유자의 사용자 에이전트를 통과시키지 않고 직접 클라이언트에게 전송하여 리소스 소유자를 포함한 다른 사람에게 노출되지 않도록 하는 몇 가지 중요한 보안 이점을 제공합니다.