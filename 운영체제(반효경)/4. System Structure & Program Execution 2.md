

# 동기식 입출력과 비동기식 입출력

![[Pasted image 20240201021132.png]]

![[Pasted image 20240203000128.png]]
## 동기식 입출력 (synchronous I/O)
- I/O장치까지 직접가서 결과를 보고 오는 것을  동기식 입출력이라고 볼 수 있습니다.
	- 🤔 이게 무슨 말이지?
- I/O 장치를 혼자만 접근하는 것이 아닌 동시에 접근할 수 있는데 A는 I/O 장치에 가져다 쓰고 B는 읽어오고  중간에 직접 가지(확인하지)않고 바로 다음 일을 처리하는 것은 syncronous 하지 않는 asynchronous 하다고 부르고
- syncronus는 I/O 장치까지 가서 직접 확인하고 읽어와서 보고 작업하는 것을 syncronous read고 I/O 장치에다가 데이터를 써야 하는데 쓰기 작업을 요청하고 다음일을 할 수 있지만 쓰기 작업이 끝났는지 확인하고 나서 그 다음일을 진행하면 syncronus write임
- 쓰고 확인을 했다는 것은 누군가가 서로 같은 것을 보고 있다는 것을 보장할 수 있기 때문에 이런 용어를 쓰는 것임

-  I/O는 커널을 통해서만 할 수 있음 
- 사용자 프로그램이 I/O요청을 운영체제 커널에게 하면 IO장치에 맞는 디바이스 드라이버를 거치고 실제 하드웨어를 통해서 IO를 읽거나 쓰는 작업을 진행함
	- 단 IO를 하는 작업은 시간이 오래걸리는 작업인데 이걸 보고서 사용자가 다음 작업을 하는데 이것을 syncronous IO라고 합니다.

- 구현 방법1
	- I/O가 끝날 때까지 CPU를 낭비시킴
	- 매시점 하나의 I/O만 일어날 수 있음
- 구현 방법2 
	- I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
		- IO진행중에는 CPU를 낭비시키기 때문에 다른 작업에게 cpu 제어권을 넘겨줌 
	- I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
	- 다른 프로그램에게 CPU를 줌

I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감


### 비동기식 입출력(asyncronous I/O)
I/O 가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

- 사용자 프로그램이 운영체제 커널에게 요청을 해서 I/O요청 작업이 진행되는데 요청 작업을 기다리지 않고 바로 CPU 제어권을 얻어서 바로 다음 작업을 진행함
- 이때 끝났다는 것을 알려줘야 하는데 이는 인터럽트를 통해서 알려주게 됌

자바에서 completableFuture는 어떻게 처리되는거지?

> syncronous IO와 asyncronous IO가 서로 어떤 의미를 가질까



### DMA 컨트롤러 (26:00)
![[Pasted image 20240201022110.png]]

- DMA는 메모리를 접근할 수 있는 장치
	- 원래는 cpu만 가능
- DMA는 CPU가 IO디바이스로 인한 너무 많은 인터럽트를 발생시켜 cpu 제어권이 운영체제로 자주 넘어가는데 이런 오버헤드를 해결하기 위한 것임
- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용함
	
# 서로 다른 입출력 명령어
- I/O를 할 수 있는 2가지 방법

좌측에 있는 그림은 일반적인 IO방식.
- CPU에서 실행할 수 있는 기계어(인스트럭션)에는 메모리만 접근하는 인스트럭션이 있고 IO장치에 접근해야 하는 인스트럭션이 존재합니다.
- LoadStore같이 메모리에 접근하는 인스트럭션이 존재함
- 각 IO디바이스별로 LoadStor와 같이 메모리에 접근하는 별개의 인스트럭션이 존재함

우측에 있는 방식
- 메모리 주소를 통해서 IO 디바이스에 접근할 수 있음 (Memory Mapped IO)
- IO장치도 메모리 주소에 연장 장치를 붙임 
![[Pasted image 20240201022132.png]]
# 저장장치 계층 구조
![[Pasted image 20240201022357.png]]
위 그림에서 맨 위에는 CPU가 존재함
CPU안에는 레지스터가 존재함
- 캐시 메모리(컴퓨터 구조)
- Main memory (dram)
- 세컨더리 디스크는 하드 디스크 혹은 SSD 

위로 갈수록 용량이 적고 단위 공간에 따른 비용이 비쌈
Volatility (휘발성)



# 프로그램의 실행 (메모리 load)

![[Pasted image 20240201022724.png]]
프로그램은 실행 파일 형태로 파일 시스템에 저장 돼 있는데 실행 파일을 실행하게 되면 메모리에 프로세스 형태로 메모리에 올라가게 됩니다.

![[Pasted image 20240201022745.png]]

파일 시스템에 있는 실행 파일이 메모리의 프로세스에 바로 올라가는 것이 아닌 중간 단계인 가상 메모리 (Virtual memory)에 올라갑니다.

어떤 프로그램을 실행시키게 되면 그 프로그램에 주소공간이 형성이 됩니다. 
이는 0번지 부터 시작하는 프로그램만의 독자적인 주소 공간이 형성됩니다. 
각 프로그램마다 전부 0번지 부터 생성됨

이러한 주소 공간은 code, data,stack의 형태로 구성 
- code: 기계어 코드
- data: 변수 전역 변수, 자료구조
- stack: 함수를 호출하거나 반환할 때 사용하는 용도

물리적인 메모리에 커널(운영체제)는 컴퓨터 부팅시 커널 주소 공간에 메모리에 항상 상주합니다.
하지만 사용자 프로그램은 실행시키면 주소 공간이 생겼다가 종료 시키면 사라지게 됩니다.

여기서 프로그램이 실행 후 생성된 가상 메모리를 물리적인 메모리에 전부 올리는 것은 아닙니다.
- 전부 올리게 되면 메모리 용량이 초과되지 않을까 
- 낭비도 있겠네요
그렇기에 현재 사용되는 부분만 물리적인 메모리에 올려두고 사용하지 않는 부분은 올리지 않습니다.

나중에 사용이 안되는 경우 물리적인 메모리에서 제거하기도 합니다.
물론 모두 제거되는 것은 아니고 보관되는 것 또한 존재합니다.

이는 디스크의 swap 메모리에 저장됩니다.

> 아 그러면 프로그램이 실행됐을 때 메모리 공간은 모두 물리적인 메모리 공간에 할당되는게 아니구나.
> 
> 가상 메모리에서 물리적인 메모리로 옮겨간 다음 사용하지 않는 경우는 제거되거나 스왑 영역에 추가적으로 등록이 될 수 있구나


Virtual 메모리는 각 프로그램이 실행 됐을 때 가지는 고유한 메모리 공간을 의미함

FileSystem의 디스크와 Swap area의 디스크는 서로 용도가 다릅니다.

FileSystem은 전원이 나가더라도 유지해야 하는 데이터고
Swap area는 전원이 나가면 의미가 없는 데이터이기 때문에 삭제 해야 합니다.
- 즉 한정적인 메모리 공간을 연장하는 연장 메모리 개념이라고 생각하면 됩니다.

각 프로그램마다 0번지에서 시작하는 물리적인 공간이 있는데 가상 메모리에서 1000번지를 쓰고 있다면 물리적인 메모리에서는 다른 주소로 변경되야 합니다. 
- 가상 메모리는 독립적인 메모리 주소를 가지고 있기 때문에 변경해야 함

이를 위해 주소 변환이 필요함
별도의 계층이 존재하는데 운영체제가 하는 것이 아닌 하드웨어 장치가 해줍니다.

# 커널 주소 공간의 내용
![[Pasted image 20240201023203.png]]

운영체제 커널의 주소 송간의 내용입니다.

먼저 운영체제가 해야 할 일은 다음과 같습니다.
1. 자원 관리를 위한 코드
2. 사용자를 위한 인터페이스를 제공
3. 시스템콜, 하드웨어가 발생시키는 인터럽트에 무슨 일을 해야할지 커널의 코드부분에 들어감

운영체제(커널)의 데이터 영역에서는 다음과 같은 작업을 합니다.
- 운영체제는 CPU, 메모리, 디스크와 같은 하드웨어를 통제합니다.
	- 그런 하드웨어를 관리하기 위해서 하드웨어 종류마다 자료구조를 하나씩 만들어서 관리하는데 추상적으로 표시한 그림임
- (그림 설명) data영역에 있는 CPU, 메모리, 디스크는 자료구조를 의미하고 그 밖에 있는 cpu, 메모리, 디스크는 실제 하드웨어를 의미합니다. 
- 운영체제는 프로세스를 관리해야 하기 때문에 각 프로그램들이 독자적인 주소공간을 가지고 있기 떄문에 프로그램마다 관리하는 자료구조가 필요한데 이를 PCB라고 부릅니다.

운영체제(커널)의 스택영역은 다음과 같은 작업을 합니다.
- 사용자 프로그램마다 커널 스택을 따로 두고 있음
- 운영체제도 함수구조로 작성되어 있기 때문에 함수를 호출하거나 리턴할 때 스택 영역을 사용해야 함
- 운영체제의 코드를 여러 사용자 프로그램이 시스템콜을 통해서 운영체제 코드를 실행시킬 수 있음


# 사용자 프로그램이 사용하는 함수

![[Pasted image 20240201023459.png]]

어떤 프로그램언어를 사용하든 함수구조로 작성되어 있습니다. 

짜여진 코드는 컴파일이 되더라도 해당 함수가 어디서 부터 어디까지인지 기계어 코드로 라인 별로 기록돼 있음

그래서 함수라는 용어자체는 고급언어가 아니더라도 인스트럭션(기계어)레벨까지 내려가서 계속 사용하는 이유임

![[Pasted image 20240201023547.png]]


# 프로그램의 실행 (54:17)

![[Pasted image 20240201023803.png]]

프로그램이 실행되는 단계를 보면
- A 프로그램이 실행 ~ 종료 까지의 단계를 봄
- 사용자가 만든 프로그램이 CPU제어권을 가지면 사용자 모드 즉 User Mode라고 함
	- 사용자 모드 안에서 사용자 정의 함수를 호출해도 사용자 모드임
- 만약 System call을 하게 되면 프로그램의 주소가 아닌 커널에서 동작하기 때문에 커널 모드 즉 Kernel의 주소 공간에서 실행됌
- 그러다 시스템콜이 끝나게 되면 CPU 제어권이 A프로그램에 넘어오게 되고 만약 라이브러리 함수를 호출해도 여전히 사용자 모드임

프로그램은 시작부터 끝까지 사용자 모드, 커널 모드를 반복함

