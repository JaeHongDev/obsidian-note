---
cssclasses:
  - my_style_width_100
---
> ⚠ 학습 목표
> 운영체제를 설명하기 앞서 하드웨어의 동작을 설명하기 위함


컴퓨터 하드웨어 구성을 요약해서 보여준 것
![[Pasted image 20240121235526.png]]
보통 컴퓨터 시스템은 CPU, 메모리로 구성된 컴퓨터와  I/O DEVICE를 합친 것을 의미합니다.


메모리는 CPU의 작업 공간입니다.

CPU에서 매 클럭 사이클마다 메모리에서 인스트럭션(기계어)를 하나씩 읽어서 실행합니다.

CPU는 매 클럭 사이클마다 메모리에서 기계어를 하나씩 읽어 실행하게 됌
![[Pasted image 20240121235738.png]]

IO 디바이스(키보드, 마우스)는 각각의 CPU를 가지고 있음 이를 디바이스 컨트롤러라고 이야기함.

디스크 실행하는 것이라고 이야기합니다.

디스크의 내부를 통제하는 것은 CPU가 아닌 디스크 내부에 붙어있는 디스크 컨트롤러가 작업을 처리함
==그래서 디스크 컨트롤러는 작은 CPU라고 이해하면 좋음==

CPU도 작업 공간인 메모리가 존재하듯이  IO디바이스도 각각의 메모리가 존재하는데 이를 로컬 버퍼라고 이야기 함

CPU와 IO디바이스는 처리 속도에서 많은 차이가 발생함. (CPU > DISK)

CPU는 매 클럭마다 메모리에서 인트럭션을 하나씩 계속 읽음
> CPU의 운명
> 메모리에서 인스트럭션을 하나씩 가져와서 읽는데 다 읽으면 다음 인스트럭션을 받아와서처리함

CPU안에는 정보를 저장할 수 있는 작은 공간인 레지스터가 존재함

CPU안에 모드 비트가 존재하는데 이것이 사용자 운영체제인지 사용자 프로그램인지 구분하는 역할을 합니다.

CPU에는 Interrupt line이라는 것이 붙어하는데 메모리에서 처리하는 작업 외 IO Device에서 처리된 작업을 CPU가 받아서 마무리 해주는 역할을 위해 존재함(이거 다시 확인)
- CPU는 메모리하고 일함

메모리에서 A프로그램을 실행하다가 A프로그램이 IO 작업을 할 때 CPU는 IO디바이스에 직접 접근하지 않고 메모리에서 읽어서 인스트럭션을 실행하게 되어 있는데 그러다가 디스크에서 무언가 읽어와야 하는 요청을 처리하려면
cpu가 디스크 컨틀롤러에 특정 데이터를 읽어오라고(일을 시키는 인스트럭션이 있음) 요청 디스크는 컨트롤러의 요청을 받아서 자신의 로컬 버퍼에 집어넣음

메모리에서 IO작업이 필요하면 CPU가 기다리는게 아닌 IO 디바이스에 작업을 시키고 메모리의 인스트럭션을 실행함

(13:10)
CPU가 디바이스 컨트롤러에게 지시하는 역할은 누가 함?

만약 무한 루프를 도는 프로그램은 어떻게 하나요?
- IO를 하지도 않고 CPU를 계속 사용하는데 다른 작업을 처리하지 못한다.
- 이때 타임 쉐어링조차 할 수 없음
- 그래서 컴퓨터는 타이머라는 하드웨어가 존재함
	- 타이머는 특정 프로그램이 CPU를 독점하는 것을 막기 위해 존재함
		- 처음에는 cpu가 운영체제를 가지고 있다가 여러 프로그램이 실행될 때 cpu를 넘겨주는데 그냥 넘기는 것이 아닌 타이머 값을 설정한 다음에 cpu를 넘겨주게 됌
		- 사용자 프로그램은 cpu를 독점적으로 계속 쓸 수 있는게 아닌 정해진 시간만큼 쓸 수 있음
		- 세팅된 시간이 완료되면 타이머가 cpu에게 인터럽트를 걸어줌 
		- cpu는 매번 인스트럭션일 실행되다가 끝나고나면 인터럽트 라인을 체크
		- 인터럽트 라인을 체크해서 들어온 요청이 없으면 다음 인스럭션을 실행함
		- 요청이 있는 경우 cpu는 하던 일을 멈추고 사용자 프로그램으로 부터 운영체제한테 cpu 사용권이 자동으로 넘어감
		- 운영체제가 cpu를 얻게 되면 다음 프로그램한테 타이머를 걸고 cpu를 씀

프로그램이 IO를 하게 되면 운영체제에게 cpu를 넘김

IO를 넘긴 사용자 프로그램은 요청한 작업이 끝나면 io디바이스의 데이터가 로컬 버퍼에 채워지면 cpu가 자신한테 인터럽트를 걸어버림
인터럽트가 걸리면 cpu 제어권이 운영체제에게 넘어감
운영체제는 인터럽트가 왜 들어왔는지 파악하고 io 요청 값을 프로그램 메모리 공간에 카피를 한 다음 보통은 요청한 사용자 프로그램에게 cpu를 줌
- 타이머를 봤을 때 한정된 시간이 남아있다면 그대로 쓰게 해주지만  할당된 시간이 끝났다면 이후에 라운드로빈으로 차례가 됐을 때 cpu에 넘겨줌


모드 비트는 cpu의 소유권이 누구에게 있는지 식별하기 위해서 존재합니다.
- mode bit은 0이면 모니터 모드 (커널 모드) : 운영체제가 CPU에서 실핼
	- mode bit 0일 때 운영체제가 cpu에서 메모리 접근 혹은 IO Device 접근등을 처리할 수 있게 됌 (운영체제가 cpu를 가지고 있음)
- mode bit이 1일 때 사용자 모드
	- 사용자 프로그램이 cpu의 소유권을 가지고 있을 때 제한된 인스트럽션만 실행할 수 있음
- mode bit이 0에서 1로 바뀔 때 운영체제는 mode bit을 1로 변경해서 cpu를 넘겨줌
	- 만약 사용자 프로그램이 io접근을 하거나 다른 프로그램의 메모리 공간에 접근하려고 할 때 mode bit이 1인 것을 보고 인스트럭션을 실행할 수 없게 하드웨어 차원에서 구현돼 있습니다.
- 인트럽터가 들어오게 되면 mode bit은 0으로 바뀌게 됩니다. 
- 
> 하드웨어 차원에서 사용자 프로그램이 io 디바이스에 직접하거나 다른 프로그램의 메모리 공간에 접근하는 것을 막는데 어떻게 다른 메모리 주소의 값을 바꾸는 형태의 해킹 툴들이 존재할 수 있나요?
> 
> 1. 버퍼오버플로우
>    버퍼오버플로우를 활용해서 쉘에 접근할 수 있음 (해킹 기법 중 하나임)

사용자 프로그램이 cpu를 가지고 있을 때는 제한된 작업만 가능함

![[Pasted image 20240122001618.png]]


# Timer
![[Pasted image 20240125174010.png]]

# Device COntroller
![[Pasted image 20240125174132.png]]

제어정보를 위한 register는 cpu를 통해서 무엇을 해야 하는지 지시하기 위한 용도입니다.
데이터를 위한 로컬 버퍼는 메모리로 넘겨주거나 메모리에서 로컬버퍼에 담는 지시를 제어(control) 레지스터를 통해 발생함

![[Pasted image 20240125174424.png]]

또한 메모리를 전담하는 컨트롤러가 존재하는데 다른 디바이스와 마찬가지로 붙어있음

원칙적으로는 cpu만 접근할 수 있도록 한 것임 
메인 메모리는 cpu만 접근하고 io device는 로컬 버퍼가 존재하는 형식

cpu는 메모리 접근을 할 수 있고 로컬 버퍼도 접근할 수 있음

이러한 작은 cpu는 로컬 버퍼만 접근할 수 있음

근데 이렇게 하다 보니깐 cpu가 너무 많은 인터럽트를 당함
- 어떤 장치는 인풋하나만 하니깐 인터럽트를 당하고
- cpu는 os에 소유권이 넘어가게 되고
- 이런 상황에서 아무리 빠른 os라고 하더라도 너무 많은 인터럽트를 당하게 되면 효율이 좋지 않음
- 이를 개선하기 위해 DMA 컨트롤러가 존재함

# DMA Controller
Direct Memory Access Controller

원래는 메모리에 접근할 수 있는 장치는 cpu지만 dma controller둬서 cpu뿐 아니라 메모리에 접근할 수 있도록 함
만약 cpu와 dma controller가 동시에 같은 메모리 주소에 접근하려고 할 때 memory 컨트롤러가 이를 중재하는 역할을 함

dma의 존재의의는 
io 장치가 cpu의 방해를 너무 많이 받게 되는 이를 막기 위함

io요청이 들어올 때 마다 cpu에 인터럽트를 걸어버리니 cpu가 로컬 버퍼에 있는 내용을 카피하는게 오버헤드가 크기 때문에 cpu는 자기일을 하고 있고 중간 중간 로컬버퍼에 들어온 내용을 DMA가 메모리에 직접 복사하는 일까지 하는 것 그 작업이 끝이 나면 cpu에게 인터럽트를 걸어버림

![[Pasted image 20240125180131.png]]


함수를 호출하게 될 경우는
main에서 인스트럭션을 점프하게 됌

운영체제 함수를 호출하는 방법 

만약 사용자 프로그램에서 시스템 콜을 해야 하는 경우 이 경우 cpu의 인터럽트 라인에 직접 인스터럭션을 실행함
cpu는 mode bit이 바뀌고 os에 cpu의 제어권이 넘어감

# 인터럽트

![[Pasted image 20240125180754.png]]


![[Pasted image 20240125180951.png]]

2가지 종류의 인터럽트가 발생

프로그램이 cpu에게 거는 인터럽트
io가 끝나면 cpu에게 거는 인터럽트

인터럽트 벡터 (50분)
