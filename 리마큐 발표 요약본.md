---
cssclasses:
  - my_style_width_100
---

DDL - DBMS 서버의 모든 오브젝트를 생성하거나 변경하는 쿼리


https://medium.com/daangn/mysql-online-ddl-faf47439084c



> ℹ 온라인 DDL
> 스키마를 변경하거나 작업 도중에도 다른 커넥션에서 해당 테이블의 데이터를 변경하거나 조회하는 작업을 가능하게 하는 것

온라인 DDL은 
- ALGORITHM
- LOCK 
2가지 옵션을 지원합니다.

위 두 옵션을 이용해 어떤 모드로 스키마 변경을 실행할지 결정할 수 있습니다.


MySQL에서 Alter table 명령에서 적합한 알고리즘을 찾는 과정

1. ALGORITHM=INSTANT로 스키마 변경이 가능한지 체크
2. ALGORITHM=INPLACE로 스키마 변경이 가능한지 확인
3. ALGORITHM=COPY 알고리즘 선택

> 스키마 변경 알고리즘의 우선순위가 낮을수록 MySQL 서버는 스키마 변경을 위해서 더 큰 잠금과 많은 작업을 필요로 하기 때문에 서버 부하로 이어짐

- INSTANT: 테이블의 메타데이터만 변경
- INPLACE: 임시 테이블로 데이터를 복사하지 않고 스키마 변경을 실행
- COPY: 변경된 스키마를 적용한 임시 테이블을 생성 후 레코드를 모두 임시테이블로 복사 후 rename을 통해 스키마 변경을 완료

INPLACE, COPY 알고리즘을 사용하는 경우 아래 3가지 LOCK중 하나를 명시할 수 있습니다.
- NONE: 잠금을 걸지 않음
- SHARED: 읽기 잠금만 걸어 쓰기 X
- EXCLUSIVE 쓰기 잠금을 걸어 쓰기, 읽기 X

> 실제 사용법은 아래 처럼 사용할 수 있습니다.
![[Pasted image 20240305154020.png]]

## INPLACE 

INPLACE 알고리즘을 사용하면 내부적으로 테이블의 리빌드가 필요한데 대표적인 예시로는 프라이머리키를 추가하는 작업이 해당됩니다.

INPLACE 알고리즘은 임시 테이블로 레코드를 복사하지 않더라도 내부적으로 테이블의 모든 레코드를 리빌드 하는 경우가 많이 있습니다.
- 데이터 재구성이 필요한 경우: 잠금을 필요로 하지 않기 때문에 읽고 쓰기는 가능하지만 여전히 테이블의 레코드 건수에 따라 상당히 많은 시간이 소요
- 데이터 재구성이 필요하지 않은 경우: INPLACE 알고리즘을 사용하지만 INSTANT 알고리즘과 비슷하게 매우 빨리 작업이 완료될 수 있습니다.


이 때 MySQL 서버는 아래 과정을 거칩니다.

1. INPLACE 스키마 변경이 지원되는 스토리지 엔진의 테이블인지 확인
2. INPLACE 스키마 변경 준비
3. 테이블의 스키마 변경 및 새로운 DML 로깅
4. 로그 적용
5. INPLACE 스키마 변경 완료

INPLACE 알고리즘으로 온라인 스키마 변경이 진행되는 동안 새로 유입된 DML 쿼리들에 의해 변경되는 데이터를 온라인 변경 로그에 쌓아 두었다가 온라인 스키마 변경이 완료되면 로그의 실제 내용를 테이블로 일괄 적용합니다.

참고로 온라인 변경 로그는 디스크가 아닌 메모리에만 생성되며, 메모리 공간의 크기는 innodb_online_alter_log_max_size 시스템 변수에 의해 결정됩니다.


# 온라인 처리 가능 스키마 변경

MySQL 서버의 모든 스키마 변경 작업이 온라인으로 가능한 것이 아니기 때문에 스키마 변경 작업의 형태가 온라인으로 처리될 수 있는지, 테이블의 일고 쓰기가 대기하게 되는지 확인후 실행하는 것이 좋습니다. 또한 버전별로 사용가능사항이 다르기 때문에 메뉴얼을 참고해는 것이 좋습니다.


MySQL 서버에서 사용할 수 있는 스키마 변경 작업은 매우 다양하기 떄문에 온라인 DDL을 지원 여부를 기억하는 것이 쉽지 않기 때문에 MySQL에 직접 값을 넣어보며 테스트하는 것도 하나의 방법입니다.

```
mysql> ALTER TABLE employees DROP PRIMARY KEY, ALGORITHM=INSTANT;

ERROR 1846 (0A000): ALGORITHM=INSTANT is not supported. Reason: Dropping a primary key is not allowed without also adding a new primary key. Try ALGORITHM=COPY/INPLACE.

mysql> ALTER TABLE employees DROP PRIMARY KEY, ALGORITHM=INPLACE, LOCK=NONE;

ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. Reason: Dropping a primary key is not allowed without also adding a new primary key. Try ALGORITHM=COPY.

mysql> ALTER TABLE employees DROP PRIMARY KEY, ALGORITHM=COPY, LOCK=SHARED;

Query OK, 300024 rows affected (6.24 sec)Records: 300024  Duplicates: 0  Warnings: 0

mysql> ALTER TABLE employees ADD PRIMARY KEY (emp_no), ALGORITHM=INPLACE, LOCK=NONE;

Query OK, 0 rows affected (1.48 sec)Records: 0  Duplicates: 0  Warnings: 0

```

1. ALGORITH=INSTANT 옵션으로 스키마 변경을 시도
2. 실패하면 ALGORITHM=INPLACE, LOCK=NONE 옵션으로 스키마 변경을 시도
3. 실패하면 ALGORITHM=INPLACE, LOCK=SHARED 옵션으로 스키마 변경을 시도
4. 실패하면 ALGORITHM=COPY, LOCK=SHARED 옵션으로 스키마 변경을 시도
5. 실패하면 ALGORITHM=COPY, LOCK=EXCLUSIVE 옵션으로 스키마 변경을 시도

스키마 변경 작업으로 인해 DML이 멈숴서는 안 된다면 1~2번까지 사용하는 것을 추천함

주의점
1. 1,2번이 실패한다면 서비스를 멈춘 후 스키마를 변경해야 함
2. 실행하고자 하는 스키마 변경이 1,2번 옵션으로 가능하더라도 MySQL 서버는 스키마 변경을 실행하게 되지만 온라인 DDL이라 하더라도 MySQL 서버에 부하를 유발할 수 있으며 다른 커넥션의 쿼리들이 느려질 수 있음

> 결론적으로 스키마 변경 작업이 다른 커넥션의 DML을 대기하게 만들지 않도록 주의해야 함




# 온라인 DDL의 실패 케이스

대부분 INPLACE 알고리즘으로 실행되는 경우 내부적으로 테이블 리빌드 과정이 필요할 때 자주 발생합니다.
INPLACE 알고리즘은 오랜 시간이 걸리기 때문에 실행되던 온라인 DDL이 실패하면 상당한 자원과 시간이 낭비됩니다.
> 추가적인 예시
1. ALTER TABLE 명령이 장시간 실행되고 다른 커넥션에서 DML이 많이 실행되는 경우
2. ALTER TABLE 명령이 실행되는 동안 이전 버전의 테이블 구조에서 문제가 없지만 변경된 테이블에서 문제가 생기는 경우
3. 스키마 변경을 위해서 필요한 잠금 수준보다 낮은 잠금 옵션이 사용 
4. 온라인 스키마 변경은 LOCK=NONE으로 실행했지만 변경의 처음과 마지막 과정에서 잠금이 필요한 경우
5. 온라인으로 인덱스를 생성하는 작업의 경우 정렬을 위해 tmpdir 시스템 변수에 설정된 디스크의 임시 디렉터리를 사용할 때 공간이 부족한 경우


# 온라인 DDL 진행 상황 모니터링

온라인 DDL 을 포함한 모든 ALTER TABLE 명령은 MySQL 서버의 performance_schema를 통해 진행 상황을 모니터링할 수 있습니다. 

온라인 DDL을 모니터링하려면 performance_schema 옵션이 ON으로 활성화돼야 합니다.
![[Pasted image 20240304152548.png|600]]
![[Pasted image 20240304152556.png|600]]
스키마 변경 작업의 진행 상황은 performance_schema.events_stages_current 테이블을 통해 확인할 수 있는데, 실행 중인 스키마 변경 종류에 따라 기록되는 내용이 상이합니다.

아래는 온라인 DDL이 아닌 전통적인 copy 알고리즘으로 스키마 변경이 진행되는 경우입니다.
![[Pasted image 20240304152734.png|600]]

스키마 변경 작업이 온라인 DDL로 실행되는 경우 다양한 상태를 보여주는데, 이는 온라인 ddl이 단계별로 event_name 컬럼의 값을 다르게 보여주기 때문입니다.

![[Pasted image 20240304152817.png | 600]]
![[Pasted image 20240304152829.png | 600]]

WORK_ESTIMATED와 WORK_COMPLETED 컬럼의 값을 비교해보면 ALTER TABLE의 진행상왕을 예측할 수 있지만 WORKESTIMATED 컬럼의 값은 예측치이기 때문에 ALTER TABLE이 진행되면서 조금씩 변경됩니다. 

# 데이터베이스 변경 

데이터베이스 생성 방법
![[Pasted image 20240304154651.png |600]]

데이터베이스 목록 조회
![[Pasted image 20240305162026.png]]
- 권한을 가진 테이블만 볼 수 있음

데이터베이스 선택 
![[Pasted image 20240305162059.png]]

데이터베이스 속성 변경
![[Pasted image 20240305162123.png]]
데이터베이스 삭제 
![[Pasted image 20240305162132.png]]


# 테이블 스페이스

MySQL에서 테이블스페이스는 데이터베이스 객체(테이블, 인덱스 등)를 저장하는 물리적인 공간을 의미합니다.
InnoDB 엔진의 시스템 테이블 스페이스는 제너럴 테이블 스페이스를 사용

제너럴 테이블 스페이스의 장점
1. 제너럴 테이블스페이스를 사용하면 파일 핸들러를 최소화
2. 테이블스페이스 관리에 필요한 메모리 공간을 최소화
단 위 두 장점 모두 테이블 개수가 많은 경우에 유용함

제너럴 테이블 스페이스의 제약사항
1. 파티션 테이블은 제너럴 테이블스페이스를 사용하지 못함
2. 복제 소스와 레플리카 서버가 동일 호스트에서 실행되는 경우 add datafile 문장 사용불가
3. 테이블 암호화는 테이블스페이스 단위로 설정
4. 테이블 압축 가능 여부는 테이블스페이스의 블록 사이즈와 innoDB 페이지 사이즈에 의해 결정
5. 특정 테이블을 삭제해도 디스크 공간이 운영체제로 반납되지 않음


# 테이블


테이블 생성
![[Pasted image 20240304160127.png|600]]

TEMPORARY
- 해당 키워드를 사용하면 데이터베이스 커넥션(세션) 에서만 사용 가능한 임시 테이블을 생성합니다.
- 같은 이름의 테이블이 있으면 에러가 발생합니다.
컬럼
- 컬럼명 + 컬럼타입 + [타입별 옵션] + [NULL 여부] + [기본값]


테이블 구조 조회
MySQL에서 테이블을 구조를 조회하는 방법
1. SHOW CREATE TABLE
2. DESC

SHOW CREATE TABLE 명령을 사용하면 CREATE TABLE 문장을 표시

![[Pasted image 20240304161535.png|600]]
SHOW CREATE TABLE 명령은 칼럼의 목록과 인덱스, 외래키 정보를 동시에 보여주기 때문에 SQL을 튜닝하거나 테이블의 구조를 확인할 때 주로 사용합니다.


DESC 명령은 테이블의 칼럼 정보를 보기 편한 표 형태로 표시해줍니다. 
다만 인덱스 커럶의 순서나 외래키, 테이블 자체의 속성을 보여주지는 않기 때문에 테이블의 전체적인 구조를 한 번에 확인하기는 어렵습니다.
![[Pasted image 20240305162907.png]]

테이블 구조 변경
![[Pasted image 20240304161912.png]]

테이블 이름 변경
![[Pasted image 20240304162642.png]]
리눅스의 MV 명령어 처럼 다른 데이터베이스로 옮기는 것 또한 가능합니다.

# 테이블 상태 조회


MySQL 모든 테이블은 만들어진 시간, 대략의 레코드 건수, 데이터 파일의 크기 등의 정보를 가지고 있습니다. 

또한 데이터 파일의 버전이나 레코드 포맷 등과 같이 자주 사용되는 않지만 중요한 정보도 가지고 있는데, 이러한 정보를 조회할 수 있는 명령이 `SHOW TABLE STATUS` 입니다.


![[Pasted image 20240304163701.png|600]]

show table status 명령뿐 아니라 select 쿼리를 이용해서 조회할 수 있습니다.

![[Pasted image 20240304163738.png|600]]


# 테이블 삭제
![[Pasted image 20240305163557.png]]
일반적으로 MySQl에서 레코드가 많지 않은 테이블을 삭제하는 작업은 서비스 도중이라고 하더라도 문제가 되지 않습니다. 
MySQL 8.0 버전에서는 특정 테이블을 삭제하는 작업이 다른 테이블의 DML이나 쿼리를 직접 방해하지는 않습니다. MySQL 서버에서 테이블 삭제는 DROP TABLE 명령으로 실행합니다. 

하지만 용량이 매우 큰 테이블을 삭제하는 작업은 상당히 부하가 큰 작업인데 테이블이 삭제되면  MySQL 서버는 해당 테이블이 사용하던 데이터 파이를 삭제해야 하는데 이 파일의 크기가 매우크고 디스크에서 파일의 조각들이 너무 분산되어 저장돼 있다면 많은 디스크 읽기 쓰기를 반복합니다.

즉 MySQL 서버의 디스크 읽고 쓰기 부하가 높아지면 다른 커넥션의 커리 처리성능이 떨어지는 것을 의미합니다.

그래서 테이블이 크다면 서비스 도중에 삭제 작업은 수행하지 않는 것이 좋습니다. 

테이블 삭제에서 한 가지 더 주의해야 하는 것은 InnoDB 스토리지 엔진의 어댑티브 해시 인덱스입니다. 

어댑티브 해시 인덱스는 INnnoDB 버퍼 풀의 각 페이지가 가진 레코드에 대한 해시 인덱스 기능을 제공하는데, 어댑티브 해시 인덱스가 활성화돼 있는 경우 테이블이 삭제되면 어댑티브 해시 인덱스 정보도 모두 삭제해야합니다. 

어댑티브 해시 인덱스가 삭제될 때 테이블에 대한 정보를 많이 가지고 있다면 어댑티브 해시 인덱스 삭제 작ㄷ업으로 인해 MySQL 서버의 부하가 높아지고 간접적으로 다른 쿼리 처리에 영향을 미칠 수 있습니다.



# 컬럼 변경

컬럼 추가
![[Pasted image 20240304165711.png|600]]

컬럼 삭제
![[Pasted image 20240304171129.png]]

컬럼 이름 및 타입 변경
![[Pasted image 20240305163725.png]]



# 인덱스 변경
MySQL 8.0 버전에서는 대부분의 인덱스 변경 작업이 온라인 ddl로 처리 가능하도록 개선됐습니다.

인덱스 추가
![[Pasted image 20240304171647.png|600]]

여기서 인덱스의 추가는 INPLACE 알고리즘을 사용하는 것을 알 수 있습니다.
전문 검색에서는 shared 옵션이 필요


인덱스 조회

SHOW INDEX FROM 명령으로 인덱스의 목록을 조회할 수 있습니다.
![[Pasted image 20240305172355.png]]

- KEY_NAME: 인덱스 이름
- SEQ_IN_INDEX: 인덱스에서 해당 컬럼의 위치
- CARDINALITY: 인덱스에서 해당 컬럼까지의 유니크한 값의 개수 
	- ix_gender_birthday 가 왜 4죠?


인덱스 이름 변경

이름 변경
![[Pasted image 20240305173001.png]]

내부 값을 변경
![[Pasted image 20240305173013.png]]


인덱스 가시성 변경

MySQL 서버가 인덱스를 사용하지 못하도록 막는 방법
![[Pasted image 20240305173144.png]]

invisible 상태의 인덱스를 다시 visible로 변경
![[Pasted image 20240305173228.png]]


인덱스 삭제

세컨더리 인덱스를 삭제하는 작업은 비교적 빠르게 실행됩니다. 하지만 프라이머리 키의 삭제 작업은 모든 인덱스의 리프 노드에 저장된 프라이머리 키 값을 삭제해야 하기 때문에 테이블을 재구축 하는 과정이 필요합니다.
![[Pasted image 20240305173309.png]]

프라이머리 키의 경우 잠금이 SHARED임

## 테이블 변경 묶음 실행

하나의 테이블에 대해 여러 가지 스키마를 변경하는 경우 ALTER TABLE 명령으로 차례대로 실행할 때가 있습니다. 온라인 DDL로 빠르게 스키마 변경을 처리할 수 있다면 개별로 실행하는 것이 좋지만 그렇지 않다면 모아서 실행하는 것이 효율적입니다. 

![[Pasted image 20240305132914.png]]

2개의 alter table 명령어로 인덱스를 각각 생성하면 인덱스를 생성할 때마다 테이블의 레코드를 스캔해서 인덱스를 생성합니다. 하지만 하나의 alter table 명령으로 모아서 실행하면 MySQL 서버는 테이블 레코드를 한 번만 풀 스캔해서 2개의 인덱스를 한꺼번에 생성할 수 있습니다.
![[Pasted image 20240305133027.png]]

2개의 인덱스를 한 번에 생성하면 인덱스 하나를 생성할 때보다 더 많은 시간일 걸리지만 2개의 인덱스를 각각 생성하는 데 걸리는 시간보다는 훨씬 시간을 단축할 수 있습니다.

단 서로 다른 알고리즘을 사용하는 경우라면 굳이 모아서 실행할 필요는 없습니다.


# 프로세스 조회 및 강제 종료

MySQL 서버에 접속된 사용자의 목록이나 각 클라이언트 사용자가 현재 어떤 쿼리를 실행하고 있는지는 SHOW PROCESSLIST 명령으로 확인할 수 있습니다.

SHOW PROCESSLIST 명령의 결과에는 현재 MySQL 서버에 접속된 클라이언트의 요청을 처리하는 스레드 수만큼의 레코드가 표시됩니다.

- ID : MySQQL 서버의 스레드 아이디, 쿼리나 커넥션을 강제 종료할 때는 컬럼값을 식별자로 사용
- User: 클라이언트가 MySQL 서버에 접속할 떄 인증에 사용한 계정
- Host: 클라이언트의 호스트명이나 IP주소
- DB: 클라이언트가 기본으로 사용하는 데이터베이스의 이름
- Command: 해당 스레드가 현재 어떤 작업을 처리하고 있는지 표시
- Time: Command 컬럼에 표시되는 작업이 얼마나 실행되고 있는지 표시
- State: Command 컬럼에 표시되는 내용이 해당 스레드가 처리하고 있는 작업의 큰 분류를 보여준다면 State 컬럼에는 소분류 작업 내용을 보여줌
- Info: 해당 스레드가 실행중인 쿼리 문장을 보여줌. 쿼리는 화면의 크기에 맞춰서 표시 가능한 부분까지만 표시
	- 전체를 보기 원한다면 SHOW FULL PROCESSLIST명령을 활용

SWHO PROCESSLIST 명령의 결과에서 ID 컬럼값은 접속된 커넥션의 요청을 처리하는 전용 스레드 번호인데 해당 스레드 id를 kill 하게 되면 실행 중인 쿼리나 커넥션 자체를 강제 종료할 수 있습니다. 


# 활성 트랜잭션 조회
쿼리가 오랜 시간 실행되고 있는 경우도 문제지만 트랜잭션이 오랜 시간 완료되지 않고 활성 상태로 남아있는 것도 MySQL 서버의 성능에 영향을 미칠 수 있습니다. 

MySQL 서버의 트랜잭션 목록은 information_schema.innodb_trx 테이블을 통해 확인할 수 있습니다.



# 쿼리 성능 테스트


## 쿼리의 성능에 영향을 미치는 요소

### 운영체제의 캐시
MySQL 서버는 운영체제의 파일 시스템 관련 기능(시스템 콜)을 이용해 데이터 파일을 읽어옵니다. 

일반적으로 운영체제는 한 번 읽은 데이터는 운영체제가 관리하는 별도의 캐시 영역에 보관해 뒀다가 해당 데이터가 요청되면 디스크를 읽지 않고 캐시의 내용을 바로 MySQL 서버로 반환합니다.

InnoDB 스토리지 엔진은 파일 시스템의 캐시나 버퍼를 거치지 않는 DirectI/O를 사용하므로 운영체제의 캐시가 큰 영향을 미치지 않지만 MyISAM 스토리지 엔진은 운영체제의 캐시에 대한 의존도가 높기 때문에 운영체제의 캐시에 따라 성능 차이가 큰 편입니다. 

운영체제가 관리하는 캐시나 버퍼는 공용 공간이기 떄문에 MySQL 서버와 같은 응용프로그램이 종료된다고 해도 여전히 남아있을 수 있습니다. 그래서 운영체제가 가지고 있는 캐시나 버퍼가 전혀 없는 상태에서 쿼리의 성능을 테스트 하려면 운영체제의 캐시 삭제 명령을 실행하고 테스트하는 것이 좋습니다.

![[Pasted image 20240305135953.png]]


### MySQL 서버의 버퍼 풀

운영체제의 버퍼나 캐시와 마찬가지로 MySQL 서버에서도 데이터 파일의 내용을 페이지(블록) 단위로 캐시하는 기능을 제공합니다. 

InnoDB 스토리지 엔진이 관리하는 캐시를 버퍼풀이라고 합니다.
여기서 InnoDB의 버퍼 풀은 인덱스 페이지는 물론이고 데이터 페이지까지 캐시하며, 쓰기 작업을 버퍼링 작업까지 겸해서 처리합니다.

InnoDB 버퍼 풀은 MySQL 서버가 종료될 때 자동으로 덤프됐다가 다시 시작될 때 자동으로 적재되는데 
innodb_buffer_pool_load_at_startup 시스템 변수를 off로 설정한 후 재시작 해야 합니다.

MySQL 서버가 종료될 때 버퍼 풀의 내용을 덤프하지 않고자 한다면 innodb_buffer_poll_dump_at_shutdown 시스템 변수도 off로 변경하면됩니다.


### 독립된 MySQL 서버
MySQL 서버가 기동 중인 장비에 웹 서버나 다른 배치용 프로그램이 실행되고 있다면 테스트하려는 쿼리의 성능이 영향을 받습니다. 

또한 테스트 쿼리를 실행하는 클라이언트 프로그램이나 네트워크의 영향 요소도 고려해야 합니다. 


### 쿼리 테스트 횟수

실제 쿼리의 성능 테스트를 MySQL 서버의 상태가 워밍업된 상태에서 진행할지 아니면 콜드 상태에서 진행할지 고려해야 합니다.

일반적으로 쿼리의 성능 테스트는 콜드 상태가 아닌 워밍업된 상태를 가정하고 테스트 합니다. 

그렇기에 어느 정도 사용량이 있는 서비스라면 콜드 상태에서 워밍업 상태로 전환하는데 그다지 오래 걸리지 않기 때문에 실제 서비스 환경의 쿼리는 대부분 콜드 상태보다 워밍업 상태에서 실행된다고 볼 수 있습니다. 

