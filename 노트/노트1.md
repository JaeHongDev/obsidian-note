<17.1> 요약
리액티브 프로그래밍이 나온 시점은 일반적인 방식으로 대규모 트래픽을 감당하기 힘든 상황에서 문제를 해결하기 위해 등장했다. 다양한 시스템과 소스에서 데이터 항목 스트림을 비동기적으로 처리하는 방법을 사용하고 이런 방식은 시스템에서 고장, 정전 같은 상태에 쉽게 대처하고 다양한 네트워크 상에서 메시지를 교환하고 전달할 수 있으며 무거운 작업을 하고 있는 상황에서도 가용성을 제공한다.


<17.1> 리액티브 매니페스토
리액티브 매니패스토는 2013년과 2014년에 걸쳐 개발되었으며 리액티브 애플리케이션과 시스템 개발의 핵심 원칙을 공식적으로 정의함
- 반응성(responsive): 리액티브 시스템은 빠르고, 중요하고, 조화롭고, 응답시간을 예상할 수 있다. 결국 사용자에게 애플리케이션에 대한 높은 신뢰성을 제공할 수 있다.
- 회복성(resilient): 컴포넌트중 일부가 장애가 발생하더라도 다른 컴포넌트는 실행 가능해야 한다.
- 탄력성(elastic): 애플리케이션의 생명주기 동안 다양한 작업 부하를 받을 때 리액티브 시스템에서는 컴포넌트에 할당된 자원의 수를 늘리는 것으로 해결 가능하다 -> 아마 서버의 코드를 고치지 않는 형태로 확장가능하다는 의미로 예상
- 메시지 드리븐, 메시지 기반(Message-driven): 회복성과 탄력성을 지원하기 위해 결합도를 낮추고, 고립, 위치 투명성 등을 지원할 수 있도록 시스템을 구성하는 컴포넌트의 경계를 명확하게 정의해야 한다. 비동기 메시지를 전달해 컴포넌트 끼리의 통신이 이루어진다.

반응성은 시스템에서 가능한한 적정 시간안에 반응한다. 반응성이 뒷받침 되어야 사용성을 높일 수 있다.

탄력성은 다양한 작업 부하에도 시스템 반응성이 유진된다. 입력 속도가 바뀐다면 이를 이들 입력 관련 서비스에 할당된 자원을 늘리거나 줄임으로 반응할 수 있다. 

회복성은 장애 시에도 시스템의 반응성은 유지된다.

메시지 주도는 컴포넌트 간의 약한 결합, 고립, 위치 투명성이 유지되도록 시스템은 비동기 메시지 전달에 의존한다.

그래서 여기서 이야기하는 반응성은 뭘까?

![[Pasted image 20230917223023.png]]
gpt 가 말하는 반응성


### 17.1.1 애플리케이션 수준의 리액티브
애플리케이션 수준 컴포넌트의 리액티브 프로그램의 주요 기능은 비동기로 작업을 수행하여 멀티코어 CPU의 사용률을 극대화하는 방법이다. 목표를 달성할 수 있도록  퓨처, 액터, 콜백메서드, 이벤트 루프와 같은 기능을 사용할 수 있습니다. 
이들 기술은 스레드보다 가벼우며 개발자에게 큰 이득을 제공한다. 개발자 입장에서는 이들 기술을 이용함으로 동시성, 비동기 애플리케이션의 추상 수준을 높일 수 있으므로 동기 블록, 경쟁 상태, 데드락 같은 저 수준의 멀티스레드 문제를 처리할 필요가 없어지며 비즈니스 요구사항을 구현하는데 더 집중할 수 있다.

> 핵심은 이들 기술을 이용하는 것으로 동기 블로킹, 경쟁 상태, 데드락 같은 저 수준의 멀티스레드 문제를 직접 처리할 필요가 없어지면서 비즈니스 요구사항을 구현하는 데 더 집중할 수 있다.

스레드를 다시 나누는 종류의 기술을 이용할 때는 메인 이벤트 루프 안에서는 절대 동작을 블로킹하지 않아야 한다는 전제 조건이 항상 따라온다.

두 스레드를 포함하는 스레드 풀에서 이벤트 스트림 세 개를 처리하는 상황에서 한 번에 오직 두 개의 스트림을 처리할 수 있는 상황이므로 가능하면 스트림은 두 스레드를 효율적이고 공정하게 공유해야 한다. 
하지만 어떤 스트림의 이벤트를 처리하다보니 파일 시스템을 사용거나 블로킹되는 api를 이용해 데이터베이스에 데이터를 가져오는 등 느린 i/o 작업이 발생하면 스레드 풀은 이를 기다린다.

이런 상황에서 메인 풀의 모든 스레드는 방해받지 않고 실행되기 위해 별도의 지정된 스레드 풀에서 블로킹 동작을 실행시켜 문제를 해결 할 수 있다. 



## 17.2 리액티브 스트림과 Flow API
리액티브 프로그래밍은 리액티브 스트림을 사용하는 프로그래밍 방식이다. 리액티브 스트림은 잠재적으로 무한의 비동기 데이터를 순서대로 그리고 블로킹하지 않고 역압력으로 처리하는 표준 기술이다.

역압력은 발행-구독 프로토콜에서 이벤트 스트림의 구독자가 발행자에게 이벤트를 늦게 처리하는 문제가 발생하지 않도록 보장하는 장치이다.

결국 리액티브 스트림과 Flow API의 존재 이유는 기존의 아키텍처로 처리하기 힘든 수준의 데이터를 효율적으로 처리하기 위해 고안한 방식이다.

### Flow 클래스 소개

자바 9에서 리액티브 프로그래밍을 제공하는 `java.util.concurrent.Flow` 클래스를 추가 했다. Flow 클래스는 중첩된 인터페이스 네 개를 가진다.
- Publisher
- Subscriber
- Subscription
- Processor
![[Pasted image 20230918152524.png]]
Publisher가 항목을 발행하면 Subscriber가 한 개씩 또는 한 번에 여러 항목을 소비하는데 Subscription이 이 과정을 관리할 수 있도록 Flow 클래스는 관련된 인터페이스와 정적 메서드를 제공한다.

Publisher는 수 많은 일련의 이벤트를 제공할 수 있다. 추가로 Subscriber의 요구사항에 따라 역압력 기법에 의해 이벤트 제공 속도 제한을 받을 수 있다. 함수형 인터페이스로 구성되어 있으며 Subscriber는 Publisher가 발행한 이벤트 리스너로 자신을 등록할 수 있다.
> 이전 챕터에서 봤던 것과 동일하게 생각하면 될 것 같다.
> 
![[Pasted image 20230918153830.png]]

반면 Subscriber 인터페이스는 Publisher가 관련 이벤트를 발행할 때 호출할 수 있도록 콜백 메서드 네 개를 정의한다.

![[Pasted image 20230918153934.png]]

- Publisher는 반드시 Subscription의 request 메서드에 정의된 개수 이하의 요소만 Subscriber에 전달해야 한다. 하지만 Publisher는 지정된 개수보다 적은 수의 요소를 onNext로 전달할 수 있으며 동작이 끝났으면 onComplete를 호출하고 문제가 발생하면 onError를 호출해 Subscription을 종료할 수 있다.
- Subscriber는 요소를 받아 처리할 수 있음을 Publisher에 알려야 한다. 이런 방식으로 Subscriber는 Publisher에 역압력을 행사할 수 있고 Subscriber가 관리할 수 없이 너무 많은 요소를 받는 일을 피할 수 있다.

###  첫 번째 리액티브 애플리케이션 만들기
Flow 클래스에 정의된 인터페이스 대부분은 직접 구현하도록 의도된 것이 아니다.
-> 자바 9 이전부터 리액티브 프로그래밍을 지원하기 위해 외부 라이브러리가 존재 했음
-> 자바는 Flow 클래스의 명세를 통해 이들 라이브러리가 준수해야 할 규칙과 다양한 리액티브 라이브러릴 이용해 개발된 리액티브 애플리케이션이 서로 협동하고 소통할 수 있는 공용어를 제시한다.

> 만들 애플리케이션

리액티브 원칙을 적용한 온도를 보고하는 간단한 프로그램.
두 컴포넌트를 가짐
- TempInfo, 원격 온도계를 흉내 낸다 (0~99 사이의 화씨 온도를 임의로 만들어 연속적으로 보고)
- TempoSubscriber. 레포트를 관찰하면서 각 도시에 설치된 센서에서 보고한 온도 스트림을 출력한다.


> 발생하는 문제점

지금까지 개발한 코드에는 에러를 발생시크는 코드가 감춰진 상태다. 에러를 발생시키는 코드가 없으면 호출 스택이 가득 찰 때 까지 계속해서 반복되며 이는 스택오버플로우가 발생하게 된다.

스택 오버플로우를 해결하기 위한 방법은 Executor를 TempSubscription으로 추가한 다음 다른 스레드에서 TempSubscriber로 새 요소를 전달하는 방법이 있다.


### Processor로 데이터 변환하기

절에서 설명한 것처럼 Processor는 subscriber이며 동시에 Publisher다. Processor의 목적은 Publisher를 구독한 다음 수신한 데이터를 가공해서 제공하는 것이다.



### 자바는 왜 플로 API 구현을 제공하지 않는가?
일반적으로 자바 라이브러리는 보통 인터페이스와 구현을 제공하는 반면 플로 API는 구현을 제공하지 않기에 사용하려면 직접 인터페이스를 구현해야 한다. 이는 FLOW API를 만들 당시 다양한 리액티브 스트림의 자바 코드 라이브러리가 이미 존재했기 떄문이다. 즉 표준화를 위해 존재하는 기능이다. 



### Observable 만들고 사용하기
Observable, Flowable 클래스는 다양한 종류의 리액티브 스트림을 편리하게 만들 수 있도록 여러 팩토리 메서드를 제공한다.

다음처럼 미리 정의한 몇 개의 요소를 이용해 간단한 Observable을 만들 수 있다.


## 함수형 관점으로 생각하기

자바 8에서 스트림을 이용하면 스레드의 lock 관련 문제를 피할 수 있는데 이를 위해 상태가 없는 동작이어야 합니다. 즉 스트림 파이프라인의 함수는 다른 누군가가 변수의 값을 바꿀 수 있는 상태에 있는 변수를 사용하지 않습니다. 결국 병렬 처리 혹은 스트림 파이프라인을 잘 사용하는 것은 쉽게 유지보수할 수 있는 코드를 만드는 것에 기인합니다. 쉽게 유지보수 할 수 있는 코드는 좋은 코드이며 이는 시스템의 각 부분의 상호 의존성을 가리키는 결합도와 응집도라는 구조로 평가하는데 함수형 프로그램은 이런 부분에서 사이드 이펙트 제거와 불변성이라는 개념을 제공합니다.

### 공유된 가변 데이터
변수가 예상하지 못한 값을 갖는 이유는 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문입니다. 
만약 리스트를 참조하는 클래스가 여러개 일 때 해당 리스트의 소유자는 어떤 클래스인지 혹은 어떻게 추적하는지와 같은 방식이 정해져 있지 않으면 관리하기 상당히 어렵습니다. 
만약 변하지 않는 자료구조를 가진 시스템이 있다고 가정하면 해당 시스템에서 오류가 발생한다면 어떤 부분에서 문제가 생겼는지 식별하는 것은 어렵지는 않습니다(버그를 해결하는 것은 다른 상황이라고 생각).
즉 입력과 출력의 결과를 예상하기 쉬운 형태 메서드가 순수하고 사이드 이펙트가 없는 메서드가 여기에 해당합니다.
추가로 불변 객체를 사용하는 방법도 여기에 해당하죠. 불변 객체를 사용하는 것으로 스레드 안정성을 얻는 이점이 있듯이 결국 외부 변화로 인한 부작용을 없애는 것이 시스템 안정성을 올리는 가장 좋은 방법이라고 이야기할 수 있습니다. 그리고 이를 선언형 프로그래밍이라고 부릅니다.

### 선언형 프로그래밍 
선언형 프로그래밍은 어떻게에 집중하는 것이 아닌 무엇을 하는지에 집중하는 방식입니다. 저희가 주로 사용하는 스트림 api를 보면 어떤 처리의 질의하는 방식으로 이루어지는데 대표적인 예시라고 할 수 있습니다. 


### 왜 함수형 프로그래밍인가?
함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며 부작용이 없는 계산을 지향합니다. 즉 부작용을 멀리한다는 개념에서 시스템의 유지보수를 높이는 특징이 있습니다. 

이전에 학습한 람다 표현식 처럼 언어에서 제공하는 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 방식을 사용합니다. 스트림 API를 활용하여 여러 연산을 연결해서 복잡한 질의를 표현할 수 있는 것도 여기에 해당합니다. 

## 함수형 프로그래밍이란 무엇인가
함수형 프로그래밍에서 `함수`는 수학적인 함수와 같은 의미를 가집니다. 즉 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하며 사이드 이펙트가 없어야 합니다. 
![[Pasted image 20230919000247.png]]
즉 입력과 출력이 명확한 형태로 구분되는 것이 그 특징 중 하나입니다. 덧붙혀서 같은 입력이 반복해서 들어오면 같은 출력을 내보내는데 이는 수식에서도 마찬가지로 생각할 수 있습니다. 

### 함수형 자바
실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다(I/O). 다만 시스템의 컴포넌트 순수한 함수형인 것처럼 동작하도록 코드를 구현할 수 있다. 실제로 부작용이 있긴 하지만 아무도 이를 보지 못하게 함으로써 함수형을 달성할 수 있다. 자바에서 함수형은 함수나 메서드가 참조하는 객체가 있을 때 해당 객체는 불변 객체여야 합니다. 즉 모든 필드가 final이어야하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다. 예외적으로 생성한 객체의 필드는 개신할 수 있다.

