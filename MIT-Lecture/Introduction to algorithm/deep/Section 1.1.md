---
cssclasses:
  - my_style_width_100
---

The study of algorithms for effective procedures to solve problem.

알고리즘 연구는 문제를 효율적으로 해결하기 위한 절차를 찾는 것입니다.
알고리즘을 배우는 것은 문제를 효율적으로 해결하는 것 뿐만 아니라 다른 사람에게 올바르고 효율적인 해결책을 전달하기 위함입니다.

- 문제는 문제의 입력과 출력을 올바르게 연결하는 이진 관계입니다.


어떤 알고리즘 문제를 풀고자할 때 그 문제가 효율적이거나 올바른 것을 어떻게 알 수 있을까?

### Problem의 정의
문제(problem) 입력값과 그에 해당하는 올바른 출력값 사이의 관계를 말합니다. 



# 효율

효율적인 컴퓨터 프로그램은 무엇일까요? 

단순하게 생각해보면 A,B라는 프로그램이 있을 때 같은 입력을 받고 동일한 결과를 냈을 때 A가 B보다 더 적은 자원, 시간을 사용한다면 A가 B보다 효율적이라고 할 수 있습니다.

느린 컴퓨터, 빠른 컴퓨터로 실행 했을 때 당연하게도 하드웨어 성능이 좋은 컴퓨터가 훨씬 빠릅니다.

그렇기에 우리는 효율적인 프로그램을 비교하기 위해서는 하드웨어의 차이에 따른 Constant factor를 무시하기 위한 방법이 필요합니다.

알고리즘에서 이를 비교하기 위해 문제 입력의 크기에 따른 점근적 성능을 통해서 어떤 프로그램이 더 효율적인지 비교합니다.


# 점근적 표기법

문제 입력의 크게에 따라 변하지 않는 상수를 무시하기 위해 점근적 표기법을 사용할 수 있습니다.

$O(f(n))$ 는 자연수를 정의역으로 하는  함수의 집합으로 아래의 조건을 만족합니다
- O Notation:  음수가 아닌 함수  $g(n)$ 이 $O(f(n))$ 에 속한다는 것은, 양의 실수 c와 양의 정수 $n_0$ 가 존재하여 모든 $n>=n_0$ 에 대해 $g(n) <= c · f(n)$  
충분히 큰 규모의 입력에 대한 함수의 점진적 증가에 대한 상한선을 정의하는 것입니다. 다른 말로 함수를 상수만큼 스케일링하거나 이동시켜도 점근적 증가에 대한 제한은 여전히 유효하다.

관례에 따라 함수 $g(n)$ 이 $O(f(n))$이라고 하거나 $O(f(n))$ 과 같다고 말하는 것이 더 일반적이다, 하지만 실제로 의미하는 것은 집합의 포함이며, $g(n)$ 이 $O(f(n))$ 에 속한다는 것이다.

그래서 입력사이즈에 대한 문제들은 어떤 상수 c에 대한 cn이기 때문에, 우리는 c를 지우고 입력 사이즈를 O(n)이라고 합니다.

하한선에 대한 유사한 표기법으로 사용할 수 있습니다.
- $Ω$ Notation: 음수가 아닌 함수  $g(n)$ 이 $Ω(f(n))$ 에 속한다는 것은, 양의 실수 c와 양의 정수 $n_0$ 가 존재하여 모든 $n>=n_0$ 에 대해 $g(n) <= c · f(n)$  
한 함수가 다른 함수에 대해 동시에 점근적 상한과 점근적 하한을 모두 제공할 때, 우리는 Θ(세타) 표기법을 사용합니다. g(n) = Θ(f(n))일 때, f(n)이 g(n)에 대한 타이트한(정확한) 경계를 나타낸다고 말합니다.
- $Θ$ Notation: Non-negative g(n) is in Θ(f(n)) if and only if g(n) ∈ O(f(n)) ∩ Ω(f(n)).

선형 시간은 전체 입력을 읽어야만 문제를 해결할 수 있는 경우에 종종 필요합니다. 하지만, 입력이 이미 메모리에 접근 가능한 상태라면 많은 문제들을 선형 미만의 시간에 해결할 수 있습니다. 예를 들어, 이미 메모리에 로드된 정렬된 배열에서 특정 값을 찾는 문제는 이진 탐색을 통해 로그 시간에 해결할 수 있습니다. 이 수업에서는 일반적으로 c의 작은 값에 대해 다항식 시간 알고리즘에 초점을 맞춥니다. 로그, 선형, 지수 사이에는 큰 차이가 있습니다. 예를 들어, n이 1000일 때, log n은 약 101, n은 약 10^3, 반면 2^n은 약 10^300입니다. 비교를 위해, 우주의 원자 수는 대략 10^80으로 추정됩니다. 문제 입력 크기에 선형적인 매개변수를 나타내는 데 'n' 변수를 사용하는 것이 일반적이지만, 항상 그런 것은 아닙니다. 예를 들어, 학기 후반에 그래프 알고리즘에 대해 이야기할 때, 문제 입력은 정점 집합 V와 간선 집합 E로 매개변수화된 그래프가 될 것이므로, 자연스러운 입력 크기는 Θ(|V| + |E|)가 됩니다. 반대로, 행렬 알고리즘에 대해 이야기할 때는 n을 정사각 행렬의 너비로 설정하는 것이 일반적입니다.

### 🤔 이해가 안가는 내용1
음수가 아닌 함수 g(n)이 O(f(n))에 속한다는 것은, 양의 실수 c와 양의 정수 $n_0$가 존재하여 모든 $n ≥ n0$에 대해 $g(n) ≤ c · f(n)$을 만족할 때에만 해당된다는 의미입니다.

빅 오 표기법(Big O notation)을 사용하여 함수 g(n)이 O(f(n))에 속한다고 말하는 이유는, 이 표기법이 함수의 상한을 정의하기 때문입니다. 여기서의 상한은 함수의 성장률을 나타내는 것으로, 알고리즘의 시간 복잡도나 공간 복잡도를 분석할 때 중요한 개념입니다. 이를 구체적으로 설명하면 다음과 같습니다:

1. **함수의 상한 정의**: 빅 오 표기법은 주어진 함수 g(n)의 상한을 정의합니다. 여기서 '상한'이란, 함수 g(n)의 성장률이 특정한 조건 아래에서 다른 함수 f(n)의 성장률을 초과하지 않는다는 것을 의미합니다.
    
2. **양의 실수 c와 양의 정수 n0의 존재**: 이 조건은 함수 g(n)이 f(n)에 의해 어떻게 제한되는지를 구체화합니다. c와 n0를 찾을 수 있다는 것은, n이 충분히 크면 g(n)의 성장률이 f(n)의 성장률에 비례하여 제한된다는 것을 의미합니다.
    
3. **모든 n ≥ n0에 대한 조건**: 이 조건은 성장률의 비교가 n이 충분히 클 때만 의미가 있다는 것을 나타냅니다. 작은 n에 대해서는 g(n)과 f(n)의 관계가 다를 수 있지만, 복잡도 분석에서 중요한 것은 n이 클 때의 행동입니다.
    
4. **g(n) ≤ c · f(n)의 의미**: 이 부분은 g(n)의 성장률이 c배 f(n)의 성장률보다 항상 작거나 같다는 것을 나타냅니다. 즉, g(n)의 성장 속도가 f(n)의 성장 속도의 상수배를 넘지 않음을 의미합니다.
    

따라서, "음수가 아닌 함수 g(n)이 O(f(n))에 속한다"는 것은 g(n)의 성장률이 f(n)의 성장률에 의해 유사한 방식으로 제한되며, 이를 통해 g(n)의 상한을 f(n)으로 표현할 수 있다는 것을 의미합니다. 이는 알고리즘의 효율성을 비교하거나 이해할 때 중요한 도구입니다.


## 🤔 테이블 용어
  
이 용어들은 알고리즘의 복잡도를 설명하는 데 사용되며, 각각 알고리즘의 실행 시간이나 공간 요구 사항이 입력 크기에 따라 어떻게 변화하는지를 나타냅니다. 다음은 각 용어에 대한 설명입니다:

1. **Shorthand (약식 표기법)**: 이 용어는 복잡도를 표현하는 데 사용되는 간단한 기호 또는 표기법을 의미합니다. 예를 들어, O(n), Θ(n^2), O(log n) 등이 이에 해당합니다.
    
2. **Constant (상수)**: 상수 복잡도는 입력 크기에 상관없이 일정한 실행 시간 또는 공간 요구 사항을 가집니다. 표기법으로는 O(1)로 표현됩니다. 예를 들어, 간단한 할당 연산이나 특정 값 반환 등이 이에 해당합니다.
    
3. **Logarithmic (로그)**: 로그 복잡도는 입력 크기가 커질수록 실행 시간이 로그함수의 비율로 증가합니다. 표기법으로는 O(log n)입니다. 이진 탐색이 대표적인 예입니다.
    
4. **Linear (선형)**: 선형 복잡도는 입력 크기에 비례하여 실행 시간 또는 공간이 증가합니다. 표기법으로는 O(n)으로 표현됩니다. 예를 들어, 단일 루프를 사용하여 배열을 순회하는 경우가 이에 해당합니다.
    
5. **Quadratic (2차)**: 2차 복잡도는 입력 크기의 제곱에 비례하여 실행 시간 또는 공간이 증가합니다. 표기법으로는 O(n^2)입니다. 이중 루프를 사용하는 알고리즘이 대표적인 예입니다.
    
6. **Polynomial (다항식)**: 다항식 복잡도는 입력 크기의 거듭제곱에 비례하는 실행 시간을 가집니다. 표기법으로는 O(n^k) (k는 양의 정수)로 표현됩니다. 예를 들어, 삼중 루프(3차 복잡도) 등이 이에 해당합니다.
    
7. **Exponential (지수)**: 지수 복잡도는 입력 크기가 커질수록 실행 시간이 지수적으로 증가합니다. 표기법으로는 O(2^n)과 같이 표현됩니다. 예를 들어, 일부 재귀적 알고리즘이나 조합 문제 해결 알고리즘이 이에 해당합니다.