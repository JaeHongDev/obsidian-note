---
cssclasses:
  - my_style_width_100
---

## Sequence Interface

시퀀스는 외부적 순서로 항목들의 모음을 유지하는데, 여기서 저장된 각 항목은 시퀀스 내에서 순위를 가지며, 첫 번째 항목과 마지막 항목을 포함합니다. 여기서 '외부적'이라는 말은 첫 번째 항목이 그 항목 자체 때문에 '첫 번째'가 아니라, 어떤 외부 주체가 그것을 거기에 놓았기 때문이라는 뜻입니다. 시퀀스는 스택과 큐의 일반화로서, 시퀀스 연산의 부분 집합을 지원합니다.

![[Pasted image 20240123154242.png]]
> `insert_`, `delete_`는 모든 항목들의 순위를 변경시킵니다.

## Set interface 
반대로, 세트는 항목들이 무엇인지에 대한 본질적인 특성을 바탕으로 항목들의 모음을 유지합니다. 
이는 보통 각 항목 x에 연결된 고유한 키, x.key를 기반으로 합니다. 세트는 사전과 기타 본질적 질의 데이터베이스의 일반화입니다.

![[Pasted image 20240123154726.png]]



## Sequence Implementation
  
여기서 우리는 시퀀스 인터페이스를 구현하기 위한 세 가지 데이터 구조에 대해 논의할 것입니다. 문제 세트 1에서, 여러분은 연결 리스트와 동적 배열을 확장하여 각각의 첫 번째와 마지막 동적 연산을 O(1) 시간에 수행할 수 있게 만들 것입니다. 이 데이터 구조들 중 어느 것도 선형 이하 시간에 임의의 인덱스에서 동적 연산을 지원하지 않는다는 점에 주목하세요. 우리는 강의 7에서 이 연산을 개선하는 방법을 배울 것입니다.![[Pasted image 20240123155021.png]]

### Array Sequence
컴퓨터 메모리는 한정된 자원입니다.
근대 컴퓨터의 많은 프로세스들은 같은 메모리 저장소를 공유할 수 있습니다. 그래서 운영체제는 각각의 활성화된 프로세스에 메모리의 고정된 청크를 할당합니다 
할당된 메모리의 양은 프로세스의 필요와 사용 가능한 여유 메모리에 따라 달라집니다. 

예를 들어 컴퓨터 프로그램이 변수를 저장하기 위한 요청을 했을 때, 프로그램은 운영체제에게 변수를 저장하기 위해 메모리가 얼만큼 필요한지 알려야 합니다.

요청을 충족시키기 위해, 운영 체제는 프로세스에 할당된 메모리 주소 공간에서 사용 가능한 메모리를 찾아 그 목적을 위해 예약(즉, 할당)할 것이며, 할당된 메모리 주소 공간이 더 이상 필요하지 않을 때까지 유지됩니다.



컴퓨터 프로그램이 64비트 단어 열 개씩 저장하는 두 개의 배열을 저장하고자 한다고 가정해 봅시다. 
프로그램은 메모리의 두 덩어리(각각 640비트)에 대해 별도의 요청을 하고, 예를 들어 운영체제는 프로세스에 할당된 주소 공간의 첫 번째 단어를 첫 번째 배열 A에, 그리고 주소 공간의 두 번째 열 단어를 두 번째 배열 B에 예약함으로써 요청을 충족시킵니다. 
이제 컴퓨터 프로그램이 진행됨에 따라 배열 A에 열한 번째 단어 w를 추가해야 한다고 가정해 봅시다. A 근처에 새 단어를 저장할 공간이 없어 보입니다: 프로세스에 할당된 주소 공간의 시작이 A의 왼쪽에 있고 배열 B는 오른쪽에 저장되어 있습니다. 

그렇다면 우리는 어떻게 w를 A에 추가할 수 있을까요? 한 가지 해결책은 B를 오른쪽으로 이동하여 w를 위한 공간을 만드는 것이지만, B 옆에 이미 예약된 엄청난 양의 데이터도 이동시켜야 할 수 있습니다. 

더 나은 방법은 새로운 메모리에 열한 개의 단어를 요청하고, A를 새 메모리 할당의 시작 부분에 복사하고, w를 끝에 저장한 다음, 프로세스의 주소 공간 첫 열 단어를 미래의 메모리 요청을 위해 해제하는 것일 것입니다.

고정 길이 배열은 우리의 계산 모델의 기본이 되는 있는 자료구조 입니다.



## Linked List Sequence

LinkedList는 완전히 다른 종류의 자료구조입니다.

item을 메모리에 저장하기 위해서 인접한 메모리의 청크에 할당하는 대신에
링크드 리스트는 각 노드에 항목을 저장합니다.

연결 리스트는 각 항목을 노드라는 두가지 속성을 가진 일정한 크기의 컨테이너에 저장합니다.
- node.item 은 항목을 저장
- node.next 시퀀스에 포함될 다음 item을 node에 메모리 주소를 저장함

이러한 데이터 구조는 때때로 포인터 기반 또는 연결된 것이라고 불리며, 구성 항목이 메모리 어디에나 저장될 수 있기 때문에 배열 기반 데이터 구조보다 훨씬 유연합니다. 연결 리스트는 리스트의 첫 번째 요소를 저장하는 노드, 즉 리스트의 '헤드(head)'의 주소와 함께 연결 리스트의 크기, 즉 연결 리스트에 저장된 항목의 수를 저장합니다. 리스트의 다른 항목 뒤에 항목을 추가하는 것은 주소를 변경하는 것(즉, 포인터를 재연결하는 것)에 의해 쉽게 이루어집니다. 특히, 리스트의 앞부분(헤드)에 새 항목을 추가하는 것은 $O(1)$ 시간이 걸립니다. 그러나, 시퀀스에서 i번째 항목을 찾는 유일한 방법은 항목을 하나씩 거쳐가는 것이며, 이는 최악의 경우 get at과 set at 연산에 선형 시간이 걸립니다.



## Dynamic Array

배열의 동적 시퀀스 연산은 배열 A의 길이에 대해 선형 시간이 필요합니다. 요소를 추가할 때마다 선형 오버헤드 전송 비용을 지불하지 않고 배열에 요소를 추가하는 다른 방법이 있을까요? 빠른 삽입을 지원하기 위한 한 가지 간단한 방법은 배열에 대한 공간을 요청할 때 추가 공간을 과할당하는 것입니다. 그렇게 하면, 새 항목을 삽입하는 것은 다음 빈 슬롯에 새 값을 복사하는 것만큼 간단해집니다. 이 타협은 조금 더 많은 공간을 상수 시간 삽입을 위해 교환합니다. 듣기에는 좋은 거래처럼 보이지만, 어떤 추가 할당도 한계가 있을 것이고, 결국 반복된 삽입으로 추가 공간이 차게 되면 배열은 다시 재할당되고 복사되어야 합니다. 또한, 예약하는 추가 공간은 프로그램의 다른 부분에 사용할 수 있는 공간이 줄어들 것을 의미합니다.

그렇다면 Python이 어떻게 길이 n인 Python 리스트의 끝에 최악의 경우 \(O(1)\) 시간에 추가하는 것을 지원할까요? 대답은 간단합니다: 그렇지 않습니다. 때때로 Python 리스트의 끝에 추가하는 것은 메모리의 더 큰 할당으로 배열을 전송하는 데 \(O(n)\) 시간이 걸릴 수 있으므로, 때때로 Python 리스트에 추가하는 것은 선형 시간이 걸립니다. 그러나, 추가 공간을 올바르게 할당하면 \(n\)번의 삽입 시퀀스가 최대 \(O(n)\) 시간만 걸린다는 것을 보장할 수 있습니다(즉, 선형 시간 전송 작업은 자주 발생하지 않음), 따라서 삽입은 평균적으로 \(O(1)\) 시간이 걸립니다. 이러한 점근적 실행 시간을 할당된 상수 시간이라고 부릅니다. 왜냐하면 작업의 비용이 많은 작업 응용에 걸쳐 할당(분산)되기 때문입니다.

배열에 삽입하는 것에 대해 할당된 상수 실행 시간을 달성하기 위해, 우리의 전략은 저장되는 배열의 크기에 비례하여 추가 공간을 할당하는 것입니다. $O(n)$의 추가 공간을 할당함으로써 삽입이 할당을 초과하기 전에 선형 수의 삽입이 발생해야 합니다. 동적 배열의 일반적인 구현은 현재 배열을 저장하는 데 필요한 공간의 두 배를 할당합니다. 이것은 때때로 테이블 두 배로 불리기도 합니다. 그러나, 어떤 상수 비율의 추가 공간을 할당해도 할당된 경계를 달성할 수 있습니다. Python 리스트는 다음과 같은 공식에 따라 추가 공간을 할당합니다(C로 작성된 Python 소스 코드에서):
```
new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6);
```
여기서 추가 할당은 소박합니다. 추가되는 배열 크기의 약 1/8에 해당합니다(크기를 오른쪽으로 3비트 시프트하는 것은 8로 나눈 것과 같습니다). 하지만 추가 할당은 여전히 배열 크기에 선형이므로 평균적으로 \(n/8\) 삽입이 배열의 선형 시간 할당마다 수행됩니다. 즉, 할당된 상수 시간입니다.

배열의 끝에서 항목을 제거하고 싶다면 어떻게 할까요? 배열의 마지막 항목을 제거하는 것은 배열의 저장된 길이를 감소시키는 것만큼 간단하게 상수 시간 내에 발생할 수 있습니다(이것은 Python이 하는 일입니다). 그러나, 큰 리스트에서 많은 항목을 제거하는 경우, 사용되지 않는 추가 할당은 다른 용도로 사용할 수 없는 상당한 양의 낭비된 메모리를 차지할 수 있습니다. 배열의 길이가 충분히 작아지면, 배열의 내용을 더 작은 새 메모리 할당으로 옮겨서 더 큰 메모리 할당을 해제할 수 있습니다. 이 새 할당은 얼마나 커야 할까요? 배열의 크기에 어떤 추가 할당도 없이 할당한다면, 즉시 삽입이 다른 할당을 유발할 수 있습니다. \(n\)번의 추가 또는 팝 시퀀스에 대해 상수 할당된 실행 시간을 달성하기 위해서는, 더 작은 배열로 재건축할 때 사용되지 않는 할당된 공간의 선형 비율이 남아 있어야 합니다. 이것은 다음 번에 메모리를 재할당할 필요가 있기 전에 최소한 \(Ω(n)\) 연속 동적 작업이 발생해야 함을 보장합니다.

아래는 동적 배열 시퀀스의 Python 구현입니다. 여기에는 테이블 두 배 비율을 사용하는 연산 last 삽입(i.e., Python list append)과 last 삭제(i.e., Python list pop)가 포함됩니다. 할당 끝을 넘어서 추가하려고 할 때, 배열의 내용은 두 배 크기의 할당으로 옮겨집니다. 할당의 1/4까지 제거되면, 배열의 내용은 반으로 줄어든 할당으로 옮겨집니다. 물론 Python 리스트는 이미 이러한 기술을 사용하여 동적 작업을 지원합니다. 이 코드는 할당된 상수 append 및 pop을 어떻게 구현할 수 있는지 이해하는 데 도움이 되도록 제공됩니다.