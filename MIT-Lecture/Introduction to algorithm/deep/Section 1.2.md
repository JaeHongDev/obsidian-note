---
cssclasses:
  - my_style_width_100
---

## Sequence Interface

시퀀스는 외부적 순서로 항목들의 모음을 유지하는데, 여기서 저장된 각 항목은 시퀀스 내에서 순위를 가지며, 첫 번째 항목과 마지막 항목을 포함합니다. 여기서 '외부적'이라는 말은 첫 번째 항목이 그 항목 자체 때문에 '첫 번째'가 아니라, 어떤 외부 주체가 그것을 거기에 놓았기 때문이라는 뜻입니다. 시퀀스는 스택과 큐의 일반화로서, 시퀀스 연산의 부분 집합을 지원합니다.

![[Pasted image 20240123154242.png]]
> `insert_`, `delete_`는 모든 항목들의 순위를 변경시킵니다.

## Set interface 
반대로, 세트는 항목들이 무엇인지에 대한 본질적인 특성을 바탕으로 항목들의 모음을 유지합니다. 
이는 보통 각 항목 x에 연결된 고유한 키, x.key를 기반으로 합니다. 세트는 사전과 기타 본질적 질의 데이터베이스의 일반화입니다.

![[Pasted image 20240123154726.png]]



## Sequence Implementation
  
여기서 우리는 시퀀스 인터페이스를 구현하기 위한 세 가지 데이터 구조에 대해 논의할 것입니다. 문제 세트 1에서, 여러분은 연결 리스트와 동적 배열을 확장하여 각각의 첫 번째와 마지막 동적 연산을 O(1) 시간에 수행할 수 있게 만들 것입니다. 이 데이터 구조들 중 어느 것도 선형 이하 시간에 임의의 인덱스에서 동적 연산을 지원하지 않는다는 점에 주목하세요. 우리는 강의 7에서 이 연산을 개선하는 방법을 배울 것입니다.![[Pasted image 20240123155021.png]]

### Array Sequence
컴퓨터 메모리는 한정된 자원입니다.
근대 컴퓨터의 많은 프로세스들은 같은 메모리 저장소를 공유할 수 있습니다. 그래서 운영체제는 각각의 활성화된 프로세스에 메모리의 고정된 청크를 할당합니다 
할당된 메모리의 양은 프로세스의 필요와 사용 가능한 여유 메모리에 따라 달라집니다. 

예를 들어 컴퓨터 프로그램이 변수를 저장하기 위한 요청을 만들 때, 프로그램은 운영체제에게 저장하기 위해 메모리가 얼만큼 필요한지 알려야 합니다.

요청을 충족시키기 위해, 운영 체제는 프로세스에 할당된 메모리 주소 공간에서 사용 가능한 메모리를 찾아 그 목적을 위해 예약(즉, 할당)할 것이며, 그것이 더 이상 필요하지 않을 때까지 유지됩니다.

컴퓨터 프로그램이 64비트 단어 열 개씩 저장하는 두 개의 배열을 저장하고자 한다고 가정해 봅시다. 
프로그램은 메모리의 두 덩어리(각각 640비트)에 대해 별도의 요청을 하고, 예를 들어 운영체제는 프로세스에 할당된 주소 공간의 첫 번째 단어를 첫 번째 배열 A에, 그리고 주소 공간의 두 번째 열 단어를 두 번째 배열 B에 예약함으로써 요청을 충족시킵니다. 
이제 컴퓨터 프로그램이 진행됨에 따라 배열 A에 열한 번째 단어 w를 추가해야 한다고 가정해 봅시다. A 근처에 새 단어를 저장할 공간이 없어 보입니다: 프로세스에 할당된 주소 공간의 시작이 A의 왼쪽에 있고 배열 B는 오른쪽에 저장되어 있습니다. 

그렇다면 우리는 어떻게 w를 A에 추가할 수 있을까요? 한 가지 해결책은 B를 오른쪽으로 이동하여 w를 위한 공간을 만드는 것이지만, B 옆에 이미 예약된 엄청난 양의 데이터도 이동시켜야 할 수 있습니다. 

더 나은 방법은 새로운 메모리에 열한 개의 단어를 요청하고, A를 새 메모리 할당의 시작 부분에 복사하고, w를 끝에 저장한 다음, 프로세스의 주소 공간 첫 열 단어를 미래의 메모리 요청을 위해 해제하는 것일 것입니다.