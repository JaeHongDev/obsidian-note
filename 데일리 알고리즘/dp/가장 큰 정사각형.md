n×m의 0, 1로 된 배열이 있다. 이 배열에서 1로 된 가장 큰 정사각형의 크기를 구하는 프로그램을 작성하시오.

|   |   |   |   |
|---|---|---|---|
|0|1|0|0|
|0|1|1|1|
|1|1|1|0|
|0|0|1|0|

위와 같은 예제에서는 가운데의 2×2 배열이 가장 큰 정사각형이다.

## 입력

첫째 줄에 n, m(1 ≤ n, m ≤ 1,000)이 주어진다. 다음 n개의 줄에는 m개의 숫자로 배열이 주어진다.

## 출력

첫째 줄에 가장 큰 정사각형의 넓이를 출력한다.

#### 풀이
```

생각보다 간단한데?

결국 각 변의 길이가 2 -> 3 -> 4 순서대로 늘어는건데

정사각형도 2*2, 3*3, 4*4로 늘어남

4x4 정사각형에서
최대한 크기가 가장 큰 정사각형을 만드려면

1*1이 되는지 확인
(0,0,1) (0,1,1) (0,2,1) (0,3,1)
(1,0,1) (1,1,1) (1,2,1) (1,3,1)
(2,0,1) (2,1,1) (2,2,1) (2,3,1)
(3,0,1) (3,1,1) (3,2,1) (3,3,1)

이제 다음 2*2가 되는 경우를 확인하려면
(0,0,2) = min((0,0,1),(0,1,1),(1,0,1)(1,1,1)) 이 된다. 각 요소가 1이 되어야 가능함
(0,1,2) = min((0,1,1),(0,2,1),(1,1,1),(1,2,1)) ? 1 

즉 이런식으로 일 부분을 캐싱 할 수 있다.

각 요소가 캐시 되지 않는 경우에는 결국 처리할 수 없다.

일단 캐시값을 어떻게 처리해야하지?
정사각형인줄 알았는데 상관없나?


3 2

가장 작은 값에 홀수면 -1 짝수면 그대로

```
### 의사코드
```java

recursive = (현재 N크기, 현재 M크기, 정사각형 크기) -> {
	if(N 혹은 M의 크기가 0보다 작다면) return 0;

	var flag = false; 
	for(int i = 0; i < 현재 N의 크기; i++){
		for(int j = 0; j < 현재 M의 크기; j++){
			recursive(현재 N의 크기 + 1)
		}	   
	}
}
```